2026-01-06 15:34:45,656 - INFO - [LLM registry 9cc59795-ac71-4d8f-b4b1-8a1017eb2792]: Registering service for agent
2026-01-06 15:34:45,695 - INFO - Building image: ghcr.io/openhands/runtime:oh_v1.0.0_7umkz9m593wz57ax_v008aov5t6vw3gr5
2026-01-06 15:46:37,304 - INFO - Image [ghcr.io/openhands/runtime:oh_v1.0.0_7umkz9m593wz57ax_v008aov5t6vw3gr5] build finished.
2026-01-06 15:46:37,309 - INFO - Re-tagged image [ghcr.io/openhands/runtime:oh_v1.0.0_7umkz9m593wz57ax_v008aov5t6vw3gr5] with more generic tag [oh_v1.0.0_7umkz9m593wz57ax]
2026-01-06 15:46:37,311 - INFO - Image ghcr.io/openhands/runtime with tags [oh_v1.0.0_7umkz9m593wz57ax_v008aov5t6vw3gr5, oh_v1.0.0_7umkz9m593wz57ax] built successfully
2026-01-06 15:46:37,347 - INFO - [runtime 1d00f53b-dbe4-47-c594c5464a4ebeb] Starting runtime with image: ghcr.io/openhands/runtime:oh_v1.0.0_7umkz9m593wz57ax_v008aov5t6vw3gr5
2026-01-06 15:46:37,479 - INFO - [runtime 1d00f53b-dbe4-47-c594c5464a4ebeb] Starting server with command: ['/openhands/micromamba/bin/micromamba', 'run', '-n', 'openhands', 'poetry', 'run', 'python', '-u', '-m', 'openhands.runtime.action_execution_server', '38125', '--working-dir', '/workspace', '--plugins', 'agent_skills', 'jupyter', '--username', 'root', '--user-id', '0', '--no-enable-browser']
2026-01-06 15:46:37,781 - INFO - [runtime 1d00f53b-dbe4-47-c594c5464a4ebeb] Container started: openhands-runtime-1d00f53b-dbe4-47-c594c5464a4ebeb. VSCode URL: None
2026-01-06 15:46:37,782 - INFO - [runtime 1d00f53b-dbe4-47-c594c5464a4ebeb] Waiting for client to become ready at http://localhost:38125...
2026-01-06 15:47:05,914 - INFO - [runtime 1d00f53b-dbe4-47-c594c5464a4ebeb] Runtime is ready.
2026-01-06 15:47:09,039 - INFO - Successfully configured git: name=openhands, email=openhands@all-hands.dev
2026-01-06 15:47:09,040 - INFO - ------------------------------
2026-01-06 15:47:09,040 - INFO - BEGIN Runtime Initialization Fn
2026-01-06 15:47:09,040 - INFO - ------------------------------
2026-01-06 15:47:09,041 - INFO - **CmdRunAction (source=None, is_input=False)**
COMMAND:
echo 'export SWE_INSTANCE_ID=matplotlib__matplotlib-25433' >> ~/.bashrc && echo 'export PIP_CACHE_DIR=~/.cache/pip' >> ~/.bashrc && echo "alias git='git --no-pager'" >> ~/.bashrc && git config --global core.pager "" && git config --global diff.binary false
2026-01-06 15:47:09,663 - INFO - **CmdOutputObservation (source=None, exit code=0, metadata={
  "exit_code": 0,
  "pid": -1,
  "username": "root",
  "hostname": "cf4d9f88e54a",
  "working_dir": "/workspace",
  "py_interpreter_path": "/openhands/micromamba/envs/openhands/bin/python",
  "prefix": "",
  "suffix": "\n[The command completed with exit code 0.]"
})**
--BEGIN AGENT OBSERVATION--

[The command completed with exit code 0.]
[Current working directory: /workspace]
[Python interpreter: /openhands/micromamba/envs/openhands/bin/python]
[Command finished with exit code 0]
--END AGENT OBSERVATION--
2026-01-06 15:47:09,663 - INFO - **CmdRunAction (source=None, is_input=False)**
COMMAND:
export USER=$(whoami); echo USER=${USER} 
2026-01-06 15:47:10,290 - INFO - **CmdOutputObservation (source=None, exit code=0, metadata={
  "exit_code": 0,
  "pid": -1,
  "username": "root",
  "hostname": "cf4d9f88e54a",
  "working_dir": "/workspace",
  "py_interpreter_path": "/openhands/micromamba/envs/openhands/bin/python",
  "prefix": "",
  "suffix": "\n[The command completed with exit code 0.]"
})**
--BEGIN AGENT OBSERVATION--
USER=root
[The command completed with exit code 0.]
[Current working directory: /workspace]
[Python interpreter: /openhands/micromamba/envs/openhands/bin/python]
[Command finished with exit code 0]
--END AGENT OBSERVATION--
2026-01-06 15:47:10,291 - INFO - **CmdRunAction (source=None, is_input=False)**
COMMAND:
mkdir -p /swe_util/eval_data/instances
2026-01-06 15:47:10,911 - INFO - **CmdOutputObservation (source=None, exit code=0, metadata={
  "exit_code": 0,
  "pid": -1,
  "username": "root",
  "hostname": "cf4d9f88e54a",
  "working_dir": "/workspace",
  "py_interpreter_path": "/openhands/micromamba/envs/openhands/bin/python",
  "prefix": "",
  "suffix": "\n[The command completed with exit code 0.]"
})**
--BEGIN AGENT OBSERVATION--

[The command completed with exit code 0.]
[Current working directory: /workspace]
[Python interpreter: /openhands/micromamba/envs/openhands/bin/python]
[Command finished with exit code 0]
--END AGENT OBSERVATION--
2026-01-06 15:47:10,916 - INFO - **CmdRunAction (source=None, is_input=False)**
COMMAND:
cat ~/.bashrc
2026-01-06 15:47:11,533 - INFO - **CmdOutputObservation (source=None, exit code=0, metadata={
  "exit_code": 0,
  "pid": -1,
  "username": "root",
  "hostname": "cf4d9f88e54a",
  "working_dir": "/workspace",
  "py_interpreter_path": "/openhands/micromamba/envs/openhands/bin/python",
  "prefix": "",
  "suffix": "\n[The command completed with exit code 0.]"
})**
--BEGIN AGENT OBSERVATION--
source /opt/miniconda3/etc/profile.d/conda.sh && conda activate testbed

. "/openhands/bin/env"
export PATH="/usr/bin:/bin:/usr/sbin:/sbin:/openhands/micromamba/bin:$PATH"
export PLAYWRIGHT_BROWSERS_PATH=/opt/playwright-browsers
eval "$(/openhands/micromamba/bin/micromamba shell hook --shell bash)"
micromamba activate openhands 2>/dev/null || true
export ENABLE_AUTO_LINT=true
export NO_CHANGE_TIMEOUT_SECONDS=30
export OPENHANDS_EVAL_INSTANCE_ID=matplotlib__matplotlib-25433
export OPENHANDS_EVAL_JOB_ID=3684925519
export OPENHANDS_TIMING_DIR=./continuum32/princeton-nlp__SWE-bench_Lite-test/CodeActAgent/GLM-4.6-FP8_maxiter_135/timing
export SWE_INSTANCE_ID=matplotlib__matplotlib-25433
export PIP_CACHE_DIR=~/.cache/pip
alias git='git --no-pager'
[The command completed with exit code 0.]
[Current working directory: /workspace]
[Python interpreter: /openhands/micromamba/envs/openhands/bin/python]
[Command finished with exit code 0]
--END AGENT OBSERVATION--
2026-01-06 15:47:11,534 - INFO - **CmdRunAction (source=None, is_input=False)**
COMMAND:
source ~/.bashrc
2026-01-06 15:47:12,152 - INFO - **CmdOutputObservation (source=None, exit code=0, metadata={
  "exit_code": 0,
  "pid": -1,
  "username": "root",
  "hostname": "cf4d9f88e54a",
  "working_dir": "/workspace",
  "py_interpreter_path": "/openhands/micromamba/envs/openhands/bin/python",
  "prefix": "",
  "suffix": "\n[The command completed with exit code 0.]"
})**
--BEGIN AGENT OBSERVATION--

[The command completed with exit code 0.]
[Current working directory: /workspace]
[Python interpreter: /openhands/micromamba/envs/openhands/bin/python]
[Command finished with exit code 0]
--END AGENT OBSERVATION--
2026-01-06 15:47:12,152 - INFO - **CmdRunAction (source=None, is_input=False)**
COMMAND:
source /swe_util/instance_swe_entry.sh
2026-01-06 15:47:15,287 - INFO - **CmdOutputObservation (source=None, exit code=0, metadata={
  "exit_code": 0,
  "pid": -1,
  "username": "root",
  "hostname": "cf4d9f88e54a",
  "working_dir": "/workspace",
  "py_interpreter_path": "/opt/miniconda3/envs/testbed/bin/python",
  "prefix": "",
  "suffix": "\n[The command completed with exit code 0.]"
})**
--BEGIN AGENT OBSERVATION--
WORKSPACE_NAME: matplotlib__matplotlib__3.7
[The command completed with exit code 0.]
[Current working directory: /workspace]
[Python interpreter: /opt/miniconda3/envs/testbed/bin/python]
[Command finished with exit code 0]
--END AGENT OBSERVATION--
2026-01-06 15:47:15,287 - INFO - **CmdRunAction (source=None, is_input=False)**
COMMAND:
cd /workspace/matplotlib__matplotlib__3.7
2026-01-06 15:47:15,908 - INFO - **CmdOutputObservation (source=None, exit code=0, metadata={
  "exit_code": 0,
  "pid": -1,
  "username": "root",
  "hostname": "cf4d9f88e54a",
  "working_dir": "/workspace/matplotlib__matplotlib__3.7",
  "py_interpreter_path": "/opt/miniconda3/envs/testbed/bin/python",
  "prefix": "",
  "suffix": "\n[The command completed with exit code 0.]"
})**
--BEGIN AGENT OBSERVATION--

[The command completed with exit code 0.]
[Current working directory: /workspace/matplotlib__matplotlib__3.7]
[Python interpreter: /opt/miniconda3/envs/testbed/bin/python]
[Command finished with exit code 0]
--END AGENT OBSERVATION--
2026-01-06 15:47:15,908 - INFO - **CmdRunAction (source=None, is_input=False)**
COMMAND:
git reset --hard
2026-01-06 15:47:17,532 - INFO - **CmdOutputObservation (source=None, exit code=0, metadata={
  "exit_code": 0,
  "pid": -1,
  "username": "root",
  "hostname": "cf4d9f88e54a",
  "working_dir": "/workspace/matplotlib__matplotlib__3.7",
  "py_interpreter_path": "/opt/miniconda3/envs/testbed/bin/python",
  "prefix": "",
  "suffix": "\n[The command completed with exit code 0.]"
})**
--BEGIN AGENT OBSERVATION--
Updating files: 100% (4407/4407), done.
HEAD is now at 7eafdd8af3 Merge pull request #25423 from jklymak/bld-pst013-compat
[The command completed with exit code 0.]
[Current working directory: /workspace/matplotlib__matplotlib__3.7]
[Python interpreter: /opt/miniconda3/envs/testbed/bin/python]
[Command finished with exit code 0]
--END AGENT OBSERVATION--
2026-01-06 15:47:17,532 - INFO - **CmdRunAction (source=None, is_input=False)**
COMMAND:
for remote_name in $(git remote); do git remote remove "${remote_name}"; done
2026-01-06 15:47:18,153 - INFO - **CmdOutputObservation (source=None, exit code=0, metadata={
  "exit_code": 0,
  "pid": -1,
  "username": "root",
  "hostname": "cf4d9f88e54a",
  "working_dir": "/workspace/matplotlib__matplotlib__3.7",
  "py_interpreter_path": "/opt/miniconda3/envs/testbed/bin/python",
  "prefix": "",
  "suffix": "\n[The command completed with exit code 0.]"
})**
--BEGIN AGENT OBSERVATION--

[The command completed with exit code 0.]
[Current working directory: /workspace/matplotlib__matplotlib__3.7]
[Python interpreter: /opt/miniconda3/envs/testbed/bin/python]
[Command finished with exit code 0]
--END AGENT OBSERVATION--
2026-01-06 15:47:18,153 - INFO - **CmdRunAction (source=None, is_input=False)**
COMMAND:
which python
2026-01-06 15:47:18,776 - INFO - **CmdOutputObservation (source=None, exit code=0, metadata={
  "exit_code": 0,
  "pid": -1,
  "username": "root",
  "hostname": "cf4d9f88e54a",
  "working_dir": "/workspace/matplotlib__matplotlib__3.7",
  "py_interpreter_path": "/opt/miniconda3/envs/testbed/bin/python",
  "prefix": "",
  "suffix": "\n[The command completed with exit code 0.]"
})**
--BEGIN AGENT OBSERVATION--
/opt/miniconda3/envs/testbed/bin/python
[The command completed with exit code 0.]
[Current working directory: /workspace/matplotlib__matplotlib__3.7]
[Python interpreter: /opt/miniconda3/envs/testbed/bin/python]
[Command finished with exit code 0]
--END AGENT OBSERVATION--
2026-01-06 15:47:18,776 - INFO - ------------------------------
2026-01-06 15:47:18,777 - INFO - END Runtime Initialization Fn
2026-01-06 15:47:18,777 - INFO - ------------------------------
2026-01-06 15:47:18,781 - INFO - [LLM registry be466f0c-cf3a-451b-b6b9-0c8d17d96229]: Registering service for agent
2026-01-06 15:47:18,799 - INFO - [runtime 1d00f53b-dbe4-47-c594c5464a4ebeb] Selected repo: None, loading microagents from /workspace/.openhands/microagents (inside runtime)
2026-01-06 15:47:18,802 - INFO - [runtime 1d00f53b-dbe4-47-c594c5464a4ebeb] Attempting to list files in repository microagents directory: /workspace/.openhands/microagents
2026-01-06 15:47:18,804 - INFO - Loading user workspace microagents: []
2026-01-06 15:47:18,805 - INFO - AgentController 1d00f53b-dbe4-47-c594c5464a4ebeb - created new state. start_id: 0
2026-01-06 15:47:18,812 - INFO - [Agent Controller 1d00f53b-dbe4-47-c594c5464a4ebeb] Setting agent(CodeActAgent) state from AgentState.LOADING to AgentState.RUNNING
2026-01-06 15:47:18,814 - INFO - Saved conversation stats
2026-01-06 15:58:22,650 - WARNING - Action, ErrorObservation loop detected
2026-01-06 15:58:22,650 - ERROR - AgentStuckInLoopError: Agent got stuck in a loop
2026-01-06 15:58:22,651 - INFO - [Agent Controller 1d00f53b-dbe4-47-c594c5464a4ebeb] Setting agent(CodeActAgent) state from AgentState.RUNNING to AgentState.ERROR
2026-01-06 15:58:22,653 - INFO - Saved conversation stats
2026-01-06 15:58:22,653 - INFO - [Agent Controller 1d00f53b-dbe4-47-c594c5464a4ebeb] Setting agent(CodeActAgent) state from AgentState.ERROR to AgentState.ERROR
2026-01-06 15:58:23,629 - INFO - ------------------------------
2026-01-06 15:58:23,629 - INFO - BEGIN Runtime Completion Fn
2026-01-06 15:58:23,630 - INFO - ------------------------------
2026-01-06 15:58:23,630 - INFO - **CmdRunAction (source=None, is_input=False)**
COMMAND:
cd /workspace/matplotlib__matplotlib__3.7
2026-01-06 15:58:24,249 - INFO - **CmdOutputObservation (source=None, exit code=0, metadata={
  "exit_code": 0,
  "pid": -1,
  "username": "root",
  "hostname": "cf4d9f88e54a",
  "working_dir": "/workspace/matplotlib__matplotlib__3.7",
  "py_interpreter_path": "/opt/miniconda3/envs/testbed/bin/python",
  "prefix": "",
  "suffix": "\n[The command completed with exit code 0.]"
})**
--BEGIN AGENT OBSERVATION--

[The command completed with exit code 0.]
[Current working directory: /workspace/matplotlib__matplotlib__3.7]
[Python interpreter: /opt/miniconda3/envs/testbed/bin/python]
[Command finished with exit code 0]
--END AGENT OBSERVATION--
2026-01-06 15:58:24,250 - INFO - **CmdRunAction (source=None, is_input=False)**
COMMAND:
git config --global core.pager ""
2026-01-06 15:58:24,878 - INFO - **CmdOutputObservation (source=None, exit code=0, metadata={
  "exit_code": 0,
  "pid": -1,
  "username": "root",
  "hostname": "cf4d9f88e54a",
  "working_dir": "/workspace/matplotlib__matplotlib__3.7",
  "py_interpreter_path": "/opt/miniconda3/envs/testbed/bin/python",
  "prefix": "",
  "suffix": "\n[The command completed with exit code 0.]"
})**
--BEGIN AGENT OBSERVATION--

[The command completed with exit code 0.]
[Current working directory: /workspace/matplotlib__matplotlib__3.7]
[Python interpreter: /opt/miniconda3/envs/testbed/bin/python]
[Command finished with exit code 0]
--END AGENT OBSERVATION--
2026-01-06 15:58:24,878 - INFO - **CmdRunAction (source=None, is_input=False)**
COMMAND:
find . -type d -name .git -not -path "./.git"
2026-01-06 15:58:25,504 - INFO - **CmdOutputObservation (source=None, exit code=0, metadata={
  "exit_code": 0,
  "pid": -1,
  "username": "root",
  "hostname": "cf4d9f88e54a",
  "working_dir": "/workspace/matplotlib__matplotlib__3.7",
  "py_interpreter_path": "/opt/miniconda3/envs/testbed/bin/python",
  "prefix": "",
  "suffix": "\n[The command completed with exit code 0.]"
})**
--BEGIN AGENT OBSERVATION--

[The command completed with exit code 0.]
[Current working directory: /workspace/matplotlib__matplotlib__3.7]
[Python interpreter: /opt/miniconda3/envs/testbed/bin/python]
[Command finished with exit code 0]
--END AGENT OBSERVATION--
2026-01-06 15:58:25,505 - INFO - **CmdRunAction (source=None, is_input=False)**
COMMAND:
git add -A
2026-01-06 15:58:26,124 - INFO - **CmdOutputObservation (source=None, exit code=0, metadata={
  "exit_code": 0,
  "pid": -1,
  "username": "root",
  "hostname": "cf4d9f88e54a",
  "working_dir": "/workspace/matplotlib__matplotlib__3.7",
  "py_interpreter_path": "/opt/miniconda3/envs/testbed/bin/python",
  "prefix": "",
  "suffix": "\n[The command completed with exit code 0.]"
})**
--BEGIN AGENT OBSERVATION--

[The command completed with exit code 0.]
[Current working directory: /workspace/matplotlib__matplotlib__3.7]
[Python interpreter: /opt/miniconda3/envs/testbed/bin/python]
[Command finished with exit code 0]
--END AGENT OBSERVATION--
2026-01-06 15:58:26,124 - INFO - **CmdRunAction (source=None, is_input=False)**
COMMAND:
for file in $(git status --porcelain | grep -E "^(M| M|\?\?|A| A)" | cut -c4-); do
        if [ -f "$file" ] && (file "$file" | grep -q "executable" || git check-attr binary "$file" | grep -q "binary: set"); then
            git rm -f "$file" 2>/dev/null || rm -f "$file"
            echo "Removed: $file"
        fi
    done
2026-01-06 15:58:26,748 - INFO - **CmdOutputObservation (source=None, exit code=0, metadata={
  "exit_code": 0,
  "pid": -1,
  "username": "root",
  "hostname": "cf4d9f88e54a",
  "working_dir": "/workspace/matplotlib__matplotlib__3.7",
  "py_interpreter_path": "/opt/miniconda3/envs/testbed/bin/python",
  "prefix": "",
  "suffix": "\n[The command completed with exit code 0.]"
})**
--BEGIN AGENT OBSERVATION--
bash: file: command not found
bash: file: command not found
bash: file: command not found
bash: file: command not found
bash: file: command not found
[The command completed with exit code 0.]
[Current working directory: /workspace/matplotlib__matplotlib__3.7]
[Python interpreter: /opt/miniconda3/envs/testbed/bin/python]
[Command finished with exit code 0]
--END AGENT OBSERVATION--
2026-01-06 15:58:26,748 - INFO - **CmdRunAction (source=None, is_input=False)**
COMMAND:
git diff --no-color --cached 7eafdd8af3c523c1c77b027d378fb337dd489f18 > patch.diff
2026-01-06 15:58:27,373 - INFO - **CmdOutputObservation (source=None, exit code=0, metadata={
  "exit_code": 0,
  "pid": -1,
  "username": "root",
  "hostname": "cf4d9f88e54a",
  "working_dir": "/workspace/matplotlib__matplotlib__3.7",
  "py_interpreter_path": "/opt/miniconda3/envs/testbed/bin/python",
  "prefix": "",
  "suffix": "\n[The command completed with exit code 0.]"
})**
--BEGIN AGENT OBSERVATION--

[The command completed with exit code 0.]
[Current working directory: /workspace/matplotlib__matplotlib__3.7]
[Python interpreter: /opt/miniconda3/envs/testbed/bin/python]
[Command finished with exit code 0]
--END AGENT OBSERVATION--
2026-01-06 15:58:27,375 - INFO - FileReadAction(path='patch.diff', start=0, end=-1, thought='', action=<ActionType.READ: 'read'>, security_risk=<ActionSecurityRisk.UNKNOWN: -1>, impl_source=<FileReadSource.DEFAULT: 'default'>, view_range=None)
2026-01-06 15:58:27,379 - INFO - [Read from /workspace/matplotlib__matplotlib__3.7/patch.diff is successful.]
diff --git a/direct_test.py b/direct_test.py
new file mode 100644
index 0000000000..839d92b8eb
--- /dev/null
+++ b/direct_test.py
@@ -0,0 +1,48 @@
+import matplotlib.pyplot as plt
+import matplotlib.widgets as widgets
+
+def test_direct_mouse_grab():
+    """Direct test of mouse grab behavior."""
+    
+    fig = plt.figure()
+    
+    # Create RangeSlider
+    slider_ax = plt.axes([0.2, 0.2, 0.6, 0.1])
+    slider = widgets.RangeSlider(slider_ax, "Test", valmin=1, valmax=10, valinit=(3, 7))
+    
+    # Manually grab the mouse to simulate the issue
+    print("=== Testing mouse grab behavior ===")
+    print(f"Initial grabber: {fig.canvas.mouse_grabber}")
+    
+    # Simulate what happens during slider interaction
+    fig.canvas.grab_mouse(slider_ax)
+    print(f"After grab_mouse: {fig.canvas.mouse_grabber}")
+    
+    # Now simulate the callback that clears the figure
+    def problem_callback(values):
+        print(f"In callback with values: {values}")
+        print(f"Grabber before clf: {fig.canvas.mouse_grabber}")
+        
+        # This is the problematic behavior
+        plt.clf()
+        
+        print(f"Grabber after clf: {fig.canvas.mouse_grabber}")
+        
+        # Recreate widgets
+        new_slider_ax = plt.axes([0.2, 0.2, 0.6, 0.1])
+        new_slider = widgets.RangeSlider(new_slider_ax, "Test", valmin=1, valmax=10, valinit=values)
+        
+        plt.draw()
+        
+        print(f"Grabber after redraw: {fig.canvas.mouse_grabber}")
+    
+    # Call the callback to simulate the issue
+    problem_callback((4, 6))
+    
+    # Now test what should happen - proper release
+    print("\n=== Testing proper release ===")
+    fig.canvas.release_mouse(slider_ax)
+    print(f"After release_mouse: {fig.canvas.mouse_grabber}")
+
+if __name__ == "__main__":
+    test_direct_mouse_grab()
diff --git a/grab_test.py b/grab_test.py
new file mode 100644
index 0000000000..cb95618bc1
--- /dev/null
+++ b/grab_test.py
@@ -0,0 +1,66 @@
+import matplotlib.pyplot as plt
+import matplotlib.widgets as widgets
+from matplotlib.backend_bases import MouseEvent
+
+def test_mouse_grab_simulation():
+    """Test that simulates the actual mouse grab/release sequence."""
+    
+    fig = plt.figure()
+    
+    # Create RangeSlider
+    slider_ax = plt.axes([0.2, 0.2, 0.6, 0.1])
+    slider = widgets.RangeSlider(slider_ax, "Test", valmin=1, valmax=10, valinit=(3, 7))
+    
+    callback_called = False
+    
+    def on_slider_changed(values):
+        nonlocal callback_called
+        callback_called = True
+        print(f"Slider changed to: {values}")
+        print(f"Mouse grabber in callback: {getattr(fig.canvas, '_mouse_grabber', None)}")
+        
+        # This is the problematic behavior from the issue
+        plt.clf()
+        
+        print(f"Mouse grabber after clf: {getattr(fig.canvas, '_mouse_grabber', None)}")
+        
+        # Recreate widgets
+        new_slider_ax = plt.axes([0.2, 0.2, 0.6, 0.1])
+        new_slider = widgets.RangeSlider(new_slider_ax, "Test", valmin=1, valmax=10, valinit=values)
+        
+        plt.draw()
+        
+        print(f"Mouse grabber after redraw: {getattr(fig.canvas, '_mouse_grabber', None)}")
+    
+    slider.on_changed(on_slider_changed)
+    
+    # Simulate the actual mouse interaction sequence
+    print("=== Simulating mouse interaction ===")
+    
+    # 1. Mouse press on slider - click near the first handle (value 3)
+    mouse_press = MouseEvent('button_press_event', fig.canvas, x=0.5, y=0.25, button=1)
+    mouse_press.inaxes = slider_ax
+    # Set data coordinates to be near the first handle (value 3)
+    mouse_press.xdata = 3.0  # Near first handle
+    mouse_press.ydata = 0.5
+    
+    print(f"Before press - grabber: {getattr(fig.canvas, '_mouse_grabber', None)}")
+    slider._update(mouse_press)
+    print(f"After press - grabber: {getattr(fig.canvas, '_mouse_grabber', None)}")
+    print(f"drag_active: {slider.drag_active}")
+    
+    # 2. Mouse release to trigger callback
+    mouse_release = MouseEvent('button_release_event', fig.canvas, x=0.5, y=0.25, button=1)
+    mouse_release.inaxes = slider_ax
+    mouse_release.xdata = 3.0
+    mouse_release.ydata = 0.5
+    
+    slider._update(mouse_release)
+    print(f"After release - grabber: {getattr(fig.canvas, '_mouse_grabber', None)}")
+    print(f"drag_active: {slider.drag_active}")
+    print(f"Callback called: {callback_called}")
+    
+    return callback_called
+
+if __name__ == "__main__":
+    test_mouse_grab_simulation()
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..299336a616
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,29 @@
+import matplotlib.pyplot as pyplot
+import matplotlib.widgets as widgets
+
+def onchanged(values):
+    print("on changed")
+    print(values)
+    pyplot.clf()
+    addElements()
+    pyplot.draw()
+
+def onclick(e):
+    print("on click")
+    pyplot.clf()
+    addElements()
+    pyplot.draw()
+
+def addElements():
+    ax = pyplot.axes([0.1, 0.45, 0.8, 0.1])
+    global slider
+    slider = widgets.RangeSlider(ax, "Test", valmin=1, valmax=10, valinit=(1, 10))
+    slider.on_changed(onchanged)
+    ax = pyplot.axes([0.1, 0.30, 0.8, 0.1])
+    global button
+    button = widgets.Button(ax, "Test")
+    button.on_clicked(onclick)
+
+addElements()
+
+pyplot.show()
diff --git a/simple_test.py b/simple_test.py
new file mode 100644
index 0000000000..4b5290dcbd
--- /dev/null
+++ b/simple_test.py
@@ -0,0 +1,78 @@
+import matplotlib.pyplot as plt
+import matplotlib.widgets as widgets
+
+def test_mouse_grab_issue():
+    """Simple test to demonstrate the mouse grab issue."""
+    
+    fig = plt.figure()
+    
+    # Create RangeSlider
+    slider_ax = plt.axes([0.2, 0.2, 0.6, 0.1])
+    slider = widgets.RangeSlider(slider_ax, "Test", valmin=1, valmax=10, valinit=(3, 7))
+    
+    # Create Button for comparison
+    button_ax = plt.axes([0.2, 0.4, 0.6, 0.1])
+    button = widgets.Button(button_ax, "Test")
+    
+    def on_slider_changed(values):
+        print(f"Slider changed to: {values}")
+        print(f"Mouse grabber before clf: {getattr(fig.canvas, '_mouse_grabber', None)}")
+        
+        # This is the problematic behavior from the issue
+        plt.clf()
+        
+        print(f"Mouse grabber after clf: {getattr(fig.canvas, '_mouse_grabber', None)}")
+        
+        # Recreate widgets
+        new_slider_ax = plt.axes([0.2, 0.2, 0.6, 0.1])
+        new_slider = widgets.RangeSlider(new_slider_ax, "Test", valmin=1, valmax=10, valinit=values)
+        
+        new_button_ax = plt.axes([0.2, 0.4, 0.6, 0.1])
+        new_button = widgets.Button(new_button_ax, "Test")
+        
+        plt.draw()
+        
+        print(f"Mouse grabber after redraw: {getattr(fig.canvas, '_mouse_grabber', None)}")
+    
+    def on_button_clicked(event):
+        print(f"Button clicked")
+        print(f"Mouse grabber before clf: {getattr(fig.canvas, '_mouse_grabber', None)}")
+        
+        # Same behavior but with button
+        plt.clf()
+        
+        print(f"Mouse grabber after clf: {getattr(fig.canvas, '_mouse_grabber', None)}")
+        
+        # Recreate widgets
+        new_slider_ax = plt.axes([0.2, 0.2, 0.6, 0.1])
+        new_slider = widgets.RangeSlider(new_slider_ax, "Test", valmin=1, valmax=10, valinit=(3, 7))
+        
+        new_button_ax = plt.axes([0.2, 0.4, 0.6, 0.1])
+        new_button = widgets.Button(new_button_ax, "Test")
+        
+        plt.draw()
+        
+        print(f"Mouse grabber after redraw: {getattr(fig.canvas, '_mouse_grabber', None)}")
+    
+    slider.on_changed(on_slider_changed)
+    button.on_clicked(on_button_clicked)
+    
+    # Manually trigger the callbacks to simulate the issue
+    print("=== Testing Slider Callback ===")
+    on_slider_changed((4, 6))
+    
+    print("\n=== Testing Button Callback ===")
+    # Reset for button test
+    plt.clf()
+    button_ax2 = plt.axes([0.2, 0.4, 0.6, 0.1])
+    button2 = widgets.Button(button_ax2, "Test")
+    button2.on_clicked(on_button_clicked)
+    
+    # Create a dummy event for button
+    class DummyEvent:
+        pass
+    
+    on_button_clicked(DummyEvent())
+
+if __name__ == "__main__":
+    test_mouse_grab_issue()
diff --git a/test_mouse_grab.py b/test_mouse_grab.py
new file mode 100644
index 0000000000..585c98ffff
--- /dev/null
+++ b/test_mouse_grab.py
@@ -0,0 +1,135 @@
+import matplotlib.pyplot as plt
+import matplotlib.widgets as widgets
+from matplotlib.backend_bases import MouseEvent
+
+def test_range_slider_mouse_grab():
+    """Test to reproduce the mouse grab issue with RangeSlider."""
+    
+    # Create figure and widgets
+    fig, ax = plt.subplots()
+    
+    # Create RangeSlider
+    slider_ax = plt.axes([0.2, 0.2, 0.6, 0.1])
+    slider = widgets.RangeSlider(slider_ax, "Test", valmin=1, valmax=10, valinit=(3, 7))
+    
+    # Track mouse grab state
+    grab_state = {'grabbed': False, 'released': False}
+    
+    def onchanged(values):
+        print(f"Slider changed to: {values}")
+        # Simulate the problematic behavior: clear figure and redraw
+        plt.clf()
+        
+        # Recreate slider
+        new_slider_ax = plt.axes([0.2, 0.2, 0.6, 0.1])
+        new_slider = widgets.RangeSlider(new_slider_ax, "Test", valmin=1, valmax=10, valinit=values)
+        
+        # Check if mouse is still grabbed
+        if hasattr(fig.canvas, '_mouse_grabber'):
+            grab_state['grabbed'] = fig.canvas._mouse_grabber is not None
+            print(f"Mouse grabber after clf: {fig.canvas._mouse_grabber}")
+        
+        plt.draw()
+    
+    slider.on_changed(onchanged)
+    
+    # Simulate mouse press on slider - need to use data coordinates
+    # The slider is horizontal from x=1 to x=10, so let's click at x=5
+    mouse_event = MouseEvent('button_press_event', fig.canvas, 
+                           x=0.5, y=0.25, button=1)
+    mouse_event.inaxes = slider_ax
+    # Convert to data coordinates for the slider
+    mouse_event.xdata = 5.0  # Middle of slider range
+    mouse_event.ydata = 0.5
+    
+    # Check initial state
+    print(f"Initial mouse grabber: {getattr(fig.canvas, '_mouse_grabber', None)}")
+    
+    # Trigger the mouse press
+    slider._update(mouse_event)
+    
+    # Check if mouse was grabbed
+    print(f"Mouse grabber after press: {getattr(fig.canvas, '_mouse_grabber', None)}")
+    
+    # Simulate mouse release to trigger callback
+    mouse_release = MouseEvent('button_release_event', fig.canvas, 
+                             x=0.5, y=0.25, button=1)
+    mouse_release.inaxes = slider_ax
+    mouse_release.xdata = 5.0
+    mouse_release.ydata = 0.5
+    
+    slider._update(mouse_release)
+    
+    # Check final state
+    print(f"Mouse grabber after release: {getattr(fig.canvas, '_mouse_grabber', None)}")
+    print(f"Grab state: {grab_state}")
+    
+    return grab_state
+
+def test_button_mouse_grab():
+    """Test to compare with Button behavior."""
+    
+    fig, ax = plt.subplots()
+    
+    # Create Button
+    button_ax = plt.axes([0.2, 0.2, 0.6, 0.1])
+    button = widgets.Button(button_ax, "Test")
+    
+    # Track mouse grab state
+    grab_state = {'grabbed': False, 'released': False}
+    
+    def onclick(event):
+        print("Button clicked")
+        # Simulate the same behavior: clear figure and redraw
+        plt.clf()
+        
+        # Recreate button
+        new_button_ax = plt.axes([0.2, 0.2, 0.6, 0.1])
+        new_button = widgets.Button(new_button_ax, "Test")
+        
+        # Check if mouse is still grabbed
+        if hasattr(fig.canvas, '_mouse_grabber'):
+            grab_state['grabbed'] = fig.canvas._mouse_grabber is not None
+            print(f"Mouse grabber after clf: {fig.canvas._mouse_grabber}")
+        
+        plt.draw()
+    
+    button.on_clicked(onclick)
+    
+    # Simulate mouse press on button
+    mouse_event = MouseEvent('button_press_event', fig.canvas, 
+                           x=0.5, y=0.25, button=1)
+    mouse_event.inaxes = button_ax
+    
+    # Check initial state
+    print(f"Initial mouse grabber: {getattr(fig.canvas, '_mouse_grabber', None)}")
+    
+    # Trigger the mouse press
+    button._click(mouse_event)
+    
+    # Check if mouse was grabbed
+    print(f"Mouse grabber after press: {getattr(fig.canvas, '_mouse_grabber', None)}")
+    
+    # Simulate mouse release to trigger callback
+    mouse_release = MouseEvent('button_release_event', fig.canvas, 
+                             x=0.5, y=0.25, button=1)
+    mouse_release.inaxes = button_ax
+    
+    button._release(mouse_release)
+    
+    # Check final state
+    print(f"Mouse grabber after release: {getattr(fig.canvas, '_mouse_grabber', None)}")
+    print(f"Grab state: {grab_state}")
+    
+    return grab_state
+
+if __name__ == "__main__":
+    print("=== Testing RangeSlider mouse grab behavior ===")
+    slider_result = test_range_slider_mouse_grab()
+    
+    print("\n=== Testing Button mouse grab behavior ===")
+    button_result = test_button_mouse_grab()
+    
+    print(f"\n=== Comparison ===")
+    print(f"RangeSlider grab state: {slider_result}")
+    print(f"Button grab state: {button_result}")

2026-01-06 15:58:27,379 - INFO - ------------------------------
2026-01-06 15:58:27,379 - INFO - END Runtime Completion Fn
2026-01-06 15:58:27,379 - INFO - ------------------------------
2026-01-06 15:58:27,379 - INFO - Got git diff for instance matplotlib__matplotlib-25433:
--------
diff --git a/direct_test.py b/direct_test.py
new file mode 100644
index 0000000000..839d92b8eb
--- /dev/null
+++ b/direct_test.py
@@ -0,0 +1,48 @@
+import matplotlib.pyplot as plt
+import matplotlib.widgets as widgets
+
+def test_direct_mouse_grab():
+    """Direct test of mouse grab behavior."""
+    
+    fig = plt.figure()
+    
+    # Create RangeSlider
+    slider_ax = plt.axes([0.2, 0.2, 0.6, 0.1])
+    slider = widgets.RangeSlider(slider_ax, "Test", valmin=1, valmax=10, valinit=(3, 7))
+    
+    # Manually grab the mouse to simulate the issue
+    print("=== Testing mouse grab behavior ===")
+    print(f"Initial grabber: {fig.canvas.mouse_grabber}")
+    
+    # Simulate what happens during slider interaction
+    fig.canvas.grab_mouse(slider_ax)
+    print(f"After grab_mouse: {fig.canvas.mouse_grabber}")
+    
+    # Now simulate the callback that clears the figure
+    def problem_callback(values):
+        print(f"In callback with values: {values}")
+        print(f"Grabber before clf: {fig.canvas.mouse_grabber}")
+        
+        # This is the problematic behavior
+        plt.clf()
+        
+        print(f"Grabber after clf: {fig.canvas.mouse_grabber}")
+        
+        # Recreate widgets
+        new_slider_ax = plt.axes([0.2, 0.2, 0.6, 0.1])
+        new_slider = widgets.RangeSlider(new_slider_ax, "Test", valmin=1, valmax=10, valinit=values)
+        
+        plt.draw()
+        
+        print(f"Grabber after redraw: {fig.canvas.mouse_grabber}")
+    
+    # Call the callback to simulate the issue
+    problem_callback((4, 6))
+    
+    # Now test what should happen - proper release
+    print("\n=== Testing proper release ===")
+    fig.canvas.release_mouse(slider_ax)
+    print(f"After release_mouse: {fig.canvas.mouse_grabber}")
+
+if __name__ == "__main__":
+    test_direct_mouse_grab()
diff --git a/grab_test.py b/grab_test.py
new file mode 100644
index 0000000000..cb95618bc1
--- /dev/null
+++ b/grab_test.py
@@ -0,0 +1,66 @@
+import matplotlib.pyplot as plt
+import matplotlib.widgets as widgets
+from matplotlib.backend_bases import MouseEvent
+
+def test_mouse_grab_simulation():
+    """Test that simulates the actual mouse grab/release sequence."""
+    
+    fig = plt.figure()
+    
+    # Create RangeSlider
+    slider_ax = plt.axes([0.2, 0.2, 0.6, 0.1])
+    slider = widgets.RangeSlider(slider_ax, "Test", valmin=1, valmax=10, valinit=(3, 7))
+    
+    callback_called = False
+    
+    def on_slider_changed(values):
+        nonlocal callback_called
+        callback_called = True
+        print(f"Slider changed to: {values}")
+        print(f"Mouse grabber in callback: {getattr(fig.canvas, '_mouse_grabber', None)}")
+        
+        # This is the problematic behavior from the issue
+        plt.clf()
+        
+        print(f"Mouse grabber after clf: {getattr(fig.canvas, '_mouse_grabber', None)}")
+        
+        # Recreate widgets
+        new_slider_ax = plt.axes([0.2, 0.2, 0.6, 0.1])
+        new_slider = widgets.RangeSlider(new_slider_ax, "Test", valmin=1, valmax=10, valinit=values)
+        
+        plt.draw()
+        
+        print(f"Mouse grabber after redraw: {getattr(fig.canvas, '_mouse_grabber', None)}")
+    
+    slider.on_changed(on_slider_changed)
+    
+    # Simulate the actual mouse interaction sequence
+    print("=== Simulating mouse interaction ===")
+    
+    # 1. Mouse press on slider - click near the first handle (value 3)
+    mouse_press = MouseEvent('button_press_event', fig.canvas, x=0.5, y=0.25, button=1)
+    mouse_press.inaxes = slider_ax
+    # Set data coordinates to be near the first handle (value 3)
+    mouse_press.xdata = 3.0  # Near first handle
+    mouse_press.ydata = 0.5
+    
+    print(f"Before press - grabber: {getattr(fig.canvas, '_mouse_grabber', None)}")
+    slider._update(mouse_press)
+    print(f"After press - grabber: {getattr(fig.canvas, '_mouse_grabber', None)}")
+    print(f"drag_active: {slider.drag_active}")
+    
+    # 2. Mouse release to trigger callback
+    mouse_release = MouseEvent('button_release_event', fig.canvas, x=0.5, y=0.25, button=1)
+    mouse_release.inaxes = slider_ax
+    mouse_release.xdata = 3.0
+    mouse_release.ydata = 0.5
+    
+    slider._update(mouse_release)
+    print(f"After release - grabber: {getattr(fig.canvas, '_mouse_grabber', None)}")
+    print(f"drag_active: {slider.drag_active}")
+    print(f"Callback called: {callback_called}")
+    
+    return callback_called
+
+if __name__ == "__main__":
+    test_mouse_grab_simulation()
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..299336a616
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,29 @@
+import matplotlib.pyplot as pyplot
+import matplotlib.widgets as widgets
+
+def onchanged(values):
+    print("on changed")
+    print(values)
+    pyplot.clf()
+    addElements()
+    pyplot.draw()
+
+def onclick(e):
+    print("on click")
+    pyplot.clf()
+    addElements()
+    pyplot.draw()
+
+def addElements():
+    ax = pyplot.axes([0.1, 0.45, 0.8, 0.1])
+    global slider
+    slider = widgets.RangeSlider(ax, "Test", valmin=1, valmax=10, valinit=(1, 10))
+    slider.on_changed(onchanged)
+    ax = pyplot.axes([0.1, 0.30, 0.8, 0.1])
+    global button
+    button = widgets.Button(ax, "Test")
+    button.on_clicked(onclick)
+
+addElements()
+
+pyplot.show()
diff --git a/simple_test.py b/simple_test.py
new file mode 100644
index 0000000000..4b5290dcbd
--- /dev/null
+++ b/simple_test.py
@@ -0,0 +1,78 @@
+import matplotlib.pyplot as plt
+import matplotlib.widgets as widgets
+
+def test_mouse_grab_issue():
+    """Simple test to demonstrate the mouse grab issue."""
+    
+    fig = plt.figure()
+    
+    # Create RangeSlider
+    slider_ax = plt.axes([0.2, 0.2, 0.6, 0.1])
+    slider = widgets.RangeSlider(slider_ax, "Test", valmin=1, valmax=10, valinit=(3, 7))
+    
+    # Create Button for comparison
+    button_ax = plt.axes([0.2, 0.4, 0.6, 0.1])
+    button = widgets.Button(button_ax, "Test")
+    
+    def on_slider_changed(values):
+        print(f"Slider changed to: {values}")
+        print(f"Mouse grabber before clf: {getattr(fig.canvas, '_mouse_grabber', None)}")
+        
+        # This is the problematic behavior from the issue
+        plt.clf()
+        
+        print(f"Mouse grabber after clf: {getattr(fig.canvas, '_mouse_grabber', None)}")
+        
+        # Recreate widgets
+        new_slider_ax = plt.axes([0.2, 0.2, 0.6, 0.1])
+        new_slider = widgets.RangeSlider(new_slider_ax, "Test", valmin=1, valmax=10, valinit=values)
+        
+        new_button_ax = plt.axes([0.2, 0.4, 0.6, 0.1])
+        new_button = widgets.Button(new_button_ax, "Test")
+        
+        plt.draw()
+        
+        print(f"Mouse grabber after redraw: {getattr(fig.canvas, '_mouse_grabber', None)}")
+    
+    def on_button_clicked(event):
+        print(f"Button clicked")
+        print(f"Mouse grabber before clf: {getattr(fig.canvas, '_mouse_grabber', None)}")
+        
+        # Same behavior but with button
+        plt.clf()
+        
+        print(f"Mouse grabber after clf: {getattr(fig.canvas, '_mouse_grabber', None)}")
+        
+        # Recreate widgets
+        new_slider_ax = plt.axes([0.2, 0.2, 0.6, 0.1])
+        new_slider = widgets.RangeSlider(new_slider_ax, "Test", valmin=1, valmax=10, valinit=(3, 7))
+        
+        new_button_ax = plt.axes([0.2, 0.4, 0.6, 0.1])
+        new_button = widgets.Button(new_button_ax, "Test")
+        
+        plt.draw()
+        
+        print(f"Mouse grabber after redraw: {getattr(fig.canvas, '_mouse_grabber', None)}")
+    
+    slider.on_changed(on_slider_changed)
+    button.on_clicked(on_button_clicked)
+    
+    # Manually trigger the callbacks to simulate the issue
+    print("=== Testing Slider Callback ===")
+    on_slider_changed((4, 6))
+    
+    print("\n=== Testing Button Callback ===")
+    # Reset for button test
+    plt.clf()
+    button_ax2 = plt.axes([0.2, 0.4, 0.6, 0.1])
+    button2 = widgets.Button(button_ax2, "Test")
+    button2.on_clicked(on_button_clicked)
+    
+    # Create a dummy event for button
+    class DummyEvent:
+        pass
+    
+    on_button_clicked(DummyEvent())
+
+if __name__ == "__main__":
+    test_mouse_grab_issue()
diff --git a/test_mouse_grab.py b/test_mouse_grab.py
new file mode 100644
index 0000000000..585c98ffff
--- /dev/null
+++ b/test_mouse_grab.py
@@ -0,0 +1,135 @@
+import matplotlib.pyplot as plt
+import matplotlib.widgets as widgets
+from matplotlib.backend_bases import MouseEvent
+
+def test_range_slider_mouse_grab():
+    """Test to reproduce the mouse grab issue with RangeSlider."""
+    
+    # Create figure and widgets
+    fig, ax = plt.subplots()
+    
+    # Create RangeSlider
+    slider_ax = plt.axes([0.2, 0.2, 0.6, 0.1])
+    slider = widgets.RangeSlider(slider_ax, "Test", valmin=1, valmax=10, valinit=(3, 7))
+    
+    # Track mouse grab state
+    grab_state = {'grabbed': False, 'released': False}
+    
+    def onchanged(values):
+        print(f"Slider changed to: {values}")
+        # Simulate the problematic behavior: clear figure and redraw
+        plt.clf()
+        
+        # Recreate slider
+        new_slider_ax = plt.axes([0.2, 0.2, 0.6, 0.1])
+        new_slider = widgets.RangeSlider(new_slider_ax, "Test", valmin=1, valmax=10, valinit=values)
+        
+        # Check if mouse is still grabbed
+        if hasattr(fig.canvas, '_mouse_grabber'):
+            grab_state['grabbed'] = fig.canvas._mouse_grabber is not None
+            print(f"Mouse grabber after clf: {fig.canvas._mouse_grabber}")
+        
+        plt.draw()
+    
+    slider.on_changed(onchanged)
+    
+    # Simulate mouse press on slider - need to use data coordinates
+    # The slider is horizontal from x=1 to x=10, so let's click at x=5
+    mouse_event = MouseEvent('button_press_event', fig.canvas, 
+                           x=0.5, y=0.25, button=1)
+    mouse_event.inaxes = slider_ax
+    # Convert to data coordinates for the slider
+    mouse_event.xdata = 5.0  # Middle of slider range
+    mouse_event.ydata = 0.5
+    
+    # Check initial state
+    print(f"Initial mouse grabber: {getattr(fig.canvas, '_mouse_grabber', None)}")
+    
+    # Trigger the mouse press
+    slider._update(mouse_event)
+    
+    # Check if mouse was grabbed
+    print(f"Mouse grabber after press: {getattr(fig.canvas, '_mouse_grabber', None)}")
+    
+    # Simulate mouse release to trigger callback
+    mouse_release = MouseEvent('button_release_event', fig.canvas, 
+                             x=0.5, y=0.25, button=1)
+    mouse_release.inaxes = slider_ax
+    mouse_release.xdata = 5.0
+    mouse_release.ydata = 0.5
+    
+    slider._update(mouse_release)
+    
+    # Check final state
+    print(f"Mouse grabber after release: {getattr(fig.canvas, '_mouse_grabber', None)}")
+    print(f"Grab state: {grab_state}")
+    
+    return grab_state
+
+def test_button_mouse_grab():
+    """Test to compare with Button behavior."""
+    
+    fig, ax = plt.subplots()
+    
+    # Create Button
+    button_ax = plt.axes([0.2, 0.2, 0.6, 0.1])
+    button = widgets.Button(button_ax, "Test")
+    
+    # Track mouse grab state
+    grab_state = {'grabbed': False, 'released': False}
+    
+    def onclick(event):
+        print("Button clicked")
+        # Simulate the same behavior: clear figure and redraw
+        plt.clf()
+        
+        # Recreate button
+        new_button_ax = plt.axes([0.2, 0.2, 0.6, 0.1])
+        new_button = widgets.Button(new_button_ax, "Test")
+        
+        # Check if mouse is still grabbed
+        if hasattr(fig.canvas, '_mouse_grabber'):
+            grab_state['grabbed'] = fig.canvas._mouse_grabber is not None
+            print(f"Mouse grabber after clf: {fig.canvas._mouse_grabber}")
+        
+        plt.draw()
+    
+    button.on_clicked(onclick)
+    
+    # Simulate mouse press on button
+    mouse_event = MouseEvent('button_press_event', fig.canvas, 
+                           x=0.5, y=0.25, button=1)
+    mouse_event.inaxes = button_ax
+    
+    # Check initial state
+    print(f"Initial mouse grabber: {getattr(fig.canvas, '_mouse_grabber', None)}")
+    
+    # Trigger the mouse press
+    button._click(mouse_event)
+    
+    # Check if mouse was grabbed
+    print(f"Mouse grabber after press: {getattr(fig.canvas, '_mouse_grabber', None)}")
+    
+    # Simulate mouse release to trigger callback
+    mouse_release = MouseEvent('button_release_event', fig.canvas, 
+                             x=0.5, y=0.25, button=1)
+    mouse_release.inaxes = button_ax
+    
+    button._release(mouse_release)
+    
+    # Check final state
+    print(f"Mouse grabber after release: {getattr(fig.canvas, '_mouse_grabber', None)}")
+    print(f"Grab state: {grab_state}")
+    
+    return grab_state
+
+if __name__ == "__main__":
+    print("=== Testing RangeSlider mouse grab behavior ===")
+    slider_result = test_range_slider_mouse_grab()
+    
+    print("\n=== Testing Button mouse grab behavior ===")
+    button_result = test_button_mouse_grab()
+    
+    print(f"\n=== Comparison ===")
+    print(f"RangeSlider grab state: {slider_result}")
+    print(f"Button grab state: {button_result}")
--------
2026-01-06 15:58:33,989 - INFO - Using instance container image: docker.io/swebench/sweb.eval.x86_64.pytest-dev_1776_pytest-5227:latest. Please make sure this image exists. Submit an issue on https://github.com/OpenHands/OpenHands if you run into any issues.
2026-01-06 15:58:33,989 - INFO - Resource mapping for princeton-nlp__SWE-bench_Lite-test not found.
2026-01-06 15:58:33,990 - INFO - Logging LLM completions for instance pytest-dev__pytest-5227 to ./continuum32/princeton-nlp__SWE-bench_Lite-test/CodeActAgent/GLM-4.6-FP8_maxiter_135/llm_completions/pytest-dev__pytest-5227
2026-01-06 15:58:33,990 - INFO - Config file not found: config.toml. Error: [Errno 2] No such file or directory: 'config.toml'
2026-01-06 15:58:33,990 - INFO - Config file not found: [Errno 2] No such file or directory: 'config.toml'. Toml values have not been applied.
