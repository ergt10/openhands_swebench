2026-01-06 15:34:35,350 - INFO - [LLM registry def3b1a1-9c7b-4891-8def-86eb02be636f]: Registering service for agent
2026-01-06 15:34:35,411 - INFO - Building image: ghcr.io/openhands/runtime:oh_v1.0.0_rut1zvpfi2id3btc_v008aov5t6vw3gr5
2026-01-06 15:45:02,814 - INFO - Image [ghcr.io/openhands/runtime:oh_v1.0.0_rut1zvpfi2id3btc_v008aov5t6vw3gr5] build finished.
2026-01-06 15:45:02,820 - INFO - Re-tagged image [ghcr.io/openhands/runtime:oh_v1.0.0_rut1zvpfi2id3btc_v008aov5t6vw3gr5] with more generic tag [oh_v1.0.0_rut1zvpfi2id3btc]
2026-01-06 15:45:02,822 - INFO - Image ghcr.io/openhands/runtime with tags [oh_v1.0.0_rut1zvpfi2id3btc_v008aov5t6vw3gr5, oh_v1.0.0_rut1zvpfi2id3btc] built successfully
2026-01-06 15:45:02,853 - INFO - [runtime baa38a20-ebfb-49-0ba1975c5c961c4] Starting runtime with image: ghcr.io/openhands/runtime:oh_v1.0.0_rut1zvpfi2id3btc_v008aov5t6vw3gr5
2026-01-06 15:45:04,274 - INFO - [runtime baa38a20-ebfb-49-0ba1975c5c961c4] Starting server with command: ['/openhands/micromamba/bin/micromamba', 'run', '-n', 'openhands', 'poetry', 'run', 'python', '-u', '-m', 'openhands.runtime.action_execution_server', '37496', '--working-dir', '/workspace', '--plugins', 'agent_skills', 'jupyter', '--username', 'root', '--user-id', '0', '--no-enable-browser']
2026-01-06 15:45:04,589 - INFO - [runtime baa38a20-ebfb-49-0ba1975c5c961c4] Container started: openhands-runtime-baa38a20-ebfb-49-0ba1975c5c961c4. VSCode URL: None
2026-01-06 15:45:04,589 - INFO - [runtime baa38a20-ebfb-49-0ba1975c5c961c4] Waiting for client to become ready at http://localhost:37496...
2026-01-06 15:45:30,667 - INFO - [runtime baa38a20-ebfb-49-0ba1975c5c961c4] Runtime is ready.
2026-01-06 15:45:33,779 - INFO - Successfully configured git: name=openhands, email=openhands@all-hands.dev
2026-01-06 15:45:33,782 - INFO - ------------------------------
2026-01-06 15:45:33,782 - INFO - BEGIN Runtime Initialization Fn
2026-01-06 15:45:33,782 - INFO - ------------------------------
2026-01-06 15:45:33,783 - INFO - **CmdRunAction (source=None, is_input=False)**
COMMAND:
echo 'export SWE_INSTANCE_ID=matplotlib__matplotlib-25332' >> ~/.bashrc && echo 'export PIP_CACHE_DIR=~/.cache/pip' >> ~/.bashrc && echo "alias git='git --no-pager'" >> ~/.bashrc && git config --global core.pager "" && git config --global diff.binary false
2026-01-06 15:45:34,410 - INFO - **CmdOutputObservation (source=None, exit code=0, metadata={
  "exit_code": 0,
  "pid": -1,
  "username": "root",
  "hostname": "5327492ae6c5",
  "working_dir": "/workspace",
  "py_interpreter_path": "/openhands/micromamba/envs/openhands/bin/python",
  "prefix": "",
  "suffix": "\n[The command completed with exit code 0.]"
})**
--BEGIN AGENT OBSERVATION--

[The command completed with exit code 0.]
[Current working directory: /workspace]
[Python interpreter: /openhands/micromamba/envs/openhands/bin/python]
[Command finished with exit code 0]
--END AGENT OBSERVATION--
2026-01-06 15:45:34,410 - INFO - **CmdRunAction (source=None, is_input=False)**
COMMAND:
export USER=$(whoami); echo USER=${USER} 
2026-01-06 15:45:35,034 - INFO - **CmdOutputObservation (source=None, exit code=0, metadata={
  "exit_code": 0,
  "pid": -1,
  "username": "root",
  "hostname": "5327492ae6c5",
  "working_dir": "/workspace",
  "py_interpreter_path": "/openhands/micromamba/envs/openhands/bin/python",
  "prefix": "",
  "suffix": "\n[The command completed with exit code 0.]"
})**
--BEGIN AGENT OBSERVATION--
USER=root
[The command completed with exit code 0.]
[Current working directory: /workspace]
[Python interpreter: /openhands/micromamba/envs/openhands/bin/python]
[Command finished with exit code 0]
--END AGENT OBSERVATION--
2026-01-06 15:45:35,052 - INFO - **CmdRunAction (source=None, is_input=False)**
COMMAND:
mkdir -p /swe_util/eval_data/instances
2026-01-06 15:45:35,684 - INFO - **CmdOutputObservation (source=None, exit code=0, metadata={
  "exit_code": 0,
  "pid": -1,
  "username": "root",
  "hostname": "5327492ae6c5",
  "working_dir": "/workspace",
  "py_interpreter_path": "/openhands/micromamba/envs/openhands/bin/python",
  "prefix": "",
  "suffix": "\n[The command completed with exit code 0.]"
})**
--BEGIN AGENT OBSERVATION--

[The command completed with exit code 0.]
[Current working directory: /workspace]
[Python interpreter: /openhands/micromamba/envs/openhands/bin/python]
[Command finished with exit code 0]
--END AGENT OBSERVATION--
2026-01-06 15:45:35,689 - INFO - **CmdRunAction (source=None, is_input=False)**
COMMAND:
cat ~/.bashrc
2026-01-06 15:45:36,309 - INFO - **CmdOutputObservation (source=None, exit code=0, metadata={
  "exit_code": 0,
  "pid": -1,
  "username": "root",
  "hostname": "5327492ae6c5",
  "working_dir": "/workspace",
  "py_interpreter_path": "/openhands/micromamba/envs/openhands/bin/python",
  "prefix": "",
  "suffix": "\n[The command completed with exit code 0.]"
})**
--BEGIN AGENT OBSERVATION--
source /opt/miniconda3/etc/profile.d/conda.sh && conda activate testbed

. "/openhands/bin/env"
export PATH="/usr/bin:/bin:/usr/sbin:/sbin:/openhands/micromamba/bin:$PATH"
export PLAYWRIGHT_BROWSERS_PATH=/opt/playwright-browsers
eval "$(/openhands/micromamba/bin/micromamba shell hook --shell bash)"
micromamba activate openhands 2>/dev/null || true
export ENABLE_AUTO_LINT=true
export NO_CHANGE_TIMEOUT_SECONDS=30
export OPENHANDS_EVAL_INSTANCE_ID=matplotlib__matplotlib-25332
export OPENHANDS_EVAL_JOB_ID=2850793052
export OPENHANDS_TIMING_DIR=./continuum32/princeton-nlp__SWE-bench_Lite-test/CodeActAgent/GLM-4.6-FP8_maxiter_135/timing
export SWE_INSTANCE_ID=matplotlib__matplotlib-25332
export PIP_CACHE_DIR=~/.cache/pip
alias git='git --no-pager'
[The command completed with exit code 0.]
[Current working directory: /workspace]
[Python interpreter: /openhands/micromamba/envs/openhands/bin/python]
[Command finished with exit code 0]
--END AGENT OBSERVATION--
2026-01-06 15:45:36,309 - INFO - **CmdRunAction (source=None, is_input=False)**
COMMAND:
source ~/.bashrc
2026-01-06 15:45:36,928 - INFO - **CmdOutputObservation (source=None, exit code=0, metadata={
  "exit_code": 0,
  "pid": -1,
  "username": "root",
  "hostname": "5327492ae6c5",
  "working_dir": "/workspace",
  "py_interpreter_path": "/openhands/micromamba/envs/openhands/bin/python",
  "prefix": "",
  "suffix": "\n[The command completed with exit code 0.]"
})**
--BEGIN AGENT OBSERVATION--

[The command completed with exit code 0.]
[Current working directory: /workspace]
[Python interpreter: /openhands/micromamba/envs/openhands/bin/python]
[Command finished with exit code 0]
--END AGENT OBSERVATION--
2026-01-06 15:45:36,929 - INFO - **CmdRunAction (source=None, is_input=False)**
COMMAND:
source /swe_util/instance_swe_entry.sh
2026-01-06 15:45:41,066 - INFO - **CmdOutputObservation (source=None, exit code=0, metadata={
  "exit_code": 0,
  "pid": -1,
  "username": "root",
  "hostname": "5327492ae6c5",
  "working_dir": "/workspace",
  "py_interpreter_path": "/opt/miniconda3/envs/testbed/bin/python",
  "prefix": "",
  "suffix": "\n[The command completed with exit code 0.]"
})**
--BEGIN AGENT OBSERVATION--
WORKSPACE_NAME: matplotlib__matplotlib__3.7
[The command completed with exit code 0.]
[Current working directory: /workspace]
[Python interpreter: /opt/miniconda3/envs/testbed/bin/python]
[Command finished with exit code 0]
--END AGENT OBSERVATION--
2026-01-06 15:45:41,067 - INFO - **CmdRunAction (source=None, is_input=False)**
COMMAND:
cd /workspace/matplotlib__matplotlib__3.7
2026-01-06 15:45:41,688 - INFO - **CmdOutputObservation (source=None, exit code=0, metadata={
  "exit_code": 0,
  "pid": -1,
  "username": "root",
  "hostname": "5327492ae6c5",
  "working_dir": "/workspace/matplotlib__matplotlib__3.7",
  "py_interpreter_path": "/opt/miniconda3/envs/testbed/bin/python",
  "prefix": "",
  "suffix": "\n[The command completed with exit code 0.]"
})**
--BEGIN AGENT OBSERVATION--

[The command completed with exit code 0.]
[Current working directory: /workspace/matplotlib__matplotlib__3.7]
[Python interpreter: /opt/miniconda3/envs/testbed/bin/python]
[Command finished with exit code 0]
--END AGENT OBSERVATION--
2026-01-06 15:45:41,690 - INFO - **CmdRunAction (source=None, is_input=False)**
COMMAND:
git reset --hard
2026-01-06 15:45:43,819 - INFO - **CmdOutputObservation (source=None, exit code=0, metadata={
  "exit_code": 0,
  "pid": -1,
  "username": "root",
  "hostname": "5327492ae6c5",
  "working_dir": "/workspace/matplotlib__matplotlib__3.7",
  "py_interpreter_path": "/opt/miniconda3/envs/testbed/bin/python",
  "prefix": "",
  "suffix": "\n[The command completed with exit code 0.]"
})**
--BEGIN AGENT OBSERVATION--
Updating files: 100% (4402/4402), done.
HEAD is now at 9c559560e8 SWE-bench
[The command completed with exit code 0.]
[Current working directory: /workspace/matplotlib__matplotlib__3.7]
[Python interpreter: /opt/miniconda3/envs/testbed/bin/python]
[Command finished with exit code 0]
--END AGENT OBSERVATION--
2026-01-06 15:45:43,820 - INFO - **CmdRunAction (source=None, is_input=False)**
COMMAND:
for remote_name in $(git remote); do git remote remove "${remote_name}"; done
2026-01-06 15:45:44,438 - INFO - **CmdOutputObservation (source=None, exit code=0, metadata={
  "exit_code": 0,
  "pid": -1,
  "username": "root",
  "hostname": "5327492ae6c5",
  "working_dir": "/workspace/matplotlib__matplotlib__3.7",
  "py_interpreter_path": "/opt/miniconda3/envs/testbed/bin/python",
  "prefix": "",
  "suffix": "\n[The command completed with exit code 0.]"
})**
--BEGIN AGENT OBSERVATION--

[The command completed with exit code 0.]
[Current working directory: /workspace/matplotlib__matplotlib__3.7]
[Python interpreter: /opt/miniconda3/envs/testbed/bin/python]
[Command finished with exit code 0]
--END AGENT OBSERVATION--
2026-01-06 15:45:44,438 - INFO - **CmdRunAction (source=None, is_input=False)**
COMMAND:
which python
2026-01-06 15:45:45,055 - INFO - **CmdOutputObservation (source=None, exit code=0, metadata={
  "exit_code": 0,
  "pid": -1,
  "username": "root",
  "hostname": "5327492ae6c5",
  "working_dir": "/workspace/matplotlib__matplotlib__3.7",
  "py_interpreter_path": "/opt/miniconda3/envs/testbed/bin/python",
  "prefix": "",
  "suffix": "\n[The command completed with exit code 0.]"
})**
--BEGIN AGENT OBSERVATION--
/opt/miniconda3/envs/testbed/bin/python
[The command completed with exit code 0.]
[Current working directory: /workspace/matplotlib__matplotlib__3.7]
[Python interpreter: /opt/miniconda3/envs/testbed/bin/python]
[Command finished with exit code 0]
--END AGENT OBSERVATION--
2026-01-06 15:45:45,055 - INFO - ------------------------------
2026-01-06 15:45:45,055 - INFO - END Runtime Initialization Fn
2026-01-06 15:45:45,055 - INFO - ------------------------------
2026-01-06 15:45:45,057 - INFO - [LLM registry 92e65894-141e-48ec-ab99-e26309ee9e19]: Registering service for agent
2026-01-06 15:45:45,068 - INFO - [runtime baa38a20-ebfb-49-0ba1975c5c961c4] Selected repo: None, loading microagents from /workspace/.openhands/microagents (inside runtime)
2026-01-06 15:45:45,070 - INFO - [runtime baa38a20-ebfb-49-0ba1975c5c961c4] Attempting to list files in repository microagents directory: /workspace/.openhands/microagents
2026-01-06 15:45:45,072 - INFO - Loading user workspace microagents: []
2026-01-06 15:45:45,072 - INFO - AgentController baa38a20-ebfb-49-0ba1975c5c961c4 - created new state. start_id: 0
2026-01-06 15:45:45,079 - INFO - [Agent Controller baa38a20-ebfb-49-0ba1975c5c961c4] Setting agent(CodeActAgent) state from AgentState.LOADING to AgentState.RUNNING
2026-01-06 15:45:45,080 - INFO - Saved conversation stats
2026-01-06 16:00:27,270 - INFO - [Agent Controller baa38a20-ebfb-49-0ba1975c5c961c4] Setting agent(CodeActAgent) state from AgentState.RUNNING to AgentState.FINISHED
2026-01-06 16:00:27,273 - INFO - Saved conversation stats
2026-01-06 16:00:27,585 - INFO - ------------------------------
2026-01-06 16:00:27,585 - INFO - BEGIN Runtime Completion Fn
2026-01-06 16:00:27,586 - INFO - ------------------------------
2026-01-06 16:00:27,586 - INFO - **CmdRunAction (source=None, is_input=False)**
COMMAND:
cd /workspace/matplotlib__matplotlib__3.7
2026-01-06 16:00:28,206 - INFO - **CmdOutputObservation (source=None, exit code=0, metadata={
  "exit_code": 0,
  "pid": -1,
  "username": "root",
  "hostname": "5327492ae6c5",
  "working_dir": "/workspace/matplotlib__matplotlib__3.7",
  "py_interpreter_path": "/opt/miniconda3/envs/testbed/bin/python",
  "prefix": "",
  "suffix": "\n[The command completed with exit code 0.]"
})**
--BEGIN AGENT OBSERVATION--

[The command completed with exit code 0.]
[Current working directory: /workspace/matplotlib__matplotlib__3.7]
[Python interpreter: /opt/miniconda3/envs/testbed/bin/python]
[Command finished with exit code 0]
--END AGENT OBSERVATION--
2026-01-06 16:00:28,207 - INFO - **CmdRunAction (source=None, is_input=False)**
COMMAND:
git config --global core.pager ""
2026-01-06 16:00:28,826 - INFO - **CmdOutputObservation (source=None, exit code=0, metadata={
  "exit_code": 0,
  "pid": -1,
  "username": "root",
  "hostname": "5327492ae6c5",
  "working_dir": "/workspace/matplotlib__matplotlib__3.7",
  "py_interpreter_path": "/opt/miniconda3/envs/testbed/bin/python",
  "prefix": "",
  "suffix": "\n[The command completed with exit code 0.]"
})**
--BEGIN AGENT OBSERVATION--

[The command completed with exit code 0.]
[Current working directory: /workspace/matplotlib__matplotlib__3.7]
[Python interpreter: /opt/miniconda3/envs/testbed/bin/python]
[Command finished with exit code 0]
--END AGENT OBSERVATION--
2026-01-06 16:00:28,827 - INFO - **CmdRunAction (source=None, is_input=False)**
COMMAND:
find . -type d -name .git -not -path "./.git"
2026-01-06 16:00:29,447 - INFO - **CmdOutputObservation (source=None, exit code=0, metadata={
  "exit_code": 0,
  "pid": -1,
  "username": "root",
  "hostname": "5327492ae6c5",
  "working_dir": "/workspace/matplotlib__matplotlib__3.7",
  "py_interpreter_path": "/opt/miniconda3/envs/testbed/bin/python",
  "prefix": "",
  "suffix": "\n[The command completed with exit code 0.]"
})**
--BEGIN AGENT OBSERVATION--

[The command completed with exit code 0.]
[Current working directory: /workspace/matplotlib__matplotlib__3.7]
[Python interpreter: /opt/miniconda3/envs/testbed/bin/python]
[Command finished with exit code 0]
--END AGENT OBSERVATION--
2026-01-06 16:00:29,448 - INFO - **CmdRunAction (source=None, is_input=False)**
COMMAND:
git add -A
2026-01-06 16:00:30,068 - INFO - **CmdOutputObservation (source=None, exit code=0, metadata={
  "exit_code": 0,
  "pid": -1,
  "username": "root",
  "hostname": "5327492ae6c5",
  "working_dir": "/workspace/matplotlib__matplotlib__3.7",
  "py_interpreter_path": "/opt/miniconda3/envs/testbed/bin/python",
  "prefix": "",
  "suffix": "\n[The command completed with exit code 0.]"
})**
--BEGIN AGENT OBSERVATION--

[The command completed with exit code 0.]
[Current working directory: /workspace/matplotlib__matplotlib__3.7]
[Python interpreter: /opt/miniconda3/envs/testbed/bin/python]
[Command finished with exit code 0]
--END AGENT OBSERVATION--
2026-01-06 16:00:30,068 - INFO - **CmdRunAction (source=None, is_input=False)**
COMMAND:
for file in $(git status --porcelain | grep -E "^(M| M|\?\?|A| A)" | cut -c4-); do
        if [ -f "$file" ] && (file "$file" | grep -q "executable" || git check-attr binary "$file" | grep -q "binary: set"); then
            git rm -f "$file" 2>/dev/null || rm -f "$file"
            echo "Removed: $file"
        fi
    done
2026-01-06 16:00:30,692 - INFO - **CmdOutputObservation (source=None, exit code=0, metadata={
  "exit_code": 0,
  "pid": -1,
  "username": "root",
  "hostname": "5327492ae6c5",
  "working_dir": "/workspace/matplotlib__matplotlib__3.7",
  "py_interpreter_path": "/opt/miniconda3/envs/testbed/bin/python",
  "prefix": "",
  "suffix": "\n[The command completed with exit code 0.]"
})**
--BEGIN AGENT OBSERVATION--
bash: file: command not found
bash: file: command not found
bash: file: command not found
bash: file: command not found
bash: file: command not found
bash: file: command not found
bash: file: command not found
bash: file: command not found
bash: file: command not found
[The command completed with exit code 0.]
[Current working directory: /workspace/matplotlib__matplotlib__3.7]
[Python interpreter: /opt/miniconda3/envs/testbed/bin/python]
[Command finished with exit code 0]
--END AGENT OBSERVATION--
2026-01-06 16:00:30,693 - INFO - **CmdRunAction (source=None, is_input=False)**
COMMAND:
git diff --no-color --cached 66ba515e671638971bd11a34cff12c107a437e0b > patch.diff
2026-01-06 16:00:31,311 - INFO - **CmdOutputObservation (source=None, exit code=0, metadata={
  "exit_code": 0,
  "pid": -1,
  "username": "root",
  "hostname": "5327492ae6c5",
  "working_dir": "/workspace/matplotlib__matplotlib__3.7",
  "py_interpreter_path": "/opt/miniconda3/envs/testbed/bin/python",
  "prefix": "",
  "suffix": "\n[The command completed with exit code 0.]"
})**
--BEGIN AGENT OBSERVATION--

[The command completed with exit code 0.]
[Current working directory: /workspace/matplotlib__matplotlib__3.7]
[Python interpreter: /opt/miniconda3/envs/testbed/bin/python]
[Command finished with exit code 0]
--END AGENT OBSERVATION--
2026-01-06 16:00:31,312 - INFO - FileReadAction(path='patch.diff', start=0, end=-1, thought='', action=<ActionType.READ: 'read'>, security_risk=<ActionSecurityRisk.UNKNOWN: -1>, impl_source=<FileReadSource.DEFAULT: 'default'>, view_range=None)
2026-01-06 16:00:31,315 - INFO - [Read from /workspace/matplotlib__matplotlib__3.7/patch.diff is successful.]
diff --git a/debug_detailed.py b/debug_detailed.py
new file mode 100644
index 0000000000..9e6d2fc686
--- /dev/null
+++ b/debug_detailed.py
@@ -0,0 +1,79 @@
+#!/usr/bin/env python3
+"""
+Detailed debug script to understand the pickling issue.
+"""
+
+import matplotlib.pyplot as plt
+import pickle
+import weakref
+
+def debug_detailed():
+    """Debug the pickling issue in detail."""
+    print("Creating figure with subplots...")
+    fig = plt.figure()
+    ax1 = fig.add_subplot(211)
+    ax2 = fig.add_subplot(212)
+    time=[0,1,2,3,4]
+    speed=[40000,4300,4500,4700,4800]
+    acc=[10,11,12,13,14]
+    ax1.plot(time,speed)
+    ax1.set_ylabel('speed')
+    ax2.plot(time,acc)
+    ax2.set_ylabel('acc')
+
+    print("Calling align_labels()...")
+    fig.align_labels()
+
+    print(f"Figure class: {fig.__class__}")
+    print(f"Figure MRO: {fig.__class__.__mro__}")
+    
+    # Check if our __getstate__ method is being called
+    print("\nChecking __getstate__ method:")
+    print(f"fig.__getstate__: {fig.__getstate__}")
+    print(f"fig.__class__.__getstate__: {fig.__class__.__getstate__}")
+    
+    # Manually call __getstate__ to see if it works
+    print("\nManually calling __getstate__:")
+    try:
+        state = fig.__getstate__()
+        print("Manual __getstate__ call successful")
+        print(f"Keys in state: {list(state.keys())}")
+        
+        if '_align_label_groups' in state:
+            print("ERROR: _align_label_groups still in state after manual call!")
+        else:
+            print("GOOD: _align_label_groups removed from state after manual call")
+            
+        if '_align_label_groups_serializable' in state:
+            print("GOOD: _align_label_groups_serializable added to state after manual call")
+        else:
+            print("ERROR: _align_label_groups_serializable not in state after manual call!")
+            
+    except Exception as e:
+        print(f"Error in manual __getstate__ call: {e}")
+        import traceback
+        traceback.print_exc()
+        return
+
+    # Try to pickle the state from manual call
+    print("\nAttempting to pickle manually obtained state...")
+    try:
+        pickled_data = pickle.dumps(state)
+        print("SUCCESS: Manual state pickled successfully!")
+    except Exception as e:
+        print(f"ERROR: Failed to pickle manual state: {e}")
+        import traceback
+        traceback.print_exc()
+
+    # Try to pickle the figure directly
+    print("\nAttempting to pickle figure directly...")
+    try:
+        pickled_data = pickle.dumps(fig)
+        print("SUCCESS: Figure pickled directly!")
+    except Exception as e:
+        print(f"ERROR: Failed to pickle figure directly: {e}")
+        import traceback
+        traceback.print_exc()
+
+if __name__ == "__main__":
+    debug_detailed()
diff --git a/debug_pickle.py b/debug_pickle.py
new file mode 100644
index 0000000000..9f17bf85f6
--- /dev/null
+++ b/debug_pickle.py
@@ -0,0 +1,77 @@
+#!/usr/bin/env python3
+"""
+Debug script to understand what's causing the pickling issue.
+"""
+
+import matplotlib.pyplot as plt
+import pickle
+import weakref
+
+def debug_pickle_issue():
+    """Debug what's causing the pickling issue."""
+    print("Creating figure with subplots...")
+    fig = plt.figure()
+    ax1 = fig.add_subplot(211)
+    ax2 = fig.add_subplot(212)
+    time=[0,1,2,3,4]
+    speed=[40000,4300,4500,4700,4800]
+    acc=[10,11,12,13,14]
+    ax1.plot(time,speed)
+    ax1.set_ylabel('speed')
+    ax2.plot(time,acc)
+    ax2.set_ylabel('acc')
+
+    print("Before align_labels():")
+    print(f"_align_label_groups: {fig._align_label_groups}")
+    
+    print("Calling align_labels()...")
+    fig.align_labels()
+
+    print("After align_labels():")
+    print(f"_align_label_groups: {fig._align_label_groups}")
+    
+    # Let's examine what's in the grouper
+    for axis_type, grouper in fig._align_label_groups.items():
+        print(f"\n{axis_type} grouper:")
+        print(f"  _mapping: {grouper._mapping}")
+        for key, value in grouper._mapping.items():
+            print(f"    key: {key}, key(): {key()}, value: {value}")
+            if isinstance(key, weakref.ref):
+                print(f"    key is weakref.ref to: {key()}")
+    
+    # Try to get the state
+    print("\nGetting state...")
+    try:
+        state = fig.__getstate__()
+        print("State obtained successfully")
+        print(f"Keys in state: {list(state.keys())}")
+        
+        # Check if _align_label_groups is still in state
+        if '_align_label_groups' in state:
+            print("ERROR: _align_label_groups still in state!")
+        else:
+            print("GOOD: _align_label_groups removed from state")
+            
+        if '_align_label_groups_serializable' in state:
+            print("GOOD: _align_label_groups_serializable added to state")
+        else:
+            print("ERROR: _align_label_groups_serializable not in state!")
+            
+    except Exception as e:
+        print(f"Error getting state: {e}")
+        import traceback
+        traceback.print_exc()
+        return
+
+    # Try to pickle the state
+    print("\nAttempting to pickle state...")
+    try:
+        pickled_data = pickle.dumps(state)
+        print("SUCCESS: State pickled successfully!")
+    except Exception as e:
+        print(f"ERROR: Failed to pickle state: {e}")
+        import traceback
+        traceback.print_exc()
+
+if __name__ == "__main__":
+    debug_pickle_issue()
diff --git a/final_test.py b/final_test.py
new file mode 100644
index 0000000000..ee65aa799c
--- /dev/null
+++ b/final_test.py
@@ -0,0 +1,150 @@
+#!/usr/bin/env python3
+"""
+Final comprehensive test of the pickling fix.
+"""
+
+import sys
+# Add the current directory to the path to ensure we're using the local version
+sys.path.insert(0, '/workspace/matplotlib__matplotlib__3.7/lib')
+
+import matplotlib.pyplot as plt
+import pickle
+import traceback
+
+def test_comprehensive():
+    """Comprehensive test of the fix."""
+    tests_passed = 0
+    tests_total = 0
+    
+    # Test 1: Original issue
+    tests_total += 1
+    print("Test 1: Original issue from bug report")
+    try:
+        fig = plt.figure()
+        ax1 = fig.add_subplot(211)
+        ax2 = fig.add_subplot(212)
+        time=[0,1,2,3,4]
+        speed=[40000,4300,4500,4700,4800]
+        acc=[10,11,12,13,14]
+        ax1.plot(time,speed)
+        ax1.set_ylabel('speed')
+        ax2.plot(time,acc)
+        ax2.set_ylabel('acc')
+        fig.align_labels()
+        pickle.dumps(fig)
+        print("  ‚úÖ PASS")
+        tests_passed += 1
+    except Exception as e:
+        print(f"  ‚ùå FAIL: {e}")
+    
+    # Test 2: Without align_labels (should still work)
+    tests_total += 1
+    print("Test 2: Without align_labels")
+    try:
+        fig = plt.figure()
+        ax1 = fig.add_subplot(211)
+        ax2 = fig.add_subplot(212)
+        ax1.set_ylabel('speed')
+        ax2.set_ylabel('acc')
+        pickle.dumps(fig)
+        print("  ‚úÖ PASS")
+        tests_passed += 1
+    except Exception as e:
+        print(f"  ‚ùå FAIL: {e}")
+    
+    # Test 3: Only x-label alignment
+    tests_total += 1
+    print("Test 3: Only x-label alignment")
+    try:
+        fig = plt.figure()
+        ax1 = fig.add_subplot(121)
+        ax2 = fig.add_subplot(122)
+        ax1.set_xlabel('X Label 1')
+        ax2.set_xlabel('X Label 2')
+        fig.align_xlabels()
+        pickle.dumps(fig)
+        print("  ‚úÖ PASS")
+        tests_passed += 1
+    except Exception as e:
+        print(f"  ‚ùå FAIL: {e}")
+    
+    # Test 4: Only y-label alignment
+    tests_total += 1
+    print("Test 4: Only y-label alignment")
+    try:
+        fig = plt.figure()
+        ax1 = fig.add_subplot(121)
+        ax2 = fig.add_subplot(122)
+        ax1.set_ylabel('Y Label 1')
+        ax2.set_ylabel('Y Label 2')
+        fig.align_ylabels()
+        pickle.dumps(fig)
+        print("  ‚úÖ PASS")
+        tests_passed += 1
+    except Exception as e:
+        print(f"  ‚ùå FAIL: {e}")
+    
+    # Test 5: Complex layout with both alignments
+    tests_total += 1
+    print("Test 5: Complex layout with both alignments")
+    try:
+        fig = plt.figure(figsize=(10, 8))
+        ax1 = fig.add_subplot(221)
+        ax2 = fig.add_subplot(222)
+        ax3 = fig.add_subplot(223)
+        ax4 = fig.add_subplot(224)
+        
+        ax1.set_xlabel('Time (s)')
+        ax1.set_ylabel('Speed (m/s)')
+        ax2.set_xlabel('Time')
+        ax2.set_ylabel('Acc')
+        ax3.set_xlabel('Time (seconds)')
+        ax3.set_ylabel('Speed')
+        ax4.set_xlabel('T')
+        ax4.set_ylabel('Acceleration')
+        
+        fig.align_labels()
+        pickle.dumps(fig)
+        print("  ‚úÖ PASS")
+        tests_passed += 1
+    except Exception as e:
+        print(f"  ‚ùå FAIL: {e}")
+    
+    # Test 6: Round-trip test (pickle and unpickle)
+    tests_total += 1
+    print("Test 6: Round-trip test (pickle and unpickle)")
+    try:
+        fig = plt.figure()
+        ax1 = fig.add_subplot(211)
+        ax2 = fig.add_subplot(212)
+        ax1.set_ylabel('Speed (m/s)')
+        ax2.set_ylabel('Acc')
+        fig.align_labels()
+        
+        # Pickle and unpickle
+        pickled_data = pickle.dumps(fig)
+        unpickled_fig = pickle.loads(pickled_data)
+        
+        # Verify the unpickled figure has the alignment groups
+        assert hasattr(unpickled_fig, '_align_label_groups')
+        assert 'x' in unpickled_fig._align_label_groups
+        assert 'y' in unpickled_fig._align_label_groups
+        
+        print("  ‚úÖ PASS")
+        tests_passed += 1
+    except Exception as e:
+        print(f"  ‚ùå FAIL: {e}")
+    
+    print(f"\n{'='*50}")
+    print(f"FINAL RESULTS: {tests_passed}/{tests_total} tests passed")
+    
+    if tests_passed == tests_total:
+        print("üéâ ALL TESTS PASSED! The fix is working correctly.")
+        return True
+    else:
+        print("‚ùå Some tests failed. The fix needs more work.")
+        return False
+
+if __name__ == "__main__":
+    success = test_comprehensive()
+    exit(0 if success else 1)
diff --git a/lib/matplotlib/figure.py b/lib/matplotlib/figure.py
index b4c38368bf..feb3079177 100644
--- a/lib/matplotlib/figure.py
+++ b/lib/matplotlib/figure.py
@@ -3157,29 +3157,55 @@ None}, default: None
         a.draw(self.canvas.get_renderer())
 
     def __getstate__(self):
-        state = super().__getstate__()
+        state = self.__dict__.copy()
+        # remove the unpicklable remove method, this will get re-added on load
+        # (by the Axes) if the artist lives on an Axes.
+        state['stale_callback'] = None
 
         # The canvas cannot currently be pickled, but this has the benefit
         # of meaning that a figure can be detached from one canvas, and
         # re-attached to another.
-        state.pop("canvas")
+        state.pop("canvas", None)
 
         # discard any changes to the dpi due to pixel ratio changes
         state["_dpi"] = state.get('_original_dpi', state['_dpi'])
 
+        # Handle _align_label_groups which contain weak references that cannot be pickled
+        # Convert the grouper objects to a pickle-friendly format
+        align_label_groups = state.pop('_align_label_groups', None)
+        if align_label_groups is not None:
+            # Convert each grouper to a list of groups, where each group is a list of axes
+            align_label_groups_serializable = {}
+            for axis_type, grouper in align_label_groups.items():
+                # Clean dead weak references and get the groups
+                grouper.clean()
+                groups = []
+                for group in grouper:
+                    # Filter out None values (dead weak references) and get the actual axes
+                    valid_axes = [ax for ax in group if ax is not None]
+                    if valid_axes:  # Only include non-empty groups
+                        groups.append(valid_axes)
+                align_label_groups_serializable[axis_type] = groups
+            state['_align_label_groups_serializable'] = align_label_groups_serializable
+
         # add version information to the state
         state['__mpl_version__'] = mpl.__version__
 
         # check whether the figure manager (if any) is registered with pyplot
         from matplotlib import _pylab_helpers
-        if self.canvas.manager in _pylab_helpers.Gcf.figs.values():
+        if hasattr(self, 'canvas') and hasattr(self.canvas, 'manager') and \
+           self.canvas.manager in _pylab_helpers.Gcf.figs.values():
             state['_restore_to_pylab'] = True
+        
         return state
 
     def __setstate__(self, state):
         version = state.pop('__mpl_version__')
         restore_to_pylab = state.pop('_restore_to_pylab', False)
 
+        # Extract and handle the serialized align_label_groups
+        align_label_groups_serializable = state.pop('_align_label_groups_serializable', None)
+
         if version != mpl.__version__:
             _api.warn_external(
                 f"This figure was saved with matplotlib version {version} and "
@@ -3190,6 +3216,18 @@ None}, default: None
         # re-initialise some of the unstored state information
         FigureCanvasBase(self)  # Set self.canvas.
 
+        # Reconstruct _align_label_groups from serialized data if available
+        if align_label_groups_serializable is not None:
+            self._align_label_groups = {"x": cbook.Grouper(), "y": cbook.Grouper()}
+            for axis_type, groups in align_label_groups_serializable.items():
+                grouper = self._align_label_groups[axis_type]
+                for group in groups:
+                    # Only join axes that are still valid and in the figure
+                    valid_axes = [ax for ax in group if ax is not None and hasattr(ax, 'figure') and ax.figure is self]
+                    if len(valid_axes) > 1:
+                        # Join all valid axes in this group
+                        grouper.join(*valid_axes)
+
         if restore_to_pylab:
             # lazy import to avoid circularity
             import matplotlib.pyplot as plt
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..aa66b6c0ba
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,82 @@
+#!/usr/bin/env python3
+"""
+Script to reproduce the pickling issue with aligned labels.
+"""
+
+import sys
+# Add the current directory to the path to ensure we're using the local version
+sys.path.insert(0, '/workspace/matplotlib__matplotlib__3.7/lib')
+
+import matplotlib.pyplot as plt
+import pickle
+import traceback
+
+def test_pickle_with_align_labels():
+    """Test pickling a figure after calling align_labels()."""
+    print("Creating figure with subplots...")
+    fig = plt.figure()
+    ax1 = fig.add_subplot(211)
+    ax2 = fig.add_subplot(212)
+    time=[0,1,2,3,4]
+    speed=[40000,4300,4500,4700,4800]
+    acc=[10,11,12,13,14]
+    ax1.plot(time,speed)
+    ax1.set_ylabel('speed')
+    ax2.plot(time,acc)
+    ax2.set_ylabel('acc')
+
+    print("Calling align_labels()...")
+    fig.align_labels()  # This line causes the pickling issue
+
+    print("Attempting to pickle figure...")
+    try:
+        pickled_data = pickle.dumps(fig)
+        print("SUCCESS: Figure pickled successfully!")
+        
+        # Test unpickling
+        unpickled_fig = pickle.loads(pickled_data)
+        print("SUCCESS: Figure unpickled successfully!")
+        
+        return True
+    except Exception as e:
+        print(f"ERROR: Failed to pickle figure: {e}")
+        print("Full traceback:")
+        traceback.print_exc()
+        return False
+
+def test_pickle_without_align_labels():
+    """Test pickling a figure without calling align_labels()."""
+    print("\n" + "="*50)
+    print("Testing without align_labels() for comparison...")
+    
+    fig = plt.figure()
+    ax1 = fig.add_subplot(211)
+    ax2 = fig.add_subplot(212)
+    time=[0,1,2,3,4]
+    speed=[40000,4300,4500,4700,4800]
+    acc=[10,11,12,13,14]
+    ax1.plot(time,speed)
+    ax1.set_ylabel('speed')
+    ax2.plot(time,acc)
+    ax2.set_ylabel('acc')
+
+    # Don't call align_labels()
+    print("Attempting to pickle figure without align_labels()...")
+    try:
+        pickled_data = pickle.dumps(fig)
+        print("SUCCESS: Figure pickled successfully without align_labels()!")
+        return True
+    except Exception as e:
+        print(f"ERROR: Failed to pickle figure: {e}")
+        return False
+
+if __name__ == "__main__":
+    print("Testing matplotlib figure pickling with aligned labels...")
+    
+    success1 = test_pickle_with_align_labels()
+    success2 = test_pickle_without_align_labels()
+    
+    print("\n" + "="*50)
+    print("SUMMARY:")
+    print(f"With align_labels(): {'PASS' if success1 else 'FAIL'}")
+    print(f"Without align_labels(): {'PASS' if success2 else 'FAIL'}")
diff --git a/simple_test.py b/simple_test.py
new file mode 100644
index 0000000000..6c747fb959
--- /dev/null
+++ b/simple_test.py
@@ -0,0 +1,34 @@
+#!/usr/bin/env python3
+"""
+Simple test to check if __getstate__ is being called.
+"""
+
+import sys
+# Add the current directory to the path to ensure we're using the local version
+sys.path.insert(0, '/workspace/matplotlib__matplotlib__3.7/lib')
+
+import matplotlib.pyplot as plt
+import pickle
+
+def simple_test():
+    print("Creating figure...")
+    fig = plt.figure()
+    ax1 = fig.add_subplot(211)
+    ax2 = fig.add_subplot(212)
+    ax1.set_ylabel('speed')
+    ax2.set_ylabel('acc')
+
+    print("Calling align_labels()...")
+    fig.align_labels()
+
+    print("About to pickle...")
+    try:
+        pickled_data = pickle.dumps(fig)
+        print("SUCCESS: Figure pickled successfully!")
+        return True
+    except Exception as e:
+        print(f"ERROR: Failed to pickle figure: {e}")
+        return False
+
+if __name__ == "__main__":
+    simple_test()
diff --git a/test_alignment_preserved.py b/test_alignment_preserved.py
new file mode 100644
index 0000000000..3397e4217e
--- /dev/null
+++ b/test_alignment_preserved.py
@@ -0,0 +1,161 @@
+#!/usr/bin/env python3
+"""
+Test to verify that alignment functionality is preserved after pickling.
+"""
+
+import sys
+# Add the current directory to the path to ensure we're using the local version
+sys.path.insert(0, '/workspace/matplotlib__matplotlib__3.7/lib')
+
+import matplotlib.pyplot as plt
+import pickle
+import numpy as np
+
+def test_alignment_preserved():
+    """Test that alignment functionality works after pickling."""
+    print("Creating figure with subplots...")
+    fig = plt.figure(figsize=(8, 6))
+    ax1 = fig.add_subplot(221)  # 2x2 grid for better alignment testing
+    ax2 = fig.add_subplot(222)
+    ax3 = fig.add_subplot(223)
+    ax4 = fig.add_subplot(224)
+    
+    # Create data with different label lengths to make alignment visible
+    time = [0, 1, 2, 3, 4]
+    speed = [40000, 4300, 4500, 4700, 4800]
+    acc = [10, 11, 12, 13, 14]
+    
+    # Top row - should have x-labels aligned
+    ax1.plot(time, speed)
+    ax1.set_ylabel('Speed (m/s)')
+    ax1.set_xlabel('Time (s)')
+    ax2.plot(time, acc)
+    ax2.set_ylabel('Acc')
+    ax2.set_xlabel('Time')
+    
+    # Bottom row - should have x-labels aligned
+    ax3.plot(time, speed)
+    ax3.set_ylabel('Speed')
+    ax3.set_xlabel('Time (seconds)')
+    ax4.plot(time, acc)
+    ax4.set_ylabel('Acceleration')
+    ax4.set_xlabel('T')
+
+    print("Calling align_labels()...")
+    fig.align_labels()
+    
+    # Store original alignment groups
+    original_groups = {}
+    for axis_type, grouper in fig._align_label_groups.items():
+        grouper.clean()
+        original_groups[axis_type] = []
+        for group in grouper:
+            valid_axes = [ax for ax in group if ax is not None]
+            if valid_axes:
+                original_groups[axis_type].append(valid_axes)
+    
+    print(f"Original alignment groups: {original_groups}")
+
+    print("Pickling and unpickling figure...")
+    pickled_data = pickle.dumps(fig)
+    unpickled_fig = pickle.loads(pickled_data)
+
+    print("Checking alignment groups after unpickling...")
+    unpickled_groups = {}
+    for axis_type, grouper in unpickled_fig._align_label_groups.items():
+        grouper.clean()
+        unpickled_groups[axis_type] = []
+        for group in grouper:
+            valid_axes = [ax for ax in group if ax is not None]
+            if valid_axes:
+                unpickled_groups[axis_type].append(valid_axes)
+    
+    print(f"Unpickled alignment groups: {unpickled_groups}")
+
+    # Verify that the groups are preserved
+    success = True
+    for axis_type in ['x', 'y']:
+        if axis_type in original_groups and axis_type in unpickled_groups:
+            orig_len = len(original_groups[axis_type])
+            unpick_len = len(unpickled_groups[axis_type])
+            if orig_len != unpick_len:
+                print(f"ERROR: {axis_type} groups count mismatch: {orig_len} vs {unpick_len}")
+                success = False
+            else:
+                print(f"GOOD: {axis_type} groups count preserved: {orig_len}")
+        else:
+            print(f"WARNING: {axis_type} groups missing in one of the figures")
+    
+    if success:
+        print("SUCCESS: Alignment functionality preserved after pickling!")
+    else:
+        print("FAILURE: Alignment functionality not preserved after pickling!")
+    
+    return success
+
+def test_edge_cases():
+    """Test edge cases for the pickling fix."""
+    print("\n" + "="*50)
+    print("Testing edge cases...")
+    
+    # Test 1: Figure with no alignment
+    print("Test 1: Figure without align_labels()")
+    fig1 = plt.figure()
+    ax1 = fig1.add_subplot(111)
+    ax1.set_ylabel('Test')
+    
+    try:
+        pickled_data = pickle.dumps(fig1)
+        unpickled_fig1 = pickle.loads(pickled_data)
+        print("SUCCESS: Figure without alignment pickled successfully")
+    except Exception as e:
+        print(f"FAILURE: Figure without alignment failed: {e}")
+        return False
+    
+    # Test 2: Figure with only x-label alignment
+    print("Test 2: Figure with only x-label alignment")
+    fig2 = plt.figure()
+    ax1 = fig2.add_subplot(211)
+    ax2 = fig2.add_subplot(212)
+    ax1.set_xlabel('X Label 1')
+    ax2.set_xlabel('X Label 2')
+    fig2.align_xlabels()
+    
+    try:
+        pickled_data = pickle.dumps(fig2)
+        unpickled_fig2 = pickle.loads(pickled_data)
+        print("SUCCESS: Figure with x-label alignment pickled successfully")
+    except Exception as e:
+        print(f"FAILURE: Figure with x-label alignment failed: {e}")
+        return False
+    
+    # Test 3: Figure with only y-label alignment
+    print("Test 3: Figure with only y-label alignment")
+    fig3 = plt.figure()
+    ax1 = fig3.add_subplot(121)
+    ax2 = fig3.add_subplot(122)
+    ax1.set_ylabel('Y Label 1')
+    ax2.set_ylabel('Y Label 2')
+    fig3.align_ylabels()
+    
+    try:
+        pickled_data = pickle.dumps(fig3)
+        unpickled_fig3 = pickle.loads(pickled_data)
+        print("SUCCESS: Figure with y-label alignment pickled successfully")
+    except Exception as e:
+        print(f"FAILURE: Figure with y-label alignment failed: {e}")
+        return False
+    
+    print("SUCCESS: All edge cases passed!")
+    return True
+
+if __name__ == "__main__":
+    print("Testing alignment preservation after pickling...")
+    success1 = test_alignment_preserved()
+    success2 = test_edge_cases()
+    
+    print("\n" + "="*50)
+    print("FINAL SUMMARY:")
+    print(f"Alignment preservation test: {'PASS' if success1 else 'FAIL'}")
+    print(f"Edge cases test: {'PASS' if success2 else 'FAIL'}")
+    print(f"Overall: {'PASS' if success1 and success2 else 'FAIL'}")
diff --git a/test_import.py b/test_import.py
new file mode 100644
index 0000000000..fae4008550
--- /dev/null
+++ b/test_import.py
@@ -0,0 +1,38 @@
+#!/usr/bin/env python3
+"""
+Test to check if our modified __getstate__ method is being used.
+"""
+
+import sys
+import os
+
+# Add the current directory to the path to ensure we're using the local version
+sys.path.insert(0, '/workspace/matplotlib__matplotlib__3.7/lib')
+
+print(f"Python path: {sys.path[:3]}")
+
+import matplotlib.figure as figure_module
+print(f"matplotlib.figure module location: {figure_module.__file__}")
+
+import matplotlib.pyplot as plt
+
+# Check the __getstate__ method
+fig = plt.figure()
+print(f"Figure class: {fig.__class__}")
+print(f"Figure module: {fig.__class__.__module__}")
+print(f"__getstate__ method: {fig.__getstate__}")
+
+# Check the source code of the method
+import inspect
+try:
+    source = inspect.getsource(fig.__class__.__getstate__)
+    print("Source code of __getstate__:")
+    print(source[:200] + "..." if len(source) > 200 else source)
+except Exception as e:
+    print(f"Could not get source: {e}")
+
+# Test if it has our debug print
+if "DEBUG: Figure.__getstate__ called" in inspect.getsource(fig.__class__.__getstate__):
+    print("GOOD: Our debug print is in the method")
+else:
+    print("BAD: Our debug print is NOT in the method")
diff --git a/test_original_issue.py b/test_original_issue.py
new file mode 100644
index 0000000000..2136cdfe00
--- /dev/null
+++ b/test_original_issue.py
@@ -0,0 +1,43 @@
+#!/usr/bin/env python3
+"""
+Test the exact issue from the bug report.
+"""
+
+import sys
+# Add the current directory to the path to ensure we're using the local version
+sys.path.insert(0, '/workspace/matplotlib__matplotlib__3.7/lib')
+
+import matplotlib.pyplot as plt
+import pickle
+
+def test_original_issue():
+    """Test the exact code from the bug report."""
+    print("Testing exact code from bug report...")
+    
+    fig = plt.figure()
+    ax1 = fig.add_subplot(211)
+    ax2 = fig.add_subplot(212)
+    time=[0,1,2,3,4]
+    speed=[40000,4300,4500,4700,4800]
+    acc=[10,11,12,13,14]
+    ax1.plot(time,speed)
+    ax1.set_ylabel('speed')
+    ax2.plot(time,acc)
+    ax2.set_ylabel('acc')
+
+    fig.align_labels() ##pickling works after removing this line 
+
+    try:
+        pickle.dumps(fig)
+        print("SUCCESS: Original issue is fixed!")
+        return True
+    except Exception as e:
+        print(f"FAILURE: Original issue still exists: {e}")
+        return False
+
+if __name__ == "__main__":
+    success = test_original_issue()
+    if success:
+        print("\n‚úÖ The original bug has been successfully fixed!")
+    else:
+        print("\n‚ùå The original bug still exists!")

2026-01-06 16:00:31,317 - INFO - ------------------------------
2026-01-06 16:00:31,317 - INFO - END Runtime Completion Fn
2026-01-06 16:00:31,317 - INFO - ------------------------------
2026-01-06 16:00:31,317 - INFO - Got git diff for instance matplotlib__matplotlib-25332:
--------
diff --git a/debug_detailed.py b/debug_detailed.py
new file mode 100644
index 0000000000..9e6d2fc686
--- /dev/null
+++ b/debug_detailed.py
@@ -0,0 +1,79 @@
+#!/usr/bin/env python3
+"""
+Detailed debug script to understand the pickling issue.
+"""
+
+import matplotlib.pyplot as plt
+import pickle
+import weakref
+
+def debug_detailed():
+    """Debug the pickling issue in detail."""
+    print("Creating figure with subplots...")
+    fig = plt.figure()
+    ax1 = fig.add_subplot(211)
+    ax2 = fig.add_subplot(212)
+    time=[0,1,2,3,4]
+    speed=[40000,4300,4500,4700,4800]
+    acc=[10,11,12,13,14]
+    ax1.plot(time,speed)
+    ax1.set_ylabel('speed')
+    ax2.plot(time,acc)
+    ax2.set_ylabel('acc')
+
+    print("Calling align_labels()...")
+    fig.align_labels()
+
+    print(f"Figure class: {fig.__class__}")
+    print(f"Figure MRO: {fig.__class__.__mro__}")
+    
+    # Check if our __getstate__ method is being called
+    print("\nChecking __getstate__ method:")
+    print(f"fig.__getstate__: {fig.__getstate__}")
+    print(f"fig.__class__.__getstate__: {fig.__class__.__getstate__}")
+    
+    # Manually call __getstate__ to see if it works
+    print("\nManually calling __getstate__:")
+    try:
+        state = fig.__getstate__()
+        print("Manual __getstate__ call successful")
+        print(f"Keys in state: {list(state.keys())}")
+        
+        if '_align_label_groups' in state:
+            print("ERROR: _align_label_groups still in state after manual call!")
+        else:
+            print("GOOD: _align_label_groups removed from state after manual call")
+            
+        if '_align_label_groups_serializable' in state:
+            print("GOOD: _align_label_groups_serializable added to state after manual call")
+        else:
+            print("ERROR: _align_label_groups_serializable not in state after manual call!")
+            
+    except Exception as e:
+        print(f"Error in manual __getstate__ call: {e}")
+        import traceback
+        traceback.print_exc()
+        return
+
+    # Try to pickle the state from manual call
+    print("\nAttempting to pickle manually obtained state...")
+    try:
+        pickled_data = pickle.dumps(state)
+        print("SUCCESS: Manual state pickled successfully!")
+    except Exception as e:
+        print(f"ERROR: Failed to pickle manual state: {e}")
+        import traceback
+        traceback.print_exc()
+
+    # Try to pickle the figure directly
+    print("\nAttempting to pickle figure directly...")
+    try:
+        pickled_data = pickle.dumps(fig)
+        print("SUCCESS: Figure pickled directly!")
+    except Exception as e:
+        print(f"ERROR: Failed to pickle figure directly: {e}")
+        import traceback
+        traceback.print_exc()
+
+if __name__ == "__main__":
+    debug_detailed()
diff --git a/debug_pickle.py b/debug_pickle.py
new file mode 100644
index 0000000000..9f17bf85f6
--- /dev/null
+++ b/debug_pickle.py
@@ -0,0 +1,77 @@
+#!/usr/bin/env python3
+"""
+Debug script to understand what's causing the pickling issue.
+"""
+
+import matplotlib.pyplot as plt
+import pickle
+import weakref
+
+def debug_pickle_issue():
+    """Debug what's causing the pickling issue."""
+    print("Creating figure with subplots...")
+    fig = plt.figure()
+    ax1 = fig.add_subplot(211)
+    ax2 = fig.add_subplot(212)
+    time=[0,1,2,3,4]
+    speed=[40000,4300,4500,4700,4800]
+    acc=[10,11,12,13,14]
+    ax1.plot(time,speed)
+    ax1.set_ylabel('speed')
+    ax2.plot(time,acc)
+    ax2.set_ylabel('acc')
+
+    print("Before align_labels():")
+    print(f"_align_label_groups: {fig._align_label_groups}")
+    
+    print("Calling align_labels()...")
+    fig.align_labels()
+
+    print("After align_labels():")
+    print(f"_align_label_groups: {fig._align_label_groups}")
+    
+    # Let's examine what's in the grouper
+    for axis_type, grouper in fig._align_label_groups.items():
+        print(f"\n{axis_type} grouper:")
+        print(f"  _mapping: {grouper._mapping}")
+        for key, value in grouper._mapping.items():
+            print(f"    key: {key}, key(): {key()}, value: {value}")
+            if isinstance(key, weakref.ref):
+                print(f"    key is weakref.ref to: {key()}")
+    
+    # Try to get the state
+    print("\nGetting state...")
+    try:
+        state = fig.__getstate__()
+        print("State obtained successfully")
+        print(f"Keys in state: {list(state.keys())}")
+        
+        # Check if _align_label_groups is still in state
+        if '_align_label_groups' in state:
+            print("ERROR: _align_label_groups still in state!")
+        else:
+            print("GOOD: _align_label_groups removed from state")
+            
+        if '_align_label_groups_serializable' in state:
+            print("GOOD: _align_label_groups_serializable added to state")
+        else:
+            print("ERROR: _align_label_groups_serializable not in state!")
+            
+    except Exception as e:
+        print(f"Error getting state: {e}")
+        import traceback
+        traceback.print_exc()
+        return
+
+    # Try to pickle the state
+    print("\nAttempting to pickle state...")
+    try:
+        pickled_data = pickle.dumps(state)
+        print("SUCCESS: State pickled successfully!")
+    except Exception as e:
+        print(f"ERROR: Failed to pickle state: {e}")
+        import traceback
+        traceback.print_exc()
+
+if __name__ == "__main__":
+    debug_pickle_issue()
diff --git a/final_test.py b/final_test.py
new file mode 100644
index 0000000000..ee65aa799c
--- /dev/null
+++ b/final_test.py
@@ -0,0 +1,150 @@
+#!/usr/bin/env python3
+"""
+Final comprehensive test of the pickling fix.
+"""
+
+import sys
+# Add the current directory to the path to ensure we're using the local version
+sys.path.insert(0, '/workspace/matplotlib__matplotlib__3.7/lib')
+
+import matplotlib.pyplot as plt
+import pickle
+import traceback
+
+def test_comprehensive():
+    """Comprehensive test of the fix."""
+    tests_passed = 0
+    tests_total = 0
+    
+    # Test 1: Original issue
+    tests_total += 1
+    print("Test 1: Original issue from bug report")
+    try:
+        fig = plt.figure()
+        ax1 = fig.add_subplot(211)
+        ax2 = fig.add_subplot(212)
+        time=[0,1,2,3,4]
+        speed=[40000,4300,4500,4700,4800]
+        acc=[10,11,12,13,14]
+        ax1.plot(time,speed)
+        ax1.set_ylabel('speed')
+        ax2.plot(time,acc)
+        ax2.set_ylabel('acc')
+        fig.align_labels()
+        pickle.dumps(fig)
+        print("  ‚úÖ PASS")
+        tests_passed += 1
+    except Exception as e:
+        print(f"  ‚ùå FAIL: {e}")
+    
+    # Test 2: Without align_labels (should still work)
+    tests_total += 1
+    print("Test 2: Without align_labels")
+    try:
+        fig = plt.figure()
+        ax1 = fig.add_subplot(211)
+        ax2 = fig.add_subplot(212)
+        ax1.set_ylabel('speed')
+        ax2.set_ylabel('acc')
+        pickle.dumps(fig)
+        print("  ‚úÖ PASS")
+        tests_passed += 1
+    except Exception as e:
+        print(f"  ‚ùå FAIL: {e}")
+    
+    # Test 3: Only x-label alignment
+    tests_total += 1
+    print("Test 3: Only x-label alignment")
+    try:
+        fig = plt.figure()
+        ax1 = fig.add_subplot(121)
+        ax2 = fig.add_subplot(122)
+        ax1.set_xlabel('X Label 1')
+        ax2.set_xlabel('X Label 2')
+        fig.align_xlabels()
+        pickle.dumps(fig)
+        print("  ‚úÖ PASS")
+        tests_passed += 1
+    except Exception as e:
+        print(f"  ‚ùå FAIL: {e}")
+    
+    # Test 4: Only y-label alignment
+    tests_total += 1
+    print("Test 4: Only y-label alignment")
+    try:
+        fig = plt.figure()
+        ax1 = fig.add_subplot(121)
+        ax2 = fig.add_subplot(122)
+        ax1.set_ylabel('Y Label 1')
+        ax2.set_ylabel('Y Label 2')
+        fig.align_ylabels()
+        pickle.dumps(fig)
+        print("  ‚úÖ PASS")
+        tests_passed += 1
+    except Exception as e:
+        print(f"  ‚ùå FAIL: {e}")
+    
+    # Test 5: Complex layout with both alignments
+    tests_total += 1
+    print("Test 5: Complex layout with both alignments")
+    try:
+        fig = plt.figure(figsize=(10, 8))
+        ax1 = fig.add_subplot(221)
+        ax2 = fig.add_subplot(222)
+        ax3 = fig.add_subplot(223)
+        ax4 = fig.add_subplot(224)
+        
+        ax1.set_xlabel('Time (s)')
+        ax1.set_ylabel('Speed (m/s)')
+        ax2.set_xlabel('Time')
+        ax2.set_ylabel('Acc')
+        ax3.set_xlabel('Time (seconds)')
+        ax3.set_ylabel('Speed')
+        ax4.set_xlabel('T')
+        ax4.set_ylabel('Acceleration')
+        
+        fig.align_labels()
+        pickle.dumps(fig)
+        print("  ‚úÖ PASS")
+        tests_passed += 1
+    except Exception as e:
+        print(f"  ‚ùå FAIL: {e}")
+    
+    # Test 6: Round-trip test (pickle and unpickle)
+    tests_total += 1
+    print("Test 6: Round-trip test (pickle and unpickle)")
+    try:
+        fig = plt.figure()
+        ax1 = fig.add_subplot(211)
+        ax2 = fig.add_subplot(212)
+        ax1.set_ylabel('Speed (m/s)')
+        ax2.set_ylabel('Acc')
+        fig.align_labels()
+        
+        # Pickle and unpickle
+        pickled_data = pickle.dumps(fig)
+        unpickled_fig = pickle.loads(pickled_data)
+        
+        # Verify the unpickled figure has the alignment groups
+        assert hasattr(unpickled_fig, '_align_label_groups')
+        assert 'x' in unpickled_fig._align_label_groups
+        assert 'y' in unpickled_fig._align_label_groups
+        
+        print("  ‚úÖ PASS")
+        tests_passed += 1
+    except Exception as e:
+        print(f"  ‚ùå FAIL: {e}")
+    
+    print(f"\n{'='*50}")
+    print(f"FINAL RESULTS: {tests_passed}/{tests_total} tests passed")
+    
+    if tests_passed == tests_total:
+        print("üéâ ALL TESTS PASSED! The fix is working correctly.")
+        return True
+    else:
+        print("‚ùå Some tests failed. The fix needs more work.")
+        return False
+
+if __name__ == "__main__":
+    success = test_comprehensive()
+    exit(0 if success else 1)
diff --git a/lib/matplotlib/figure.py b/lib/matplotlib/figure.py
index b4c38368bf..feb3079177 100644
--- a/lib/matplotlib/figure.py
+++ b/lib/matplotlib/figure.py
@@ -3157,29 +3157,55 @@ None}, default: None
         a.draw(self.canvas.get_renderer())
 
     def __getstate__(self):
-        state = super().__getstate__()
+        state = self.__dict__.copy()
+        # remove the unpicklable remove method, this will get re-added on load
+        # (by the Axes) if the artist lives on an Axes.
+        state['stale_callback'] = None
 
         # The canvas cannot currently be pickled, but this has the benefit
         # of meaning that a figure can be detached from one canvas, and
         # re-attached to another.
-        state.pop("canvas")
+        state.pop("canvas", None)
 
         # discard any changes to the dpi due to pixel ratio changes
         state["_dpi"] = state.get('_original_dpi', state['_dpi'])
 
+        # Handle _align_label_groups which contain weak references that cannot be pickled
+        # Convert the grouper objects to a pickle-friendly format
+        align_label_groups = state.pop('_align_label_groups', None)
+        if align_label_groups is not None:
+            # Convert each grouper to a list of groups, where each group is a list of axes
+            align_label_groups_serializable = {}
+            for axis_type, grouper in align_label_groups.items():
+                # Clean dead weak references and get the groups
+                grouper.clean()
+                groups = []
+                for group in grouper:
+                    # Filter out None values (dead weak references) and get the actual axes
+                    valid_axes = [ax for ax in group if ax is not None]
+                    if valid_axes:  # Only include non-empty groups
+                        groups.append(valid_axes)
+                align_label_groups_serializable[axis_type] = groups
+            state['_align_label_groups_serializable'] = align_label_groups_serializable
+
         # add version information to the state
         state['__mpl_version__'] = mpl.__version__
 
         # check whether the figure manager (if any) is registered with pyplot
         from matplotlib import _pylab_helpers
-        if self.canvas.manager in _pylab_helpers.Gcf.figs.values():
+        if hasattr(self, 'canvas') and hasattr(self.canvas, 'manager') and \
+           self.canvas.manager in _pylab_helpers.Gcf.figs.values():
             state['_restore_to_pylab'] = True
+        
         return state
 
     def __setstate__(self, state):
         version = state.pop('__mpl_version__')
         restore_to_pylab = state.pop('_restore_to_pylab', False)
 
+        # Extract and handle the serialized align_label_groups
+        align_label_groups_serializable = state.pop('_align_label_groups_serializable', None)
+
         if version != mpl.__version__:
             _api.warn_external(
                 f"This figure was saved with matplotlib version {version} and "
@@ -3190,6 +3216,18 @@ None}, default: None
         # re-initialise some of the unstored state information
         FigureCanvasBase(self)  # Set self.canvas.
 
+        # Reconstruct _align_label_groups from serialized data if available
+        if align_label_groups_serializable is not None:
+            self._align_label_groups = {"x": cbook.Grouper(), "y": cbook.Grouper()}
+            for axis_type, groups in align_label_groups_serializable.items():
+                grouper = self._align_label_groups[axis_type]
+                for group in groups:
+                    # Only join axes that are still valid and in the figure
+                    valid_axes = [ax for ax in group if ax is not None and hasattr(ax, 'figure') and ax.figure is self]
+                    if len(valid_axes) > 1:
+                        # Join all valid axes in this group
+                        grouper.join(*valid_axes)
+
         if restore_to_pylab:
             # lazy import to avoid circularity
             import matplotlib.pyplot as plt
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..aa66b6c0ba
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,82 @@
+#!/usr/bin/env python3
+"""
+Script to reproduce the pickling issue with aligned labels.
+"""
+
+import sys
+# Add the current directory to the path to ensure we're using the local version
+sys.path.insert(0, '/workspace/matplotlib__matplotlib__3.7/lib')
+
+import matplotlib.pyplot as plt
+import pickle
+import traceback
+
+def test_pickle_with_align_labels():
+    """Test pickling a figure after calling align_labels()."""
+    print("Creating figure with subplots...")
+    fig = plt.figure()
+    ax1 = fig.add_subplot(211)
+    ax2 = fig.add_subplot(212)
+    time=[0,1,2,3,4]
+    speed=[40000,4300,4500,4700,4800]
+    acc=[10,11,12,13,14]
+    ax1.plot(time,speed)
+    ax1.set_ylabel('speed')
+    ax2.plot(time,acc)
+    ax2.set_ylabel('acc')
+
+    print("Calling align_labels()...")
+    fig.align_labels()  # This line causes the pickling issue
+
+    print("Attempting to pickle figure...")
+    try:
+        pickled_data = pickle.dumps(fig)
+        print("SUCCESS: Figure pickled successfully!")
+        
+        # Test unpickling
+        unpickled_fig = pickle.loads(pickled_data)
+        print("SUCCESS: Figure unpickled successfully!")
+        
+        return True
+    except Exception as e:
+        print(f"ERROR: Failed to pickle figure: {e}")
+        print("Full traceback:")
+        traceback.print_exc()
+        return False
+
+def test_pickle_without_align_labels():
+    """Test pickling a figure without calling align_labels()."""
+    print("\n" + "="*50)
+    print("Testing without align_labels() for comparison...")
+    
+    fig = plt.figure()
+    ax1 = fig.add_subplot(211)
+    ax2 = fig.add_subplot(212)
+    time=[0,1,2,3,4]
+    speed=[40000,4300,4500,4700,4800]
+    acc=[10,11,12,13,14]
+    ax1.plot(time,speed)
+    ax1.set_ylabel('speed')
+    ax2.plot(time,acc)
+    ax2.set_ylabel('acc')
+
+    # Don't call align_labels()
+    print("Attempting to pickle figure without align_labels()...")
+    try:
+        pickled_data = pickle.dumps(fig)
+        print("SUCCESS: Figure pickled successfully without align_labels()!")
+        return True
+    except Exception as e:
+        print(f"ERROR: Failed to pickle figure: {e}")
+        return False
+
+if __name__ == "__main__":
+    print("Testing matplotlib figure pickling with aligned labels...")
+    
+    success1 = test_pickle_with_align_labels()
+    success2 = test_pickle_without_align_labels()
+    
+    print("\n" + "="*50)
+    print("SUMMARY:")
+    print(f"With align_labels(): {'PASS' if success1 else 'FAIL'}")
+    print(f"Without align_labels(): {'PASS' if success2 else 'FAIL'}")
diff --git a/simple_test.py b/simple_test.py
new file mode 100644
index 0000000000..6c747fb959
--- /dev/null
+++ b/simple_test.py
@@ -0,0 +1,34 @@
+#!/usr/bin/env python3
+"""
+Simple test to check if __getstate__ is being called.
+"""
+
+import sys
+# Add the current directory to the path to ensure we're using the local version
+sys.path.insert(0, '/workspace/matplotlib__matplotlib__3.7/lib')
+
+import matplotlib.pyplot as plt
+import pickle
+
+def simple_test():
+    print("Creating figure...")
+    fig = plt.figure()
+    ax1 = fig.add_subplot(211)
+    ax2 = fig.add_subplot(212)
+    ax1.set_ylabel('speed')
+    ax2.set_ylabel('acc')
+
+    print("Calling align_labels()...")
+    fig.align_labels()
+
+    print("About to pickle...")
+    try:
+        pickled_data = pickle.dumps(fig)
+        print("SUCCESS: Figure pickled successfully!")
+        return True
+    except Exception as e:
+        print(f"ERROR: Failed to pickle figure: {e}")
+        return False
+
+if __name__ == "__main__":
+    simple_test()
diff --git a/test_alignment_preserved.py b/test_alignment_preserved.py
new file mode 100644
index 0000000000..3397e4217e
--- /dev/null
+++ b/test_alignment_preserved.py
@@ -0,0 +1,161 @@
+#!/usr/bin/env python3
+"""
+Test to verify that alignment functionality is preserved after pickling.
+"""
+
+import sys
+# Add the current directory to the path to ensure we're using the local version
+sys.path.insert(0, '/workspace/matplotlib__matplotlib__3.7/lib')
+
+import matplotlib.pyplot as plt
+import pickle
+import numpy as np
+
+def test_alignment_preserved():
+    """Test that alignment functionality works after pickling."""
+    print("Creating figure with subplots...")
+    fig = plt.figure(figsize=(8, 6))
+    ax1 = fig.add_subplot(221)  # 2x2 grid for better alignment testing
+    ax2 = fig.add_subplot(222)
+    ax3 = fig.add_subplot(223)
+    ax4 = fig.add_subplot(224)
+    
+    # Create data with different label lengths to make alignment visible
+    time = [0, 1, 2, 3, 4]
+    speed = [40000, 4300, 4500, 4700, 4800]
+    acc = [10, 11, 12, 13, 14]
+    
+    # Top row - should have x-labels aligned
+    ax1.plot(time, speed)
+    ax1.set_ylabel('Speed (m/s)')
+    ax1.set_xlabel('Time (s)')
+    ax2.plot(time, acc)
+    ax2.set_ylabel('Acc')
+    ax2.set_xlabel('Time')
+    
+    # Bottom row - should have x-labels aligned
+    ax3.plot(time, speed)
+    ax3.set_ylabel('Speed')
+    ax3.set_xlabel('Time (seconds)')
+    ax4.plot(time, acc)
+    ax4.set_ylabel('Acceleration')
+    ax4.set_xlabel('T')
+
+    print("Calling align_labels()...")
+    fig.align_labels()
+    
+    # Store original alignment groups
+    original_groups = {}
+    for axis_type, grouper in fig._align_label_groups.items():
+        grouper.clean()
+        original_groups[axis_type] = []
+        for group in grouper:
+            valid_axes = [ax for ax in group if ax is not None]
+            if valid_axes:
+                original_groups[axis_type].append(valid_axes)
+    
+    print(f"Original alignment groups: {original_groups}")
+
+    print("Pickling and unpickling figure...")
+    pickled_data = pickle.dumps(fig)
+    unpickled_fig = pickle.loads(pickled_data)
+
+    print("Checking alignment groups after unpickling...")
+    unpickled_groups = {}
+    for axis_type, grouper in unpickled_fig._align_label_groups.items():
+        grouper.clean()
+        unpickled_groups[axis_type] = []
+        for group in grouper:
+            valid_axes = [ax for ax in group if ax is not None]
+            if valid_axes:
+                unpickled_groups[axis_type].append(valid_axes)
+    
+    print(f"Unpickled alignment groups: {unpickled_groups}")
+
+    # Verify that the groups are preserved
+    success = True
+    for axis_type in ['x', 'y']:
+        if axis_type in original_groups and axis_type in unpickled_groups:
+            orig_len = len(original_groups[axis_type])
+            unpick_len = len(unpickled_groups[axis_type])
+            if orig_len != unpick_len:
+                print(f"ERROR: {axis_type} groups count mismatch: {orig_len} vs {unpick_len}")
+                success = False
+            else:
+                print(f"GOOD: {axis_type} groups count preserved: {orig_len}")
+        else:
+            print(f"WARNING: {axis_type} groups missing in one of the figures")
+    
+    if success:
+        print("SUCCESS: Alignment functionality preserved after pickling!")
+    else:
+        print("FAILURE: Alignment functionality not preserved after pickling!")
+    
+    return success
+
+def test_edge_cases():
+    """Test edge cases for the pickling fix."""
+    print("\n" + "="*50)
+    print("Testing edge cases...")
+    
+    # Test 1: Figure with no alignment
+    print("Test 1: Figure without align_labels()")
+    fig1 = plt.figure()
+    ax1 = fig1.add_subplot(111)
+    ax1.set_ylabel('Test')
+    
+    try:
+        pickled_data = pickle.dumps(fig1)
+        unpickled_fig1 = pickle.loads(pickled_data)
+        print("SUCCESS: Figure without alignment pickled successfully")
+    except Exception as e:
+        print(f"FAILURE: Figure without alignment failed: {e}")
+        return False
+    
+    # Test 2: Figure with only x-label alignment
+    print("Test 2: Figure with only x-label alignment")
+    fig2 = plt.figure()
+    ax1 = fig2.add_subplot(211)
+    ax2 = fig2.add_subplot(212)
+    ax1.set_xlabel('X Label 1')
+    ax2.set_xlabel('X Label 2')
+    fig2.align_xlabels()
+    
+    try:
+        pickled_data = pickle.dumps(fig2)
+        unpickled_fig2 = pickle.loads(pickled_data)
+        print("SUCCESS: Figure with x-label alignment pickled successfully")
+    except Exception as e:
+        print(f"FAILURE: Figure with x-label alignment failed: {e}")
+        return False
+    
+    # Test 3: Figure with only y-label alignment
+    print("Test 3: Figure with only y-label alignment")
+    fig3 = plt.figure()
+    ax1 = fig3.add_subplot(121)
+    ax2 = fig3.add_subplot(122)
+    ax1.set_ylabel('Y Label 1')
+    ax2.set_ylabel('Y Label 2')
+    fig3.align_ylabels()
+    
+    try:
+        pickled_data = pickle.dumps(fig3)
+        unpickled_fig3 = pickle.loads(pickled_data)
+        print("SUCCESS: Figure with y-label alignment pickled successfully")
+    except Exception as e:
+        print(f"FAILURE: Figure with y-label alignment failed: {e}")
+        return False
+    
+    print("SUCCESS: All edge cases passed!")
+    return True
+
+if __name__ == "__main__":
+    print("Testing alignment preservation after pickling...")
+    success1 = test_alignment_preserved()
+    success2 = test_edge_cases()
+    
+    print("\n" + "="*50)
+    print("FINAL SUMMARY:")
+    print(f"Alignment preservation test: {'PASS' if success1 else 'FAIL'}")
+    print(f"Edge cases test: {'PASS' if success2 else 'FAIL'}")
+    print(f"Overall: {'PASS' if success1 and success2 else 'FAIL'}")
diff --git a/test_import.py b/test_import.py
new file mode 100644
index 0000000000..fae4008550
--- /dev/null
+++ b/test_import.py
@@ -0,0 +1,38 @@
+#!/usr/bin/env python3
+"""
+Test to check if our modified __getstate__ method is being used.
+"""
+
+import sys
+import os
+
+# Add the current directory to the path to ensure we're using the local version
+sys.path.insert(0, '/workspace/matplotlib__matplotlib__3.7/lib')
+
+print(f"Python path: {sys.path[:3]}")
+
+import matplotlib.figure as figure_module
+print(f"matplotlib.figure module location: {figure_module.__file__}")
+
+import matplotlib.pyplot as plt
+
+# Check the __getstate__ method
+fig = plt.figure()
+print(f"Figure class: {fig.__class__}")
+print(f"Figure module: {fig.__class__.__module__}")
+print(f"__getstate__ method: {fig.__getstate__}")
+
+# Check the source code of the method
+import inspect
+try:
+    source = inspect.getsource(fig.__class__.__getstate__)
+    print("Source code of __getstate__:")
+    print(source[:200] + "..." if len(source) > 200 else source)
+except Exception as e:
+    print(f"Could not get source: {e}")
+
+# Test if it has our debug print
+if "DEBUG: Figure.__getstate__ called" in inspect.getsource(fig.__class__.__getstate__):
+    print("GOOD: Our debug print is in the method")
+else:
+    print("BAD: Our debug print is NOT in the method")
diff --git a/test_original_issue.py b/test_original_issue.py
new file mode 100644
index 0000000000..2136cdfe00
--- /dev/null
+++ b/test_original_issue.py
@@ -0,0 +1,43 @@
+#!/usr/bin/env python3
+"""
+Test the exact issue from the bug report.
+"""
+
+import sys
+# Add the current directory to the path to ensure we're using the local version
+sys.path.insert(0, '/workspace/matplotlib__matplotlib__3.7/lib')
+
+import matplotlib.pyplot as plt
+import pickle
+
+def test_original_issue():
+    """Test the exact code from the bug report."""
+    print("Testing exact code from bug report...")
+    
+    fig = plt.figure()
+    ax1 = fig.add_subplot(211)
+    ax2 = fig.add_subplot(212)
+    time=[0,1,2,3,4]
+    speed=[40000,4300,4500,4700,4800]
+    acc=[10,11,12,13,14]
+    ax1.plot(time,speed)
+    ax1.set_ylabel('speed')
+    ax2.plot(time,acc)
+    ax2.set_ylabel('acc')
+
+    fig.align_labels() ##pickling works after removing this line 
+
+    try:
+        pickle.dumps(fig)
+        print("SUCCESS: Original issue is fixed!")
+        return True
+    except Exception as e:
+        print(f"FAILURE: Original issue still exists: {e}")
+        return False
+
+if __name__ == "__main__":
+    success = test_original_issue()
+    if success:
+        print("\n‚úÖ The original bug has been successfully fixed!")
+    else:
+        print("\n‚ùå The original bug still exists!")
--------
2026-01-06 16:00:33,462 - INFO - Using instance container image: docker.io/swebench/sweb.eval.x86_64.pytest-dev_1776_pytest-7220:latest. Please make sure this image exists. Submit an issue on https://github.com/OpenHands/OpenHands if you run into any issues.
2026-01-06 16:00:33,462 - INFO - Resource mapping for princeton-nlp__SWE-bench_Lite-test not found.
2026-01-06 16:00:33,463 - INFO - Logging LLM completions for instance pytest-dev__pytest-7220 to ./continuum32/princeton-nlp__SWE-bench_Lite-test/CodeActAgent/GLM-4.6-FP8_maxiter_135/llm_completions/pytest-dev__pytest-7220
2026-01-06 16:00:33,463 - INFO - Config file not found: config.toml. Error: [Errno 2] No such file or directory: 'config.toml'
2026-01-06 16:00:33,463 - INFO - Config file not found: [Errno 2] No such file or directory: 'config.toml'. Toml values have not been applied.
