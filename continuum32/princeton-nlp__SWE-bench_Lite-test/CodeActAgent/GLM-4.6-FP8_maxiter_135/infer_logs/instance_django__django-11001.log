2026-01-06 14:16:48,318 - INFO - [LLM registry 698f7a1f-513f-40e6-a80b-b8b5dc258441]: Registering service for agent
2026-01-06 14:16:48,417 - INFO - Building image: ghcr.io/openhands/runtime:oh_v1.0.0_kpela9vzg238hxtp_v008aov5t6vw3gr5
2026-01-06 14:32:37,863 - INFO - Image [ghcr.io/openhands/runtime:oh_v1.0.0_kpela9vzg238hxtp_v008aov5t6vw3gr5] build finished.
2026-01-06 14:32:37,882 - INFO - Re-tagged image [ghcr.io/openhands/runtime:oh_v1.0.0_kpela9vzg238hxtp_v008aov5t6vw3gr5] with more generic tag [oh_v1.0.0_kpela9vzg238hxtp]
2026-01-06 14:32:37,886 - INFO - Image ghcr.io/openhands/runtime with tags [oh_v1.0.0_kpela9vzg238hxtp_v008aov5t6vw3gr5, oh_v1.0.0_kpela9vzg238hxtp] built successfully
2026-01-06 14:32:37,952 - INFO - [runtime e39b4a00-8f1c-4d-dc85c1202b94618] Starting runtime with image: ghcr.io/openhands/runtime:oh_v1.0.0_kpela9vzg238hxtp_v008aov5t6vw3gr5
2026-01-06 14:32:38,059 - INFO - [runtime e39b4a00-8f1c-4d-dc85c1202b94618] Starting server with command: ['/openhands/micromamba/bin/micromamba', 'run', '-n', 'openhands', 'poetry', 'run', 'python', '-u', '-m', 'openhands.runtime.action_execution_server', '32389', '--working-dir', '/workspace', '--plugins', 'agent_skills', 'jupyter', '--username', 'root', '--user-id', '0', '--no-enable-browser']
2026-01-06 14:32:38,702 - INFO - [runtime e39b4a00-8f1c-4d-dc85c1202b94618] Container started: openhands-runtime-e39b4a00-8f1c-4d-dc85c1202b94618. VSCode URL: None
2026-01-06 14:32:38,703 - INFO - [runtime e39b4a00-8f1c-4d-dc85c1202b94618] Waiting for client to become ready at http://localhost:32389...
2026-01-06 14:33:08,802 - INFO - [runtime e39b4a00-8f1c-4d-dc85c1202b94618] Runtime is ready.
2026-01-06 14:33:11,923 - INFO - Successfully configured git: name=openhands, email=openhands@all-hands.dev
2026-01-06 14:33:11,925 - INFO - ------------------------------
2026-01-06 14:33:11,925 - INFO - BEGIN Runtime Initialization Fn
2026-01-06 14:33:11,925 - INFO - ------------------------------
2026-01-06 14:33:11,926 - INFO - **CmdRunAction (source=None, is_input=False)**
COMMAND:
echo 'export SWE_INSTANCE_ID=django__django-11001' >> ~/.bashrc && echo 'export PIP_CACHE_DIR=~/.cache/pip' >> ~/.bashrc && echo "alias git='git --no-pager'" >> ~/.bashrc && git config --global core.pager "" && git config --global diff.binary false
2026-01-06 14:33:12,555 - INFO - **CmdOutputObservation (source=None, exit code=0, metadata={
  "exit_code": 0,
  "pid": -1,
  "username": "root",
  "hostname": "2e3c3856de7f",
  "working_dir": "/workspace",
  "py_interpreter_path": "/openhands/micromamba/envs/openhands/bin/python",
  "prefix": "",
  "suffix": "\n[The command completed with exit code 0.]"
})**
--BEGIN AGENT OBSERVATION--

[The command completed with exit code 0.]
[Current working directory: /workspace]
[Python interpreter: /openhands/micromamba/envs/openhands/bin/python]
[Command finished with exit code 0]
--END AGENT OBSERVATION--
2026-01-06 14:33:12,555 - INFO - **CmdRunAction (source=None, is_input=False)**
COMMAND:
export USER=$(whoami); echo USER=${USER} 
2026-01-06 14:33:13,200 - INFO - **CmdOutputObservation (source=None, exit code=0, metadata={
  "exit_code": 0,
  "pid": -1,
  "username": "root",
  "hostname": "2e3c3856de7f",
  "working_dir": "/workspace",
  "py_interpreter_path": "/openhands/micromamba/envs/openhands/bin/python",
  "prefix": "",
  "suffix": "\n[The command completed with exit code 0.]"
})**
--BEGIN AGENT OBSERVATION--
USER=root
[The command completed with exit code 0.]
[Current working directory: /workspace]
[Python interpreter: /openhands/micromamba/envs/openhands/bin/python]
[Command finished with exit code 0]
--END AGENT OBSERVATION--
2026-01-06 14:33:13,201 - INFO - **CmdRunAction (source=None, is_input=False)**
COMMAND:
mkdir -p /swe_util/eval_data/instances
2026-01-06 14:33:13,822 - INFO - **CmdOutputObservation (source=None, exit code=0, metadata={
  "exit_code": 0,
  "pid": -1,
  "username": "root",
  "hostname": "2e3c3856de7f",
  "working_dir": "/workspace",
  "py_interpreter_path": "/openhands/micromamba/envs/openhands/bin/python",
  "prefix": "",
  "suffix": "\n[The command completed with exit code 0.]"
})**
--BEGIN AGENT OBSERVATION--

[The command completed with exit code 0.]
[Current working directory: /workspace]
[Python interpreter: /openhands/micromamba/envs/openhands/bin/python]
[Command finished with exit code 0]
--END AGENT OBSERVATION--
2026-01-06 14:33:13,844 - INFO - **CmdRunAction (source=None, is_input=False)**
COMMAND:
cat ~/.bashrc
2026-01-06 14:33:14,472 - INFO - **CmdOutputObservation (source=None, exit code=0, metadata={
  "exit_code": 0,
  "pid": -1,
  "username": "root",
  "hostname": "2e3c3856de7f",
  "working_dir": "/workspace",
  "py_interpreter_path": "/openhands/micromamba/envs/openhands/bin/python",
  "prefix": "",
  "suffix": "\n[The command completed with exit code 0.]"
})**
--BEGIN AGENT OBSERVATION--
source /opt/miniconda3/etc/profile.d/conda.sh && conda activate testbed

. "/openhands/bin/env"
export PATH="/usr/bin:/bin:/usr/sbin:/sbin:/openhands/micromamba/bin:$PATH"
export PLAYWRIGHT_BROWSERS_PATH=/opt/playwright-browsers
eval "$(/openhands/micromamba/bin/micromamba shell hook --shell bash)"
micromamba activate openhands 2>/dev/null || true
export ENABLE_AUTO_LINT=true
export NO_CHANGE_TIMEOUT_SECONDS=30
export OPENHANDS_EVAL_INSTANCE_ID=django__django-11001
export OPENHANDS_EVAL_JOB_ID=2667203669
export OPENHANDS_TIMING_DIR=./continuum32/princeton-nlp__SWE-bench_Lite-test/CodeActAgent/GLM-4.6-FP8_maxiter_135/timing
export SWE_INSTANCE_ID=django__django-11001
export PIP_CACHE_DIR=~/.cache/pip
alias git='git --no-pager'
[The command completed with exit code 0.]
[Current working directory: /workspace]
[Python interpreter: /openhands/micromamba/envs/openhands/bin/python]
[Command finished with exit code 0]
--END AGENT OBSERVATION--
2026-01-06 14:33:14,473 - INFO - **CmdRunAction (source=None, is_input=False)**
COMMAND:
source ~/.bashrc
2026-01-06 14:33:15,102 - INFO - **CmdOutputObservation (source=None, exit code=0, metadata={
  "exit_code": 0,
  "pid": -1,
  "username": "root",
  "hostname": "2e3c3856de7f",
  "working_dir": "/workspace",
  "py_interpreter_path": "/openhands/micromamba/envs/openhands/bin/python",
  "prefix": "",
  "suffix": "\n[The command completed with exit code 0.]"
})**
--BEGIN AGENT OBSERVATION--

[The command completed with exit code 0.]
[Current working directory: /workspace]
[Python interpreter: /openhands/micromamba/envs/openhands/bin/python]
[Command finished with exit code 0]
--END AGENT OBSERVATION--
2026-01-06 14:33:15,102 - INFO - **CmdRunAction (source=None, is_input=False)**
COMMAND:
source /swe_util/instance_swe_entry.sh
2026-01-06 14:33:18,245 - INFO - **CmdOutputObservation (source=None, exit code=0, metadata={
  "exit_code": 0,
  "pid": -1,
  "username": "root",
  "hostname": "2e3c3856de7f",
  "working_dir": "/workspace",
  "py_interpreter_path": "/opt/miniconda3/envs/testbed/bin/python",
  "prefix": "",
  "suffix": "\n[The command completed with exit code 0.]"
})**
--BEGIN AGENT OBSERVATION--
WORKSPACE_NAME: django__django__3.0
[The command completed with exit code 0.]
[Current working directory: /workspace]
[Python interpreter: /opt/miniconda3/envs/testbed/bin/python]
[Command finished with exit code 0]
--END AGENT OBSERVATION--
2026-01-06 14:33:18,255 - INFO - **CmdRunAction (source=None, is_input=False)**
COMMAND:
cd /workspace/django__django__3.0
2026-01-06 14:33:18,880 - INFO - **CmdOutputObservation (source=None, exit code=0, metadata={
  "exit_code": 0,
  "pid": -1,
  "username": "root",
  "hostname": "2e3c3856de7f",
  "working_dir": "/workspace/django__django__3.0",
  "py_interpreter_path": "/opt/miniconda3/envs/testbed/bin/python",
  "prefix": "",
  "suffix": "\n[The command completed with exit code 0.]"
})**
--BEGIN AGENT OBSERVATION--

[The command completed with exit code 0.]
[Current working directory: /workspace/django__django__3.0]
[Python interpreter: /opt/miniconda3/envs/testbed/bin/python]
[Command finished with exit code 0]
--END AGENT OBSERVATION--
2026-01-06 14:33:18,880 - INFO - **CmdRunAction (source=None, is_input=False)**
COMMAND:
git reset --hard
2026-01-06 14:33:20,010 - INFO - **CmdOutputObservation (source=None, exit code=0, metadata={
  "exit_code": 0,
  "pid": -1,
  "username": "root",
  "hostname": "2e3c3856de7f",
  "working_dir": "/workspace/django__django__3.0",
  "py_interpreter_path": "/opt/miniconda3/envs/testbed/bin/python",
  "prefix": "",
  "suffix": "\n[The command completed with exit code 0.]"
})**
--BEGIN AGENT OBSERVATION--
HEAD is now at ef082ebb84 Fixed #29529 -- Allowed models.fields.FilePathField to accept a callable path.
[The command completed with exit code 0.]
[Current working directory: /workspace/django__django__3.0]
[Python interpreter: /opt/miniconda3/envs/testbed/bin/python]
[Command finished with exit code 0]
--END AGENT OBSERVATION--
2026-01-06 14:33:20,012 - INFO - **CmdRunAction (source=None, is_input=False)**
COMMAND:
for remote_name in $(git remote); do git remote remove "${remote_name}"; done
2026-01-06 14:33:20,644 - INFO - **CmdOutputObservation (source=None, exit code=0, metadata={
  "exit_code": 0,
  "pid": -1,
  "username": "root",
  "hostname": "2e3c3856de7f",
  "working_dir": "/workspace/django__django__3.0",
  "py_interpreter_path": "/opt/miniconda3/envs/testbed/bin/python",
  "prefix": "",
  "suffix": "\n[The command completed with exit code 0.]"
})**
--BEGIN AGENT OBSERVATION--

[The command completed with exit code 0.]
[Current working directory: /workspace/django__django__3.0]
[Python interpreter: /opt/miniconda3/envs/testbed/bin/python]
[Command finished with exit code 0]
--END AGENT OBSERVATION--
2026-01-06 14:33:20,645 - INFO - **CmdRunAction (source=None, is_input=False)**
COMMAND:
which python
2026-01-06 14:33:21,267 - INFO - **CmdOutputObservation (source=None, exit code=0, metadata={
  "exit_code": 0,
  "pid": -1,
  "username": "root",
  "hostname": "2e3c3856de7f",
  "working_dir": "/workspace/django__django__3.0",
  "py_interpreter_path": "/opt/miniconda3/envs/testbed/bin/python",
  "prefix": "",
  "suffix": "\n[The command completed with exit code 0.]"
})**
--BEGIN AGENT OBSERVATION--
/opt/miniconda3/envs/testbed/bin/python
[The command completed with exit code 0.]
[Current working directory: /workspace/django__django__3.0]
[Python interpreter: /opt/miniconda3/envs/testbed/bin/python]
[Command finished with exit code 0]
--END AGENT OBSERVATION--
2026-01-06 14:33:21,268 - INFO - ------------------------------
2026-01-06 14:33:21,268 - INFO - END Runtime Initialization Fn
2026-01-06 14:33:21,268 - INFO - ------------------------------
2026-01-06 14:33:21,271 - INFO - [LLM registry 05ec46e9-8551-4a80-ad8b-f28681779d63]: Registering service for agent
2026-01-06 14:33:21,287 - INFO - [runtime e39b4a00-8f1c-4d-dc85c1202b94618] Selected repo: None, loading microagents from /workspace/.openhands/microagents (inside runtime)
2026-01-06 14:33:21,290 - INFO - [runtime e39b4a00-8f1c-4d-dc85c1202b94618] Attempting to list files in repository microagents directory: /workspace/.openhands/microagents
2026-01-06 14:33:21,293 - INFO - Loading user workspace microagents: []
2026-01-06 14:33:21,293 - INFO - AgentController e39b4a00-8f1c-4d-dc85c1202b94618 - created new state. start_id: 0
2026-01-06 14:33:21,301 - INFO - [Agent Controller e39b4a00-8f1c-4d-dc85c1202b94618] Setting agent(CodeActAgent) state from AgentState.LOADING to AgentState.RUNNING
2026-01-06 14:33:21,305 - INFO - Saved conversation stats
2026-01-06 14:43:29,175 - INFO - [Agent Controller e39b4a00-8f1c-4d-dc85c1202b94618] Setting agent(CodeActAgent) state from AgentState.RUNNING to AgentState.FINISHED
2026-01-06 14:43:29,177 - INFO - Saved conversation stats
2026-01-06 14:43:29,890 - INFO - ------------------------------
2026-01-06 14:43:29,890 - INFO - BEGIN Runtime Completion Fn
2026-01-06 14:43:29,891 - INFO - ------------------------------
2026-01-06 14:43:29,891 - INFO - **CmdRunAction (source=None, is_input=False)**
COMMAND:
cd /workspace/django__django__3.0
2026-01-06 14:43:30,513 - INFO - **CmdOutputObservation (source=None, exit code=0, metadata={
  "exit_code": 0,
  "pid": -1,
  "username": "root",
  "hostname": "2e3c3856de7f",
  "working_dir": "/workspace/django__django__3.0",
  "py_interpreter_path": "/opt/miniconda3/envs/testbed/bin/python",
  "prefix": "",
  "suffix": "\n[The command completed with exit code 0.]"
})**
--BEGIN AGENT OBSERVATION--

[The command completed with exit code 0.]
[Current working directory: /workspace/django__django__3.0]
[Python interpreter: /opt/miniconda3/envs/testbed/bin/python]
[Command finished with exit code 0]
--END AGENT OBSERVATION--
2026-01-06 14:43:30,513 - INFO - **CmdRunAction (source=None, is_input=False)**
COMMAND:
git config --global core.pager ""
2026-01-06 14:43:31,132 - INFO - **CmdOutputObservation (source=None, exit code=0, metadata={
  "exit_code": 0,
  "pid": -1,
  "username": "root",
  "hostname": "2e3c3856de7f",
  "working_dir": "/workspace/django__django__3.0",
  "py_interpreter_path": "/opt/miniconda3/envs/testbed/bin/python",
  "prefix": "",
  "suffix": "\n[The command completed with exit code 0.]"
})**
--BEGIN AGENT OBSERVATION--

[The command completed with exit code 0.]
[Current working directory: /workspace/django__django__3.0]
[Python interpreter: /opt/miniconda3/envs/testbed/bin/python]
[Command finished with exit code 0]
--END AGENT OBSERVATION--
2026-01-06 14:43:31,132 - INFO - **CmdRunAction (source=None, is_input=False)**
COMMAND:
find . -type d -name .git -not -path "./.git"
2026-01-06 14:43:31,751 - INFO - **CmdOutputObservation (source=None, exit code=0, metadata={
  "exit_code": 0,
  "pid": -1,
  "username": "root",
  "hostname": "2e3c3856de7f",
  "working_dir": "/workspace/django__django__3.0",
  "py_interpreter_path": "/opt/miniconda3/envs/testbed/bin/python",
  "prefix": "",
  "suffix": "\n[The command completed with exit code 0.]"
})**
--BEGIN AGENT OBSERVATION--

[The command completed with exit code 0.]
[Current working directory: /workspace/django__django__3.0]
[Python interpreter: /opt/miniconda3/envs/testbed/bin/python]
[Command finished with exit code 0]
--END AGENT OBSERVATION--
2026-01-06 14:43:31,751 - INFO - **CmdRunAction (source=None, is_input=False)**
COMMAND:
git add -A
2026-01-06 14:43:32,371 - INFO - **CmdOutputObservation (source=None, exit code=0, metadata={
  "exit_code": 0,
  "pid": -1,
  "username": "root",
  "hostname": "2e3c3856de7f",
  "working_dir": "/workspace/django__django__3.0",
  "py_interpreter_path": "/opt/miniconda3/envs/testbed/bin/python",
  "prefix": "",
  "suffix": "\n[The command completed with exit code 0.]"
})**
--BEGIN AGENT OBSERVATION--

[The command completed with exit code 0.]
[Current working directory: /workspace/django__django__3.0]
[Python interpreter: /opt/miniconda3/envs/testbed/bin/python]
[Command finished with exit code 0]
--END AGENT OBSERVATION--
2026-01-06 14:43:32,371 - INFO - **CmdRunAction (source=None, is_input=False)**
COMMAND:
for file in $(git status --porcelain | grep -E "^(M| M|\?\?|A| A)" | cut -c4-); do
        if [ -f "$file" ] && (file "$file" | grep -q "executable" || git check-attr binary "$file" | grep -q "binary: set"); then
            git rm -f "$file" 2>/dev/null || rm -f "$file"
            echo "Removed: $file"
        fi
    done
2026-01-06 14:43:32,996 - INFO - **CmdOutputObservation (source=None, exit code=0, metadata={
  "exit_code": 0,
  "pid": -1,
  "username": "root",
  "hostname": "2e3c3856de7f",
  "working_dir": "/workspace/django__django__3.0",
  "py_interpreter_path": "/opt/miniconda3/envs/testbed/bin/python",
  "prefix": "",
  "suffix": "\n[The command completed with exit code 0.]"
})**
--BEGIN AGENT OBSERVATION--
bash: file: command not found
bash: file: command not found
bash: file: command not found
bash: file: command not found
bash: file: command not found
[The command completed with exit code 0.]
[Current working directory: /workspace/django__django__3.0]
[Python interpreter: /opt/miniconda3/envs/testbed/bin/python]
[Command finished with exit code 0]
--END AGENT OBSERVATION--
2026-01-06 14:43:32,996 - INFO - **CmdRunAction (source=None, is_input=False)**
COMMAND:
git diff --no-color --cached ef082ebb84f00e38af4e8880d04e8365c2766d34 > patch.diff
2026-01-06 14:43:33,616 - INFO - **CmdOutputObservation (source=None, exit code=0, metadata={
  "exit_code": 0,
  "pid": -1,
  "username": "root",
  "hostname": "2e3c3856de7f",
  "working_dir": "/workspace/django__django__3.0",
  "py_interpreter_path": "/opt/miniconda3/envs/testbed/bin/python",
  "prefix": "",
  "suffix": "\n[The command completed with exit code 0.]"
})**
--BEGIN AGENT OBSERVATION--

[The command completed with exit code 0.]
[Current working directory: /workspace/django__django__3.0]
[Python interpreter: /opt/miniconda3/envs/testbed/bin/python]
[Command finished with exit code 0]
--END AGENT OBSERVATION--
2026-01-06 14:43:33,616 - INFO - FileReadAction(path='patch.diff', start=0, end=-1, thought='', action=<ActionType.READ: 'read'>, security_risk=<ActionSecurityRisk.UNKNOWN: -1>, impl_source=<FileReadSource.DEFAULT: 'default'>, view_range=None)
2026-01-06 14:43:33,620 - INFO - [Read from /workspace/django__django__3.0/patch.diff is successful.]
diff --git a/debug_duplicates.py b/debug_duplicates.py
new file mode 100644
index 0000000000..feb4b0250c
--- /dev/null
+++ b/debug_duplicates.py
@@ -0,0 +1,102 @@
+#!/usr/bin/env python
+"""
+Debug duplicate detection behavior.
+"""
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        SECRET_KEY='test-secret-key',
+    )
+    django.setup()
+
+from django.db import models
+from django.db.models.expressions import RawSQL
+from django.db.models.sql.compiler import SQLCompiler
+from django.db.models.sql.query import Query
+from django.db import connection
+
+# Create a simple test model
+class TestModel(models.Model):
+    name = models.CharField(max_length=100)
+    status = models.CharField(max_length=50)
+    created_at = models.DateTimeField(auto_now_add=True)
+    
+    class Meta:
+        app_label = 'test_app'
+
+def debug_duplicate_detection():
+    """Debug how duplicate detection works."""
+    
+    # Test with different SQL to see the behavior
+    queryset = TestModel.objects.all().order_by(
+        RawSQL('case when status = "active" then 1 else 2 end', []).desc(),
+        RawSQL('case when status = "pending" then 1 else 2 end', []).asc(),  # Different SQL
+        RawSQL('case when status = "active" then 1 else 2 end', []).desc(),  # Exact duplicate
+    )
+    
+    query = queryset.query
+    compiler = SQLCompiler(query, connection, 'default')
+    order_by_clauses = compiler.get_order_by()
+    
+    print(f"Number of clauses: {len(order_by_clauses)}")
+    
+    for i, (expr, (sql, params, is_ref)) in enumerate(order_by_clauses):
+        print(f"\nClause {i+1}:")
+        print(f"  SQL: {sql}")
+        print(f"  Params: {params}")
+        print(f"  Is Ref: {is_ref}")
+        
+        # Test what the ordering_parts regex extracts
+        sql_normalized = ' '.join(sql.split())
+        without_ordering = compiler.ordering_parts.search(sql_normalized).group(1)
+        print(f"  Normalized SQL: {sql_normalized}")
+        print(f"  Extracted by ordering_parts: '{without_ordering}'")
+        print(f"  Params hash: {hash(tuple(params))}")
+        
+    # Now test the original case
+    print("\n" + "="*50)
+    print("Testing original case with same SQL, different directions:")
+    
+    queryset2 = TestModel.objects.all().order_by(
+        RawSQL('case when status = "active" then 1 else 2 end', []).desc(),
+        RawSQL('case when status = "active" then 1 else 2 end', []).asc(),  # Same SQL, different direction
+    )
+    
+    query2 = queryset2.query
+    compiler2 = SQLCompiler(query2, connection, 'default')
+    order_by_clauses2 = compiler2.get_order_by()
+    
+    print(f"Number of clauses: {len(order_by_clauses2)}")
+    
+    for i, (expr, (sql, params, is_ref)) in enumerate(order_by_clauses2):
+        print(f"\nClause {i+1}:")
+        print(f"  SQL: {sql}")
+        print(f"  Params: {params}")
+        print(f"  Is Ref: {is_ref}")
+        
+        # Test what the ordering_parts regex extracts
+        sql_normalized = ' '.join(sql.split())
+        without_ordering = compiler2.ordering_parts.search(sql_normalized).group(1)
+        print(f"  Normalized SQL: {sql_normalized}")
+        print(f"  Extracted by ordering_parts: '{without_ordering}'")
+        print(f"  Params hash: {hash(tuple(params))}")
+
+if __name__ == '__main__':
+    debug_duplicate_detection()
diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py
index 7649c39262..4b73b86176 100644
--- a/django/db/models/sql/compiler.py
+++ b/django/db/models/sql/compiler.py
@@ -353,7 +353,10 @@ class SQLCompiler:
             # not taken into account so we strip it. When this entire method
             # is refactored into expressions, then we can check each part as we
             # generate it.
-            without_ordering = self.ordering_parts.search(sql).group(1)
+            # Normalize multiline SQL by replacing newlines with spaces to ensure
+            # the regex captures the full expression, not just the last line.
+            sql_normalized = ' '.join(sql.split())
+            without_ordering = self.ordering_parts.search(sql_normalized).group(1)
             params_hash = make_hashable(params)
             if (without_ordering, params_hash) in seen:
                 continue
@@ -366,7 +369,10 @@ class SQLCompiler:
         if self.query.distinct and not self.query.distinct_fields:
             select_sql = [t[1] for t in select]
             for expr, (sql, params, is_ref) in order_by:
-                without_ordering = self.ordering_parts.search(sql).group(1)
+                # Normalize multiline SQL by replacing newlines with spaces to ensure
+                # the regex captures the full expression, not just the last line.
+                sql_normalized = ' '.join(sql.split())
+                without_ordering = self.ordering_parts.search(sql_normalized).group(1)
                 if not is_ref and (without_ordering, params) not in select_sql:
                     extra_select.append((expr, (without_ordering, params), None))
         return extra_select
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..7c59bb11ad
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,137 @@
+#!/usr/bin/env python
+"""
+Reproduction script for the multiline RawSQL order_by issue.
+This script demonstrates the bug where order_by clauses with multiline RawSQL
+are incorrectly removed when their last lines are identical.
+"""
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        SECRET_KEY='test-secret-key',
+    )
+    django.setup()
+
+from django.db import models
+from django.db.models.expressions import RawSQL
+from django.db.models.sql.compiler import SQLCompiler
+from django.db.models.sql.query import Query
+from django.db import connection
+
+# Create a simple test model
+class TestModel(models.Model):
+    name = models.CharField(max_length=100)
+    status = models.CharField(max_length=50)
+    accepted_datetime = models.DateTimeField(null=True)
+    preferred_datetime = models.DateTimeField(null=True)
+    created_at = models.DateTimeField(auto_now_add=True)
+    
+    class Meta:
+        app_label = 'test_app'
+
+def test_multiline_rawsql_order_by():
+    """Test that multiline RawSQL order_by clauses are not incorrectly removed."""
+    
+    # Create a query with multiple multiline RawSQL order_by clauses
+    # similar to the example in the issue description
+    queryset = TestModel.objects.all().order_by(
+        RawSQL('''
+            case when status in ('accepted', 'verification')
+                 then 2 else 1 end''', []).desc(),
+        RawSQL('''
+            case when status in ('accepted', 'verification')
+                 then (accepted_datetime, preferred_datetime)
+                 else null end''', []).asc(),
+        RawSQL('''
+            case when status not in ('accepted', 'verification')
+                 then (accepted_datetime, preferred_datetime, created_at)
+                 else null end''', []).desc()
+    )
+    
+    # Get the query and compiler
+    query = queryset.query
+    compiler = SQLCompiler(query, connection, 'default')
+    
+    # Get the order_by clauses
+    order_by_clauses = compiler.get_order_by()
+    
+    print(f"Number of order_by clauses: {len(order_by_clauses)}")
+    print("Expected: 3 clauses")
+    
+    for i, (expr, (sql, params, is_ref)) in enumerate(order_by_clauses):
+        print(f"\nClause {i+1}:")
+        print(f"  SQL: {sql}")
+        print(f"  Params: {params}")
+        print(f"  Is Ref: {is_ref}")
+        
+        # Test what the ordering_parts regex extracts
+        without_ordering = compiler.ordering_parts.search(sql).group(1)
+        print(f"  Extracted by ordering_parts: '{without_ordering}'")
+    
+    # Check if we have all 3 clauses
+    if len(order_by_clauses) == 3:
+        print("\n✓ SUCCESS: All 3 order_by clauses are present")
+        return True
+    else:
+        print(f"\n✗ FAILURE: Only {len(order_by_clauses)} order_by clauses present (expected 3)")
+        return False
+
+def test_regex_behavior():
+    """Test the regex behavior with multiline strings."""
+    import re
+    
+    # This is the same regex used in SQLCompiler
+    ordering_parts = re.compile(r'(.*)\s(ASC|DESC)(.*)')
+    
+    # Test cases from the issue
+    test_cases = [
+        "case when status in ('accepted', 'verification') then 2 else 1 end DESC",
+        "case when status in ('accepted', 'verification')\n then (accepted_datetime, preferred_datetime)\n else null end ASC",
+        "case when status not in ('accepted', 'verification')\n then (accepted_datetime, preferred_datetime, created_at)\n else null end DESC"
+    ]
+    
+    print("\n" + "="*50)
+    print("TESTING REGEX BEHAVIOR")
+    print("="*50)
+    
+    for i, sql in enumerate(test_cases):
+        match = ordering_parts.search(sql)
+        if match:
+            extracted = match.group(1)
+            print(f"\nTest case {i+1}:")
+            print(f"  Full SQL: {repr(sql)}")
+            print(f"  Extracted: {repr(extracted)}")
+        else:
+            print(f"\nTest case {i+1}: No match found")
+
+if __name__ == '__main__':
+    print("Reproducing multiline RawSQL order_by issue...")
+    print("="*50)
+    
+    # Test regex behavior first
+    test_regex_behavior()
+    
+    print("\n" + "="*50)
+    print("TESTING DJANGO QUERY BEHAVIOR")
+    print("="*50)
+    
+    # Test the actual Django behavior
+    success = test_multiline_rawsql_order_by()
+    
+    sys.exit(0 if success else 1)
diff --git a/run_basic_tests.py b/run_basic_tests.py
new file mode 100644
index 0000000000..98e730bb59
--- /dev/null
+++ b/run_basic_tests.py
@@ -0,0 +1,160 @@
+#!/usr/bin/env python
+"""
+Run basic tests to ensure our changes don't break existing functionality.
+"""
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+            'django.contrib.sessions',
+            'django.contrib.messages',
+        ],
+        SECRET_KEY='test-secret-key',
+        USE_TZ=True,
+    )
+    django.setup()
+
+from django.db import models
+from django.db.models.expressions import RawSQL
+from django.test import TestCase
+
+# Create test models
+class TestCompany(models.Model):
+    name = models.CharField(max_length=100)
+    num_employees = models.IntegerField()
+    num_chairs = models.IntegerField()
+    
+    class Meta:
+        app_label = 'test_app'
+
+class TestEmployee(models.Model):
+    firstname = models.CharField(max_length=100)
+    lastname = models.CharField(max_length=100)
+    salary = models.IntegerField()
+    company = models.ForeignKey(TestCompany, on_delete=models.CASCADE, null=True)
+    
+    class Meta:
+        app_label = 'test_app'
+
+def test_basic_rawsql_annotation():
+    """Test basic RawSQL annotation functionality."""
+    print("Testing basic RawSQL annotation...")
+    
+    # Create test data
+    company = TestCompany.objects.create(name="Test Inc.", num_employees=100, num_chairs=50)
+    
+    # Test annotation with RawSQL
+    companies = TestCompany.objects.annotate(
+        foo=RawSQL('%s', ['value']),
+    ).filter(foo='value').order_by('name')
+    
+    count = companies.count()
+    print(f"  Annotated companies count: {count}")
+    assert count == 1, "RawSQL annotation should work"
+    print("  ✓ Basic RawSQL annotation works")
+
+def test_basic_order_by():
+    """Test basic order_by functionality."""
+    print("Testing basic order_by...")
+    
+    # Create test data
+    TestCompany.objects.all().delete()
+    TestCompany.objects.create(name="B Company", num_employees=50, num_chairs=25)
+    TestCompany.objects.create(name="A Company", num_employees=100, num_chairs=50)
+    TestCompany.objects.create(name="C Company", num_employees=75, num_chairs=40)
+    
+    # Test basic ordering
+    companies = TestCompany.objects.order_by('name')
+    names = [c.name for c in companies]
+    
+    expected = ['A Company', 'B Company', 'C Company']
+    print(f"  Ordered names: {names}")
+    assert names == expected, "Basic order_by should work"
+    print("  ✓ Basic order_by works")
+
+def test_rawsql_order_by_single_line():
+    """Test RawSQL in order_by with single-line SQL."""
+    print("Testing RawSQL order_by with single-line SQL...")
+    
+    # Create test data
+    TestCompany.objects.all().delete()
+    TestCompany.objects.create(name="A Company", num_employees=100, num_chairs=50)
+    TestCompany.objects.create(name="B Company", num_employees=50, num_chairs=25)
+    
+    # Test single-line RawSQL order_by
+    companies = TestCompany.objects.order_by(
+        RawSQL('num_employees + num_chairs', []).desc()
+    )
+    
+    # Should be ordered by total (150, then 75)
+    names = [c.name for c in companies]
+    expected = ['A Company', 'B Company']
+    
+    print(f"  Ordered by RawSQL: {names}")
+    assert names == expected, "Single-line RawSQL order_by should work"
+    print("  ✓ Single-line RawSQL order_by works")
+
+def test_mixed_ordering():
+    """Test mixing regular fields and RawSQL in order_by."""
+    print("Testing mixed order_by (fields + RawSQL)...")
+    
+    # Create test data
+    TestCompany.objects.all().delete()
+    TestCompany.objects.create(name="A Company", num_employees=100, num_chairs=50)
+    TestCompany.objects.create(name="B Company", num_employees=100, num_chairs=25)
+    
+    # Test mixed ordering
+    companies = TestCompany.objects.order_by(
+        'num_employees',  # Regular field
+        RawSQL('num_chairs', []).desc()  # RawSQL
+    )
+    
+    # Both have 100 employees, but A has more chairs so comes first
+    names = [c.name for c in companies]
+    expected = ['A Company', 'B Company']
+    
+    print(f"  Mixed order_by result: {names}")
+    assert names == expected, "Mixed order_by should work"
+    print("  ✓ Mixed order_by works")
+
+if __name__ == '__main__':
+    print("Running basic tests to verify our changes don't break existing functionality...")
+    print("="*70)
+    
+    try:
+        # Create tables
+        from django.db import connection
+        with connection.schema_editor() as schema_editor:
+            schema_editor.create_model(TestCompany)
+            schema_editor.create_model(TestEmployee)
+        
+        test_basic_rawsql_annotation()
+        test_basic_order_by()
+        test_rawsql_order_by_single_line()
+        test_mixed_ordering()
+        
+        print("\n" + "="*70)
+        print("✓ ALL BASIC TESTS PASSED")
+        print("Our changes don't break existing functionality!")
+        sys.exit(0)
+        
+    except Exception as e:
+        print(f"\n✗ TEST FAILED: {e}")
+        import traceback
+        traceback.print_exc()
+        sys.exit(1)
diff --git a/test_edge_cases.py b/test_edge_cases.py
new file mode 100644
index 0000000000..497d5b809b
--- /dev/null
+++ b/test_edge_cases.py
@@ -0,0 +1,166 @@
+#!/usr/bin/env python
+"""
+Edge case tests for the multiline RawSQL order_by fix.
+"""
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        SECRET_KEY='test-secret-key',
+    )
+    django.setup()
+
+from django.db import models
+from django.db.models.expressions import RawSQL
+from django.db.models.sql.compiler import SQLCompiler
+from django.db.models.sql.query import Query
+from django.db import connection
+
+# Create a simple test model
+class TestModel(models.Model):
+    name = models.CharField(max_length=100)
+    status = models.CharField(max_length=50)
+    created_at = models.DateTimeField(auto_now_add=True)
+    
+    class Meta:
+        app_label = 'test_app'
+
+def test_single_line_sql():
+    """Test that single-line SQL still works correctly."""
+    print("Testing single-line SQL...")
+    
+    queryset = TestModel.objects.all().order_by(
+        RawSQL('case when status = "active" then 1 else 2 end', []).desc(),
+        RawSQL('case when status = "pending" then 1 else 2 end', []).asc(),
+    )
+    
+    query = queryset.query
+    compiler = SQLCompiler(query, connection, 'default')
+    order_by_clauses = compiler.get_order_by()
+    
+    print(f"  Number of clauses: {len(order_by_clauses)} (expected: 2)")
+    assert len(order_by_clauses) == 2, "Single-line SQL should work correctly"
+    print("  ✓ Single-line SQL works correctly")
+
+def test_duplicate_detection():
+    """Test that actual duplicates are still detected and removed."""
+    print("Testing duplicate detection...")
+    
+    queryset = TestModel.objects.all().order_by(
+        RawSQL('case when status = "active" then 1 else 2 end', []).desc(),
+        RawSQL('case when status = "active" then 1 else 2 end', []).asc(),  # Same SQL, different direction
+        RawSQL('case when status = "active" then 1 else 2 end', []).desc(),  # Exact duplicate
+    )
+    
+    query = queryset.query
+    compiler = SQLCompiler(query, connection, 'default')
+    order_by_clauses = compiler.get_order_by()
+    
+    print(f"  Number of clauses: {len(order_by_clauses)} (expected: 1)")
+    # Django removes duplicates regardless of direction - only the first occurrence is kept
+    assert len(order_by_clauses) == 1, "Should detect and remove duplicates regardless of direction"
+    print("  ✓ Duplicate detection works correctly")
+
+def test_mixed_line_formats():
+    """Test mixed single-line and multiline SQL."""
+    print("Testing mixed line formats...")
+    
+    queryset = TestModel.objects.all().order_by(
+        RawSQL('case when status = "active" then 1 else 2 end', []).desc(),
+        RawSQL('''
+            case when status = "pending"
+                 then 2 else 3 end''', []).asc(),
+        RawSQL('case when status = "inactive" then 3 else 4 end', []).desc(),
+    )
+    
+    query = queryset.query
+    compiler = SQLCompiler(query, connection, 'default')
+    order_by_clauses = compiler.get_order_by()
+    
+    print(f"  Number of clauses: {len(order_by_clauses)} (expected: 3)")
+    assert len(order_by_clauses) == 3, "Mixed line formats should work correctly"
+    print("  ✓ Mixed line formats work correctly")
+
+def test_various_whitespace():
+    """Test various whitespace patterns."""
+    print("Testing various whitespace patterns...")
+    
+    queryset = TestModel.objects.all().order_by(
+        RawSQL('''
+			case when status = "active"
+				 then 1 else 2 end''', []).desc(),  # Tabs
+        RawSQL('''
+            case when status = "pending"
+                 then 2 else 3 end''', []).asc(),  # Spaces
+        RawSQL('''
+case when status = "inactive"
+then 3 else 4 end''', []).desc(),  # Mixed
+    )
+    
+    query = queryset.query
+    compiler = SQLCompiler(query, connection, 'default')
+    order_by_clauses = compiler.get_order_by()
+    
+    print(f"  Number of clauses: {len(order_by_clauses)} (expected: 3)")
+    assert len(order_by_clauses) == 3, "Various whitespace patterns should work correctly"
+    print("  ✓ Various whitespace patterns work correctly")
+
+def test_empty_lines():
+    """Test SQL with empty lines."""
+    print("Testing SQL with empty lines...")
+    
+    queryset = TestModel.objects.all().order_by(
+        RawSQL('''
+
+            case when status = "active"
+                 then 1 else 2 end''', []).desc(),  # Leading empty lines
+        RawSQL('''
+            case when status = "pending"
+
+                 then 2 else 3 end''', []).asc(),  # Middle empty lines
+    )
+    
+    query = queryset.query
+    compiler = SQLCompiler(query, connection, 'default')
+    order_by_clauses = compiler.get_order_by()
+    
+    print(f"  Number of clauses: {len(order_by_clauses)} (expected: 2)")
+    assert len(order_by_clauses) == 2, "SQL with empty lines should work correctly"
+    print("  ✓ SQL with empty lines works correctly")
+
+if __name__ == '__main__':
+    print("Running edge case tests for multiline RawSQL order_by fix...")
+    print("="*60)
+    
+    try:
+        test_single_line_sql()
+        test_duplicate_detection()
+        test_mixed_line_formats()
+        test_various_whitespace()
+        test_empty_lines()
+        
+        print("\n" + "="*60)
+        print("✓ ALL EDGE CASE TESTS PASSED")
+        sys.exit(0)
+        
+    except Exception as e:
+        print(f"\n✗ TEST FAILED: {e}")
+        import traceback
+        traceback.print_exc()
+        sys.exit(1)

2026-01-06 14:43:33,622 - INFO - ------------------------------
2026-01-06 14:43:33,622 - INFO - END Runtime Completion Fn
2026-01-06 14:43:33,622 - INFO - ------------------------------
2026-01-06 14:43:33,622 - INFO - Got git diff for instance django__django-11001:
--------
diff --git a/debug_duplicates.py b/debug_duplicates.py
new file mode 100644
index 0000000000..feb4b0250c
--- /dev/null
+++ b/debug_duplicates.py
@@ -0,0 +1,102 @@
+#!/usr/bin/env python
+"""
+Debug duplicate detection behavior.
+"""
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        SECRET_KEY='test-secret-key',
+    )
+    django.setup()
+
+from django.db import models
+from django.db.models.expressions import RawSQL
+from django.db.models.sql.compiler import SQLCompiler
+from django.db.models.sql.query import Query
+from django.db import connection
+
+# Create a simple test model
+class TestModel(models.Model):
+    name = models.CharField(max_length=100)
+    status = models.CharField(max_length=50)
+    created_at = models.DateTimeField(auto_now_add=True)
+    
+    class Meta:
+        app_label = 'test_app'
+
+def debug_duplicate_detection():
+    """Debug how duplicate detection works."""
+    
+    # Test with different SQL to see the behavior
+    queryset = TestModel.objects.all().order_by(
+        RawSQL('case when status = "active" then 1 else 2 end', []).desc(),
+        RawSQL('case when status = "pending" then 1 else 2 end', []).asc(),  # Different SQL
+        RawSQL('case when status = "active" then 1 else 2 end', []).desc(),  # Exact duplicate
+    )
+    
+    query = queryset.query
+    compiler = SQLCompiler(query, connection, 'default')
+    order_by_clauses = compiler.get_order_by()
+    
+    print(f"Number of clauses: {len(order_by_clauses)}")
+    
+    for i, (expr, (sql, params, is_ref)) in enumerate(order_by_clauses):
+        print(f"\nClause {i+1}:")
+        print(f"  SQL: {sql}")
+        print(f"  Params: {params}")
+        print(f"  Is Ref: {is_ref}")
+        
+        # Test what the ordering_parts regex extracts
+        sql_normalized = ' '.join(sql.split())
+        without_ordering = compiler.ordering_parts.search(sql_normalized).group(1)
+        print(f"  Normalized SQL: {sql_normalized}")
+        print(f"  Extracted by ordering_parts: '{without_ordering}'")
+        print(f"  Params hash: {hash(tuple(params))}")
+        
+    # Now test the original case
+    print("\n" + "="*50)
+    print("Testing original case with same SQL, different directions:")
+    
+    queryset2 = TestModel.objects.all().order_by(
+        RawSQL('case when status = "active" then 1 else 2 end', []).desc(),
+        RawSQL('case when status = "active" then 1 else 2 end', []).asc(),  # Same SQL, different direction
+    )
+    
+    query2 = queryset2.query
+    compiler2 = SQLCompiler(query2, connection, 'default')
+    order_by_clauses2 = compiler2.get_order_by()
+    
+    print(f"Number of clauses: {len(order_by_clauses2)}")
+    
+    for i, (expr, (sql, params, is_ref)) in enumerate(order_by_clauses2):
+        print(f"\nClause {i+1}:")
+        print(f"  SQL: {sql}")
+        print(f"  Params: {params}")
+        print(f"  Is Ref: {is_ref}")
+        
+        # Test what the ordering_parts regex extracts
+        sql_normalized = ' '.join(sql.split())
+        without_ordering = compiler2.ordering_parts.search(sql_normalized).group(1)
+        print(f"  Normalized SQL: {sql_normalized}")
+        print(f"  Extracted by ordering_parts: '{without_ordering}'")
+        print(f"  Params hash: {hash(tuple(params))}")
+
+if __name__ == '__main__':
+    debug_duplicate_detection()
diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py
index 7649c39262..4b73b86176 100644
--- a/django/db/models/sql/compiler.py
+++ b/django/db/models/sql/compiler.py
@@ -353,7 +353,10 @@ class SQLCompiler:
             # not taken into account so we strip it. When this entire method
             # is refactored into expressions, then we can check each part as we
             # generate it.
-            without_ordering = self.ordering_parts.search(sql).group(1)
+            # Normalize multiline SQL by replacing newlines with spaces to ensure
+            # the regex captures the full expression, not just the last line.
+            sql_normalized = ' '.join(sql.split())
+            without_ordering = self.ordering_parts.search(sql_normalized).group(1)
             params_hash = make_hashable(params)
             if (without_ordering, params_hash) in seen:
                 continue
@@ -366,7 +369,10 @@ class SQLCompiler:
         if self.query.distinct and not self.query.distinct_fields:
             select_sql = [t[1] for t in select]
             for expr, (sql, params, is_ref) in order_by:
-                without_ordering = self.ordering_parts.search(sql).group(1)
+                # Normalize multiline SQL by replacing newlines with spaces to ensure
+                # the regex captures the full expression, not just the last line.
+                sql_normalized = ' '.join(sql.split())
+                without_ordering = self.ordering_parts.search(sql_normalized).group(1)
                 if not is_ref and (without_ordering, params) not in select_sql:
                     extra_select.append((expr, (without_ordering, params), None))
         return extra_select
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..7c59bb11ad
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,137 @@
+#!/usr/bin/env python
+"""
+Reproduction script for the multiline RawSQL order_by issue.
+This script demonstrates the bug where order_by clauses with multiline RawSQL
+are incorrectly removed when their last lines are identical.
+"""
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        SECRET_KEY='test-secret-key',
+    )
+    django.setup()
+
+from django.db import models
+from django.db.models.expressions import RawSQL
+from django.db.models.sql.compiler import SQLCompiler
+from django.db.models.sql.query import Query
+from django.db import connection
+
+# Create a simple test model
+class TestModel(models.Model):
+    name = models.CharField(max_length=100)
+    status = models.CharField(max_length=50)
+    accepted_datetime = models.DateTimeField(null=True)
+    preferred_datetime = models.DateTimeField(null=True)
+    created_at = models.DateTimeField(auto_now_add=True)
+    
+    class Meta:
+        app_label = 'test_app'
+
+def test_multiline_rawsql_order_by():
+    """Test that multiline RawSQL order_by clauses are not incorrectly removed."""
+    
+    # Create a query with multiple multiline RawSQL order_by clauses
+    # similar to the example in the issue description
+    queryset = TestModel.objects.all().order_by(
+        RawSQL('''
+            case when status in ('accepted', 'verification')
+                 then 2 else 1 end''', []).desc(),
+        RawSQL('''
+            case when status in ('accepted', 'verification')
+                 then (accepted_datetime, preferred_datetime)
+                 else null end''', []).asc(),
+        RawSQL('''
+            case when status not in ('accepted', 'verification')
+                 then (accepted_datetime, preferred_datetime, created_at)
+                 else null end''', []).desc()
+    )
+    
+    # Get the query and compiler
+    query = queryset.query
+    compiler = SQLCompiler(query, connection, 'default')
+    
+    # Get the order_by clauses
+    order_by_clauses = compiler.get_order_by()
+    
+    print(f"Number of order_by clauses: {len(order_by_clauses)}")
+    print("Expected: 3 clauses")
+    
+    for i, (expr, (sql, params, is_ref)) in enumerate(order_by_clauses):
+        print(f"\nClause {i+1}:")
+        print(f"  SQL: {sql}")
+        print(f"  Params: {params}")
+        print(f"  Is Ref: {is_ref}")
+        
+        # Test what the ordering_parts regex extracts
+        without_ordering = compiler.ordering_parts.search(sql).group(1)
+        print(f"  Extracted by ordering_parts: '{without_ordering}'")
+    
+    # Check if we have all 3 clauses
+    if len(order_by_clauses) == 3:
+        print("\n✓ SUCCESS: All 3 order_by clauses are present")
+        return True
+    else:
+        print(f"\n✗ FAILURE: Only {len(order_by_clauses)} order_by clauses present (expected 3)")
+        return False
+
+def test_regex_behavior():
+    """Test the regex behavior with multiline strings."""
+    import re
+    
+    # This is the same regex used in SQLCompiler
+    ordering_parts = re.compile(r'(.*)\s(ASC|DESC)(.*)')
+    
+    # Test cases from the issue
+    test_cases = [
+        "case when status in ('accepted', 'verification') then 2 else 1 end DESC",
+        "case when status in ('accepted', 'verification')\n then (accepted_datetime, preferred_datetime)\n else null end ASC",
+        "case when status not in ('accepted', 'verification')\n then (accepted_datetime, preferred_datetime, created_at)\n else null end DESC"
+    ]
+    
+    print("\n" + "="*50)
+    print("TESTING REGEX BEHAVIOR")
+    print("="*50)
+    
+    for i, sql in enumerate(test_cases):
+        match = ordering_parts.search(sql)
+        if match:
+            extracted = match.group(1)
+            print(f"\nTest case {i+1}:")
+            print(f"  Full SQL: {repr(sql)}")
+            print(f"  Extracted: {repr(extracted)}")
+        else:
+            print(f"\nTest case {i+1}: No match found")
+
+if __name__ == '__main__':
+    print("Reproducing multiline RawSQL order_by issue...")
+    print("="*50)
+    
+    # Test regex behavior first
+    test_regex_behavior()
+    
+    print("\n" + "="*50)
+    print("TESTING DJANGO QUERY BEHAVIOR")
+    print("="*50)
+    
+    # Test the actual Django behavior
+    success = test_multiline_rawsql_order_by()
+    
+    sys.exit(0 if success else 1)
diff --git a/run_basic_tests.py b/run_basic_tests.py
new file mode 100644
index 0000000000..98e730bb59
--- /dev/null
+++ b/run_basic_tests.py
@@ -0,0 +1,160 @@
+#!/usr/bin/env python
+"""
+Run basic tests to ensure our changes don't break existing functionality.
+"""
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+            'django.contrib.sessions',
+            'django.contrib.messages',
+        ],
+        SECRET_KEY='test-secret-key',
+        USE_TZ=True,
+    )
+    django.setup()
+
+from django.db import models
+from django.db.models.expressions import RawSQL
+from django.test import TestCase
+
+# Create test models
+class TestCompany(models.Model):
+    name = models.CharField(max_length=100)
+    num_employees = models.IntegerField()
+    num_chairs = models.IntegerField()
+    
+    class Meta:
+        app_label = 'test_app'
+
+class TestEmployee(models.Model):
+    firstname = models.CharField(max_length=100)
+    lastname = models.CharField(max_length=100)
+    salary = models.IntegerField()
+    company = models.ForeignKey(TestCompany, on_delete=models.CASCADE, null=True)
+    
+    class Meta:
+        app_label = 'test_app'
+
+def test_basic_rawsql_annotation():
+    """Test basic RawSQL annotation functionality."""
+    print("Testing basic RawSQL annotation...")
+    
+    # Create test data
+    company = TestCompany.objects.create(name="Test Inc.", num_employees=100, num_chairs=50)
+    
+    # Test annotation with RawSQL
+    companies = TestCompany.objects.annotate(
+        foo=RawSQL('%s', ['value']),
+    ).filter(foo='value').order_by('name')
+    
+    count = companies.count()
+    print(f"  Annotated companies count: {count}")
+    assert count == 1, "RawSQL annotation should work"
+    print("  ✓ Basic RawSQL annotation works")
+
+def test_basic_order_by():
+    """Test basic order_by functionality."""
+    print("Testing basic order_by...")
+    
+    # Create test data
+    TestCompany.objects.all().delete()
+    TestCompany.objects.create(name="B Company", num_employees=50, num_chairs=25)
+    TestCompany.objects.create(name="A Company", num_employees=100, num_chairs=50)
+    TestCompany.objects.create(name="C Company", num_employees=75, num_chairs=40)
+    
+    # Test basic ordering
+    companies = TestCompany.objects.order_by('name')
+    names = [c.name for c in companies]
+    
+    expected = ['A Company', 'B Company', 'C Company']
+    print(f"  Ordered names: {names}")
+    assert names == expected, "Basic order_by should work"
+    print("  ✓ Basic order_by works")
+
+def test_rawsql_order_by_single_line():
+    """Test RawSQL in order_by with single-line SQL."""
+    print("Testing RawSQL order_by with single-line SQL...")
+    
+    # Create test data
+    TestCompany.objects.all().delete()
+    TestCompany.objects.create(name="A Company", num_employees=100, num_chairs=50)
+    TestCompany.objects.create(name="B Company", num_employees=50, num_chairs=25)
+    
+    # Test single-line RawSQL order_by
+    companies = TestCompany.objects.order_by(
+        RawSQL('num_employees + num_chairs', []).desc()
+    )
+    
+    # Should be ordered by total (150, then 75)
+    names = [c.name for c in companies]
+    expected = ['A Company', 'B Company']
+    
+    print(f"  Ordered by RawSQL: {names}")
+    assert names == expected, "Single-line RawSQL order_by should work"
+    print("  ✓ Single-line RawSQL order_by works")
+
+def test_mixed_ordering():
+    """Test mixing regular fields and RawSQL in order_by."""
+    print("Testing mixed order_by (fields + RawSQL)...")
+    
+    # Create test data
+    TestCompany.objects.all().delete()
+    TestCompany.objects.create(name="A Company", num_employees=100, num_chairs=50)
+    TestCompany.objects.create(name="B Company", num_employees=100, num_chairs=25)
+    
+    # Test mixed ordering
+    companies = TestCompany.objects.order_by(
+        'num_employees',  # Regular field
+        RawSQL('num_chairs', []).desc()  # RawSQL
+    )
+    
+    # Both have 100 employees, but A has more chairs so comes first
+    names = [c.name for c in companies]
+    expected = ['A Company', 'B Company']
+    
+    print(f"  Mixed order_by result: {names}")
+    assert names == expected, "Mixed order_by should work"
+    print("  ✓ Mixed order_by works")
+
+if __name__ == '__main__':
+    print("Running basic tests to verify our changes don't break existing functionality...")
+    print("="*70)
+    
+    try:
+        # Create tables
+        from django.db import connection
+        with connection.schema_editor() as schema_editor:
+            schema_editor.create_model(TestCompany)
+            schema_editor.create_model(TestEmployee)
+        
+        test_basic_rawsql_annotation()
+        test_basic_order_by()
+        test_rawsql_order_by_single_line()
+        test_mixed_ordering()
+        
+        print("\n" + "="*70)
+        print("✓ ALL BASIC TESTS PASSED")
+        print("Our changes don't break existing functionality!")
+        sys.exit(0)
+        
+    except Exception as e:
+        print(f"\n✗ TEST FAILED: {e}")
+        import traceback
+        traceback.print_exc()
+        sys.exit(1)
diff --git a/test_edge_cases.py b/test_edge_cases.py
new file mode 100644
index 0000000000..497d5b809b
--- /dev/null
+++ b/test_edge_cases.py
@@ -0,0 +1,166 @@
+#!/usr/bin/env python
+"""
+Edge case tests for the multiline RawSQL order_by fix.
+"""
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        SECRET_KEY='test-secret-key',
+    )
+    django.setup()
+
+from django.db import models
+from django.db.models.expressions import RawSQL
+from django.db.models.sql.compiler import SQLCompiler
+from django.db.models.sql.query import Query
+from django.db import connection
+
+# Create a simple test model
+class TestModel(models.Model):
+    name = models.CharField(max_length=100)
+    status = models.CharField(max_length=50)
+    created_at = models.DateTimeField(auto_now_add=True)
+    
+    class Meta:
+        app_label = 'test_app'
+
+def test_single_line_sql():
+    """Test that single-line SQL still works correctly."""
+    print("Testing single-line SQL...")
+    
+    queryset = TestModel.objects.all().order_by(
+        RawSQL('case when status = "active" then 1 else 2 end', []).desc(),
+        RawSQL('case when status = "pending" then 1 else 2 end', []).asc(),
+    )
+    
+    query = queryset.query
+    compiler = SQLCompiler(query, connection, 'default')
+    order_by_clauses = compiler.get_order_by()
+    
+    print(f"  Number of clauses: {len(order_by_clauses)} (expected: 2)")
+    assert len(order_by_clauses) == 2, "Single-line SQL should work correctly"
+    print("  ✓ Single-line SQL works correctly")
+
+def test_duplicate_detection():
+    """Test that actual duplicates are still detected and removed."""
+    print("Testing duplicate detection...")
+    
+    queryset = TestModel.objects.all().order_by(
+        RawSQL('case when status = "active" then 1 else 2 end', []).desc(),
+        RawSQL('case when status = "active" then 1 else 2 end', []).asc(),  # Same SQL, different direction
+        RawSQL('case when status = "active" then 1 else 2 end', []).desc(),  # Exact duplicate
+    )
+    
+    query = queryset.query
+    compiler = SQLCompiler(query, connection, 'default')
+    order_by_clauses = compiler.get_order_by()
+    
+    print(f"  Number of clauses: {len(order_by_clauses)} (expected: 1)")
+    # Django removes duplicates regardless of direction - only the first occurrence is kept
+    assert len(order_by_clauses) == 1, "Should detect and remove duplicates regardless of direction"
+    print("  ✓ Duplicate detection works correctly")
+
+def test_mixed_line_formats():
+    """Test mixed single-line and multiline SQL."""
+    print("Testing mixed line formats...")
+    
+    queryset = TestModel.objects.all().order_by(
+        RawSQL('case when status = "active" then 1 else 2 end', []).desc(),
+        RawSQL('''
+            case when status = "pending"
+                 then 2 else 3 end''', []).asc(),
+        RawSQL('case when status = "inactive" then 3 else 4 end', []).desc(),
+    )
+    
+    query = queryset.query
+    compiler = SQLCompiler(query, connection, 'default')
+    order_by_clauses = compiler.get_order_by()
+    
+    print(f"  Number of clauses: {len(order_by_clauses)} (expected: 3)")
+    assert len(order_by_clauses) == 3, "Mixed line formats should work correctly"
+    print("  ✓ Mixed line formats work correctly")
+
+def test_various_whitespace():
+    """Test various whitespace patterns."""
+    print("Testing various whitespace patterns...")
+    
+    queryset = TestModel.objects.all().order_by(
+        RawSQL('''
+			case when status = "active"
+				 then 1 else 2 end''', []).desc(),  # Tabs
+        RawSQL('''
+            case when status = "pending"
+                 then 2 else 3 end''', []).asc(),  # Spaces
+        RawSQL('''
+case when status = "inactive"
+then 3 else 4 end''', []).desc(),  # Mixed
+    )
+    
+    query = queryset.query
+    compiler = SQLCompiler(query, connection, 'default')
+    order_by_clauses = compiler.get_order_by()
+    
+    print(f"  Number of clauses: {len(order_by_clauses)} (expected: 3)")
+    assert len(order_by_clauses) == 3, "Various whitespace patterns should work correctly"
+    print("  ✓ Various whitespace patterns work correctly")
+
+def test_empty_lines():
+    """Test SQL with empty lines."""
+    print("Testing SQL with empty lines...")
+    
+    queryset = TestModel.objects.all().order_by(
+        RawSQL('''
+
+            case when status = "active"
+                 then 1 else 2 end''', []).desc(),  # Leading empty lines
+        RawSQL('''
+            case when status = "pending"
+
+                 then 2 else 3 end''', []).asc(),  # Middle empty lines
+    )
+    
+    query = queryset.query
+    compiler = SQLCompiler(query, connection, 'default')
+    order_by_clauses = compiler.get_order_by()
+    
+    print(f"  Number of clauses: {len(order_by_clauses)} (expected: 2)")
+    assert len(order_by_clauses) == 2, "SQL with empty lines should work correctly"
+    print("  ✓ SQL with empty lines works correctly")
+
+if __name__ == '__main__':
+    print("Running edge case tests for multiline RawSQL order_by fix...")
+    print("="*60)
+    
+    try:
+        test_single_line_sql()
+        test_duplicate_detection()
+        test_mixed_line_formats()
+        test_various_whitespace()
+        test_empty_lines()
+        
+        print("\n" + "="*60)
+        print("✓ ALL EDGE CASE TESTS PASSED")
+        sys.exit(0)
+        
+    except Exception as e:
+        print(f"\n✗ TEST FAILED: {e}")
+        import traceback
+        traceback.print_exc()
+        sys.exit(1)
--------
2026-01-06 14:43:36,421 - INFO - Using instance container image: docker.io/swebench/sweb.eval.x86_64.django_1776_django-13315:latest. Please make sure this image exists. Submit an issue on https://github.com/OpenHands/OpenHands if you run into any issues.
2026-01-06 14:43:36,421 - INFO - Resource mapping for princeton-nlp__SWE-bench_Lite-test not found.
2026-01-06 14:43:36,422 - INFO - Logging LLM completions for instance django__django-13315 to ./continuum32/princeton-nlp__SWE-bench_Lite-test/CodeActAgent/GLM-4.6-FP8_maxiter_135/llm_completions/django__django-13315
2026-01-06 14:43:36,422 - INFO - Config file not found: config.toml. Error: [Errno 2] No such file or directory: 'config.toml'
2026-01-06 14:43:36,422 - INFO - Config file not found: [Errno 2] No such file or directory: 'config.toml'. Toml values have not been applied.
