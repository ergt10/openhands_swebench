2026-01-06 14:42:54,842 - INFO - [LLM registry 46bb56b4-2cb3-47d2-860c-35b8118276d7]: Registering service for agent
2026-01-06 14:42:54,885 - INFO - Building image: ghcr.io/openhands/runtime:oh_v1.0.0_l2j9z796dee1ui1g_v008aov5t6vw3gr5
2026-01-06 14:55:20,754 - INFO - Image [ghcr.io/openhands/runtime:oh_v1.0.0_l2j9z796dee1ui1g_v008aov5t6vw3gr5] build finished.
2026-01-06 14:55:20,760 - INFO - Re-tagged image [ghcr.io/openhands/runtime:oh_v1.0.0_l2j9z796dee1ui1g_v008aov5t6vw3gr5] with more generic tag [oh_v1.0.0_l2j9z796dee1ui1g]
2026-01-06 14:55:20,762 - INFO - Image ghcr.io/openhands/runtime with tags [oh_v1.0.0_l2j9z796dee1ui1g_v008aov5t6vw3gr5, oh_v1.0.0_l2j9z796dee1ui1g] built successfully
2026-01-06 14:55:20,802 - INFO - [runtime 879e6625-2311-4c-a006d56f678cd12] Starting runtime with image: ghcr.io/openhands/runtime:oh_v1.0.0_l2j9z796dee1ui1g_v008aov5t6vw3gr5
2026-01-06 14:55:20,890 - INFO - [runtime 879e6625-2311-4c-a006d56f678cd12] Starting server with command: ['/openhands/micromamba/bin/micromamba', 'run', '-n', 'openhands', 'poetry', 'run', 'python', '-u', '-m', 'openhands.runtime.action_execution_server', '39946', '--working-dir', '/workspace', '--plugins', 'agent_skills', 'jupyter', '--username', 'root', '--user-id', '0', '--no-enable-browser']
2026-01-06 14:55:21,488 - INFO - [runtime 879e6625-2311-4c-a006d56f678cd12] Container started: openhands-runtime-879e6625-2311-4c-a006d56f678cd12. VSCode URL: None
2026-01-06 14:55:21,488 - INFO - [runtime 879e6625-2311-4c-a006d56f678cd12] Waiting for client to become ready at http://localhost:39946...
2026-01-06 14:55:53,624 - INFO - [runtime 879e6625-2311-4c-a006d56f678cd12] Runtime is ready.
2026-01-06 14:55:56,745 - INFO - Successfully configured git: name=openhands, email=openhands@all-hands.dev
2026-01-06 14:55:56,746 - INFO - ------------------------------
2026-01-06 14:55:56,746 - INFO - BEGIN Runtime Initialization Fn
2026-01-06 14:55:56,746 - INFO - ------------------------------
2026-01-06 14:55:56,746 - INFO - **CmdRunAction (source=None, is_input=False)**
COMMAND:
echo 'export SWE_INSTANCE_ID=django__django-13028' >> ~/.bashrc && echo 'export PIP_CACHE_DIR=~/.cache/pip' >> ~/.bashrc && echo "alias git='git --no-pager'" >> ~/.bashrc && git config --global core.pager "" && git config --global diff.binary false
2026-01-06 14:55:57,367 - INFO - **CmdOutputObservation (source=None, exit code=0, metadata={
  "exit_code": 0,
  "pid": -1,
  "username": "root",
  "hostname": "fb3dbbafb7b7",
  "working_dir": "/workspace",
  "py_interpreter_path": "/openhands/micromamba/envs/openhands/bin/python",
  "prefix": "",
  "suffix": "\n[The command completed with exit code 0.]"
})**
--BEGIN AGENT OBSERVATION--

[The command completed with exit code 0.]
[Current working directory: /workspace]
[Python interpreter: /openhands/micromamba/envs/openhands/bin/python]
[Command finished with exit code 0]
--END AGENT OBSERVATION--
2026-01-06 14:55:57,367 - INFO - **CmdRunAction (source=None, is_input=False)**
COMMAND:
export USER=$(whoami); echo USER=${USER} 
2026-01-06 14:55:57,987 - INFO - **CmdOutputObservation (source=None, exit code=0, metadata={
  "exit_code": 0,
  "pid": -1,
  "username": "root",
  "hostname": "fb3dbbafb7b7",
  "working_dir": "/workspace",
  "py_interpreter_path": "/openhands/micromamba/envs/openhands/bin/python",
  "prefix": "",
  "suffix": "\n[The command completed with exit code 0.]"
})**
--BEGIN AGENT OBSERVATION--
USER=root
[The command completed with exit code 0.]
[Current working directory: /workspace]
[Python interpreter: /openhands/micromamba/envs/openhands/bin/python]
[Command finished with exit code 0]
--END AGENT OBSERVATION--
2026-01-06 14:55:57,988 - INFO - **CmdRunAction (source=None, is_input=False)**
COMMAND:
mkdir -p /swe_util/eval_data/instances
2026-01-06 14:55:58,608 - INFO - **CmdOutputObservation (source=None, exit code=0, metadata={
  "exit_code": 0,
  "pid": -1,
  "username": "root",
  "hostname": "fb3dbbafb7b7",
  "working_dir": "/workspace",
  "py_interpreter_path": "/openhands/micromamba/envs/openhands/bin/python",
  "prefix": "",
  "suffix": "\n[The command completed with exit code 0.]"
})**
--BEGIN AGENT OBSERVATION--

[The command completed with exit code 0.]
[Current working directory: /workspace]
[Python interpreter: /openhands/micromamba/envs/openhands/bin/python]
[Command finished with exit code 0]
--END AGENT OBSERVATION--
2026-01-06 14:55:58,616 - INFO - **CmdRunAction (source=None, is_input=False)**
COMMAND:
cat ~/.bashrc
2026-01-06 14:55:59,236 - INFO - **CmdOutputObservation (source=None, exit code=0, metadata={
  "exit_code": 0,
  "pid": -1,
  "username": "root",
  "hostname": "fb3dbbafb7b7",
  "working_dir": "/workspace",
  "py_interpreter_path": "/openhands/micromamba/envs/openhands/bin/python",
  "prefix": "",
  "suffix": "\n[The command completed with exit code 0.]"
})**
--BEGIN AGENT OBSERVATION--
source /opt/miniconda3/etc/profile.d/conda.sh && conda activate testbed

. "/openhands/bin/env"
export PATH="/usr/bin:/bin:/usr/sbin:/sbin:/openhands/micromamba/bin:$PATH"
export PLAYWRIGHT_BROWSERS_PATH=/opt/playwright-browsers
eval "$(/openhands/micromamba/bin/micromamba shell hook --shell bash)"
micromamba activate openhands 2>/dev/null || true
export ENABLE_AUTO_LINT=true
export NO_CHANGE_TIMEOUT_SECONDS=30
export OPENHANDS_EVAL_INSTANCE_ID=django__django-13028
export OPENHANDS_EVAL_JOB_ID=2132369144
export OPENHANDS_TIMING_DIR=./continuum32/princeton-nlp__SWE-bench_Lite-test/CodeActAgent/GLM-4.6-FP8_maxiter_135/timing
export SWE_INSTANCE_ID=django__django-13028
export PIP_CACHE_DIR=~/.cache/pip
alias git='git --no-pager'
[The command completed with exit code 0.]
[Current working directory: /workspace]
[Python interpreter: /openhands/micromamba/envs/openhands/bin/python]
[Command finished with exit code 0]
--END AGENT OBSERVATION--
2026-01-06 14:55:59,236 - INFO - **CmdRunAction (source=None, is_input=False)**
COMMAND:
source ~/.bashrc
2026-01-06 14:55:59,859 - INFO - **CmdOutputObservation (source=None, exit code=0, metadata={
  "exit_code": 0,
  "pid": -1,
  "username": "root",
  "hostname": "fb3dbbafb7b7",
  "working_dir": "/workspace",
  "py_interpreter_path": "/openhands/micromamba/envs/openhands/bin/python",
  "prefix": "",
  "suffix": "\n[The command completed with exit code 0.]"
})**
--BEGIN AGENT OBSERVATION--

[The command completed with exit code 0.]
[Current working directory: /workspace]
[Python interpreter: /openhands/micromamba/envs/openhands/bin/python]
[Command finished with exit code 0]
--END AGENT OBSERVATION--
2026-01-06 14:55:59,859 - INFO - **CmdRunAction (source=None, is_input=False)**
COMMAND:
source /swe_util/instance_swe_entry.sh
2026-01-06 14:56:02,491 - INFO - **CmdOutputObservation (source=None, exit code=0, metadata={
  "exit_code": 0,
  "pid": -1,
  "username": "root",
  "hostname": "fb3dbbafb7b7",
  "working_dir": "/workspace",
  "py_interpreter_path": "/opt/miniconda3/envs/testbed/bin/python",
  "prefix": "",
  "suffix": "\n[The command completed with exit code 0.]"
})**
--BEGIN AGENT OBSERVATION--
WORKSPACE_NAME: django__django__3.2
[The command completed with exit code 0.]
[Current working directory: /workspace]
[Python interpreter: /opt/miniconda3/envs/testbed/bin/python]
[Command finished with exit code 0]
--END AGENT OBSERVATION--
2026-01-06 14:56:02,492 - INFO - **CmdRunAction (source=None, is_input=False)**
COMMAND:
cd /workspace/django__django__3.2
2026-01-06 14:56:03,112 - INFO - **CmdOutputObservation (source=None, exit code=0, metadata={
  "exit_code": 0,
  "pid": -1,
  "username": "root",
  "hostname": "fb3dbbafb7b7",
  "working_dir": "/workspace/django__django__3.2",
  "py_interpreter_path": "/opt/miniconda3/envs/testbed/bin/python",
  "prefix": "",
  "suffix": "\n[The command completed with exit code 0.]"
})**
--BEGIN AGENT OBSERVATION--

[The command completed with exit code 0.]
[Current working directory: /workspace/django__django__3.2]
[Python interpreter: /opt/miniconda3/envs/testbed/bin/python]
[Command finished with exit code 0]
--END AGENT OBSERVATION--
2026-01-06 14:56:03,113 - INFO - **CmdRunAction (source=None, is_input=False)**
COMMAND:
git reset --hard
2026-01-06 14:56:04,236 - INFO - **CmdOutputObservation (source=None, exit code=0, metadata={
  "exit_code": 0,
  "pid": -1,
  "username": "root",
  "hostname": "fb3dbbafb7b7",
  "working_dir": "/workspace/django__django__3.2",
  "py_interpreter_path": "/opt/miniconda3/envs/testbed/bin/python",
  "prefix": "",
  "suffix": "\n[The command completed with exit code 0.]"
})**
--BEGIN AGENT OBSERVATION--
HEAD is now at 6f46b94e21 SWE-bench
[The command completed with exit code 0.]
[Current working directory: /workspace/django__django__3.2]
[Python interpreter: /opt/miniconda3/envs/testbed/bin/python]
[Command finished with exit code 0]
--END AGENT OBSERVATION--
2026-01-06 14:56:04,236 - INFO - **CmdRunAction (source=None, is_input=False)**
COMMAND:
for remote_name in $(git remote); do git remote remove "${remote_name}"; done
2026-01-06 14:56:04,860 - INFO - **CmdOutputObservation (source=None, exit code=0, metadata={
  "exit_code": 0,
  "pid": -1,
  "username": "root",
  "hostname": "fb3dbbafb7b7",
  "working_dir": "/workspace/django__django__3.2",
  "py_interpreter_path": "/opt/miniconda3/envs/testbed/bin/python",
  "prefix": "",
  "suffix": "\n[The command completed with exit code 0.]"
})**
--BEGIN AGENT OBSERVATION--

[The command completed with exit code 0.]
[Current working directory: /workspace/django__django__3.2]
[Python interpreter: /opt/miniconda3/envs/testbed/bin/python]
[Command finished with exit code 0]
--END AGENT OBSERVATION--
2026-01-06 14:56:04,861 - INFO - **CmdRunAction (source=None, is_input=False)**
COMMAND:
which python
2026-01-06 14:56:05,483 - INFO - **CmdOutputObservation (source=None, exit code=0, metadata={
  "exit_code": 0,
  "pid": -1,
  "username": "root",
  "hostname": "fb3dbbafb7b7",
  "working_dir": "/workspace/django__django__3.2",
  "py_interpreter_path": "/opt/miniconda3/envs/testbed/bin/python",
  "prefix": "",
  "suffix": "\n[The command completed with exit code 0.]"
})**
--BEGIN AGENT OBSERVATION--
/opt/miniconda3/envs/testbed/bin/python
[The command completed with exit code 0.]
[Current working directory: /workspace/django__django__3.2]
[Python interpreter: /opt/miniconda3/envs/testbed/bin/python]
[Command finished with exit code 0]
--END AGENT OBSERVATION--
2026-01-06 14:56:05,484 - INFO - ------------------------------
2026-01-06 14:56:05,484 - INFO - END Runtime Initialization Fn
2026-01-06 14:56:05,484 - INFO - ------------------------------
2026-01-06 14:56:05,487 - INFO - [LLM registry 9a1d709b-6294-4a78-8da2-572a1b58c67e]: Registering service for agent
2026-01-06 14:56:05,506 - INFO - [runtime 879e6625-2311-4c-a006d56f678cd12] Selected repo: None, loading microagents from /workspace/.openhands/microagents (inside runtime)
2026-01-06 14:56:05,509 - INFO - [runtime 879e6625-2311-4c-a006d56f678cd12] Attempting to list files in repository microagents directory: /workspace/.openhands/microagents
2026-01-06 14:56:05,512 - INFO - Loading user workspace microagents: []
2026-01-06 14:56:05,513 - INFO - AgentController 879e6625-2311-4c-a006d56f678cd12 - created new state. start_id: 0
2026-01-06 14:56:05,521 - INFO - [Agent Controller 879e6625-2311-4c-a006d56f678cd12] Setting agent(CodeActAgent) state from AgentState.LOADING to AgentState.RUNNING
2026-01-06 14:56:05,523 - INFO - Saved conversation stats
2026-01-06 15:06:32,886 - INFO - [Agent Controller 879e6625-2311-4c-a006d56f678cd12] Setting agent(CodeActAgent) state from AgentState.RUNNING to AgentState.FINISHED
2026-01-06 15:06:32,888 - INFO - Saved conversation stats
2026-01-06 15:06:33,159 - INFO - ------------------------------
2026-01-06 15:06:33,159 - INFO - BEGIN Runtime Completion Fn
2026-01-06 15:06:33,160 - INFO - ------------------------------
2026-01-06 15:06:33,160 - INFO - **CmdRunAction (source=None, is_input=False)**
COMMAND:
cd /workspace/django__django__3.2
2026-01-06 15:06:33,778 - INFO - **CmdOutputObservation (source=None, exit code=0, metadata={
  "exit_code": 0,
  "pid": -1,
  "username": "root",
  "hostname": "fb3dbbafb7b7",
  "working_dir": "/workspace/django__django__3.2",
  "py_interpreter_path": "/opt/miniconda3/envs/testbed/bin/python",
  "prefix": "",
  "suffix": "\n[The command completed with exit code 0.]"
})**
--BEGIN AGENT OBSERVATION--

[The command completed with exit code 0.]
[Current working directory: /workspace/django__django__3.2]
[Python interpreter: /opt/miniconda3/envs/testbed/bin/python]
[Command finished with exit code 0]
--END AGENT OBSERVATION--
2026-01-06 15:06:33,778 - INFO - **CmdRunAction (source=None, is_input=False)**
COMMAND:
git config --global core.pager ""
2026-01-06 15:06:34,396 - INFO - **CmdOutputObservation (source=None, exit code=0, metadata={
  "exit_code": 0,
  "pid": -1,
  "username": "root",
  "hostname": "fb3dbbafb7b7",
  "working_dir": "/workspace/django__django__3.2",
  "py_interpreter_path": "/opt/miniconda3/envs/testbed/bin/python",
  "prefix": "",
  "suffix": "\n[The command completed with exit code 0.]"
})**
--BEGIN AGENT OBSERVATION--

[The command completed with exit code 0.]
[Current working directory: /workspace/django__django__3.2]
[Python interpreter: /opt/miniconda3/envs/testbed/bin/python]
[Command finished with exit code 0]
--END AGENT OBSERVATION--
2026-01-06 15:06:34,396 - INFO - **CmdRunAction (source=None, is_input=False)**
COMMAND:
find . -type d -name .git -not -path "./.git"
2026-01-06 15:06:35,015 - INFO - **CmdOutputObservation (source=None, exit code=0, metadata={
  "exit_code": 0,
  "pid": -1,
  "username": "root",
  "hostname": "fb3dbbafb7b7",
  "working_dir": "/workspace/django__django__3.2",
  "py_interpreter_path": "/opt/miniconda3/envs/testbed/bin/python",
  "prefix": "",
  "suffix": "\n[The command completed with exit code 0.]"
})**
--BEGIN AGENT OBSERVATION--

[The command completed with exit code 0.]
[Current working directory: /workspace/django__django__3.2]
[Python interpreter: /opt/miniconda3/envs/testbed/bin/python]
[Command finished with exit code 0]
--END AGENT OBSERVATION--
2026-01-06 15:06:35,015 - INFO - **CmdRunAction (source=None, is_input=False)**
COMMAND:
git add -A
2026-01-06 15:06:35,634 - INFO - **CmdOutputObservation (source=None, exit code=0, metadata={
  "exit_code": 0,
  "pid": -1,
  "username": "root",
  "hostname": "fb3dbbafb7b7",
  "working_dir": "/workspace/django__django__3.2",
  "py_interpreter_path": "/opt/miniconda3/envs/testbed/bin/python",
  "prefix": "",
  "suffix": "\n[The command completed with exit code 0.]"
})**
--BEGIN AGENT OBSERVATION--

[The command completed with exit code 0.]
[Current working directory: /workspace/django__django__3.2]
[Python interpreter: /opt/miniconda3/envs/testbed/bin/python]
[Command finished with exit code 0]
--END AGENT OBSERVATION--
2026-01-06 15:06:35,634 - INFO - **CmdRunAction (source=None, is_input=False)**
COMMAND:
for file in $(git status --porcelain | grep -E "^(M| M|\?\?|A| A)" | cut -c4-); do
        if [ -f "$file" ] && (file "$file" | grep -q "executable" || git check-attr binary "$file" | grep -q "binary: set"); then
            git rm -f "$file" 2>/dev/null || rm -f "$file"
            echo "Removed: $file"
        fi
    done
2026-01-06 15:06:36,258 - INFO - **CmdOutputObservation (source=None, exit code=0, metadata={
  "exit_code": 0,
  "pid": -1,
  "username": "root",
  "hostname": "fb3dbbafb7b7",
  "working_dir": "/workspace/django__django__3.2",
  "py_interpreter_path": "/opt/miniconda3/envs/testbed/bin/python",
  "prefix": "",
  "suffix": "\n[The command completed with exit code 0.]"
})**
--BEGIN AGENT OBSERVATION--
bash: file: command not found
bash: file: command not found
bash: file: command not found
bash: file: command not found
bash: file: command not found
bash: file: command not found
[The command completed with exit code 0.]
[Current working directory: /workspace/django__django__3.2]
[Python interpreter: /opt/miniconda3/envs/testbed/bin/python]
[Command finished with exit code 0]
--END AGENT OBSERVATION--
2026-01-06 15:06:36,259 - INFO - **CmdRunAction (source=None, is_input=False)**
COMMAND:
git diff --no-color --cached 78ad4b4b0201003792bfdbf1a7781cbc9ee03539 > patch.diff
2026-01-06 15:06:36,887 - INFO - **CmdOutputObservation (source=None, exit code=0, metadata={
  "exit_code": 0,
  "pid": -1,
  "username": "root",
  "hostname": "fb3dbbafb7b7",
  "working_dir": "/workspace/django__django__3.2",
  "py_interpreter_path": "/opt/miniconda3/envs/testbed/bin/python",
  "prefix": "",
  "suffix": "\n[The command completed with exit code 0.]"
})**
--BEGIN AGENT OBSERVATION--

[The command completed with exit code 0.]
[Current working directory: /workspace/django__django__3.2]
[Python interpreter: /opt/miniconda3/envs/testbed/bin/python]
[Command finished with exit code 0]
--END AGENT OBSERVATION--
2026-01-06 15:06:36,887 - INFO - FileReadAction(path='patch.diff', start=0, end=-1, thought='', action=<ActionType.READ: 'read'>, security_risk=<ActionSecurityRisk.UNKNOWN: -1>, impl_source=<FileReadSource.DEFAULT: 'default'>, view_range=None)
2026-01-06 15:06:36,891 - INFO - [Read from /workspace/django__django__3.2/patch.diff is successful.]
diff --git a/comprehensive_test.py b/comprehensive_test.py
new file mode 100644
index 0000000000..89f853a09a
--- /dev/null
+++ b/comprehensive_test.py
@@ -0,0 +1,194 @@
+#!/usr/bin/env python
+"""
+Comprehensive test for the filterable field fix.
+Tests various scenarios to ensure the fix works correctly.
+"""
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        SECRET_KEY='test-secret-key',
+    )
+
+django.setup()
+
+from django.db import models
+from django.db.utils import NotSupportedError
+from django.db.models.expressions import BaseExpression
+
+
+class ProductMetaDataType(models.Model):
+    label = models.CharField(max_length=255, unique=True, blank=False, null=False)
+    filterable = models.BooleanField(default=False)
+    
+    class Meta:
+        app_label = "test_app"
+
+
+class ProductMetaData(models.Model):
+    product = models.CharField(max_length=255, null=False, blank=False)
+    value = models.TextField(null=False, blank=False)
+    metadata_type = models.ForeignKey(
+        ProductMetaDataType, null=False, blank=False, on_delete=models.CASCADE
+    )
+    
+    class Meta:
+        app_label = "test_app"
+
+
+class TestExpression(BaseExpression):
+    """A test expression with filterable=False to ensure the check still works for expressions."""
+    filterable = False
+
+
+def test_filterable_field_false():
+    """Test that filterable=False on model field doesn't cause error."""
+    print("Test 1: Model with filterable=False field...")
+    
+    from django.db import connection
+    with connection.schema_editor() as schema_editor:
+        schema_editor.create_model(ProductMetaDataType)
+        schema_editor.create_model(ProductMetaData)
+    
+    metadata_type = ProductMetaDataType.objects.create(
+        label="Brand",
+        filterable=False
+    )
+    
+    ProductMetaData.objects.create(
+        product="Test Product",
+        value="Dark Vador",
+        metadata_type=metadata_type
+    )
+    
+    try:
+        results = ProductMetaData.objects.filter(
+            value="Dark Vador", 
+            metadata_type=metadata_type
+        )
+        assert results.count() == 1
+        print("  ‚úì SUCCESS: filterable=False field works correctly")
+        return True
+    except Exception as e:
+        print(f"  ‚úó FAILED: {e}")
+        return False
+
+
+def test_filterable_field_true():
+    """Test that filterable=True on model field works."""
+    print("Test 2: Model with filterable=True field...")
+    
+    metadata_type = ProductMetaDataType.objects.create(
+        label="Category",
+        filterable=True
+    )
+    
+    ProductMetaData.objects.create(
+        product="Test Product 2",
+        value="Electronics",
+        metadata_type=metadata_type
+    )
+    
+    try:
+        results = ProductMetaData.objects.filter(
+            value="Electronics", 
+            metadata_type=metadata_type
+        )
+        assert results.count() == 1
+        print("  ‚úì SUCCESS: filterable=True field works correctly")
+        return True
+    except Exception as e:
+        print(f"  ‚úó FAILED: {e}")
+        return False
+
+
+def test_expression_filterable_false():
+    """Test that expressions with filterable=False still raise NotSupportedError."""
+    print("Test 3: Expression with filterable=False...")
+    
+    try:
+        from django.db.models.sql.query import Query
+        query = Query(ProductMetaData)
+        expr = TestExpression()
+        query.check_filterable(expr)
+        print("  ‚úó FAILED: Should have raised NotSupportedError")
+        return False
+    except NotSupportedError as e:
+        if "TestExpression is disallowed in the filter clause" in str(e):
+            print("  ‚úì SUCCESS: Expression filterable check still works")
+            return True
+        else:
+            print(f"  ‚úó FAILED: Wrong error message: {e}")
+            return False
+    except Exception as e:
+        print(f"  ‚úó FAILED: Unexpected error: {e}")
+        return False
+
+
+def test_regular_model_without_filterable():
+    """Test that regular models without filterable field work."""
+    print("Test 4: Regular model without filterable field...")
+    
+    class SimpleModel(models.Model):
+        name = models.CharField(max_length=100)
+        
+        class Meta:
+            app_label = "test_app"
+    
+    try:
+        from django.db import connection
+        with connection.schema_editor() as schema_editor:
+            schema_editor.create_model(SimpleModel)
+        
+        obj = SimpleModel.objects.create(name="Test")
+        results = SimpleModel.objects.filter(name="Test")
+        assert results.count() == 1
+        print("  ‚úì SUCCESS: Regular model works correctly")
+        return True
+    except Exception as e:
+        print(f"  ‚úó FAILED: {e}")
+        return False
+
+
+def run_all_tests():
+    """Run all tests."""
+    print("Running comprehensive tests for filterable field fix...\n")
+    
+    tests = [
+        test_filterable_field_false,
+        test_filterable_field_true,
+        test_expression_filterable_false,
+        test_regular_model_without_filterable,
+    ]
+    
+    passed = 0
+    total = len(tests)
+    
+    for test in tests:
+        if test():
+            passed += 1
+        print()
+    
+    print(f"Results: {passed}/{total} tests passed")
+    return passed == total
+
+
+if __name__ == "__main__":
+    success = run_all_tests()
+    sys.exit(0 if success else 1)
diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py
index ce18098fd2..eb6210d4c7 100644
--- a/django/db/models/sql/query.py
+++ b/django/db/models/sql/query.py
@@ -1124,7 +1124,9 @@ class Query(BaseExpression):
 
     def check_filterable(self, expression):
         """Raise an error if expression cannot be used in a WHERE clause."""
-        if not getattr(expression, 'filterable', True):
+        # Only check filterable attribute on Django expressions, not model instances
+        from django.db.models.expressions import BaseExpression
+        if isinstance(expression, BaseExpression) and not getattr(expression, 'filterable', True):
             raise NotSupportedError(
                 expression.__class__.__name__ + ' is disallowed in the filter '
                 'clause.'
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..eae29b1dd5
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,107 @@
+#!/usr/bin/env python
+"""
+Reproduction script for the filterable field issue.
+This script reproduces the NotSupportedError when a model has a field named 'filterable'.
+"""
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        SECRET_KEY='test-secret-key',
+    )
+
+django.setup()
+
+from django.db import models
+from django.db.utils import NotSupportedError
+
+
+class ProductMetaDataType(models.Model):
+    label = models.CharField(max_length=255, unique=True, blank=False, null=False)
+    filterable = models.BooleanField(default=False)  # This field causes the issue
+    
+    class Meta:
+        app_label = "test_app"
+
+
+class ProductMetaData(models.Model):
+    product = models.CharField(max_length=255, null=False, blank=False)
+    value = models.TextField(null=False, blank=False)
+    metadata_type = models.ForeignKey(
+        ProductMetaDataType, null=False, blank=False, on_delete=models.CASCADE
+    )
+    
+    class Meta:
+        app_label = "test_app"
+
+
+def test_issue():
+    """Test that reproduces the NotSupportedError issue."""
+    print("Creating tables...")
+    
+    # Create tables
+    from django.db import connection
+    with connection.schema_editor() as schema_editor:
+        schema_editor.create_model(ProductMetaDataType)
+        schema_editor.create_model(ProductMetaData)
+    
+    print("Creating test data...")
+    
+    # Create a metadata type with filterable=False
+    metadata_type = ProductMetaDataType.objects.create(
+        label="Brand",
+        filterable=False  # This should trigger the error
+    )
+    
+    # Create a product metadata record
+    product_meta = ProductMetaData.objects.create(
+        product="Test Product",
+        value="Dark Vador",
+        metadata_type=metadata_type
+    )
+    
+    print("Attempting to filter...")
+    
+    try:
+        # This should raise NotSupportedError due to the filterable field
+        results = ProductMetaData.objects.filter(
+            value="Dark Vador", 
+            metadata_type=metadata_type
+        )
+        print(f"SUCCESS: Found {results.count()} results")
+        for result in results:
+            print(f"  - {result.product}: {result.value}")
+    except NotSupportedError as e:
+        print(f"ERROR: {e}")
+        return False
+    except Exception as e:
+        print(f"UNEXPECTED ERROR: {e}")
+        return False
+    
+    return True
+
+
+if __name__ == "__main__":
+    print("Reproducing the filterable field issue...")
+    success = test_issue()
+    if success:
+        print("Test passed - no error occurred")
+    else:
+        print("Test failed - error reproduced")
+    sys.exit(0 if success else 1)
diff --git a/test_legitimate_expressions.py b/test_legitimate_expressions.py
new file mode 100644
index 0000000000..48ee661ba4
--- /dev/null
+++ b/test_legitimate_expressions.py
@@ -0,0 +1,148 @@
+#!/usr/bin/env python
+"""
+Test script to verify that legitimate expressions with filterable=False still work correctly.
+"""
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        SECRET_KEY='test-secret-key',
+    )
+
+django.setup()
+
+from django.db import models
+from django.db.utils import NotSupportedError
+from django.db.models.sql.query import Query
+from django.db.models.expressions import BaseExpression, Window
+
+
+class TestModel(models.Model):
+    name = models.CharField(max_length=100)
+    
+    class Meta:
+        app_label = "test_app"
+
+
+def test_window_expression():
+    """Test that Window expressions (which have filterable=False) still raise NotSupportedError."""
+    print("Testing Window expression with filterable=False...")
+    
+    from django.db import connection
+    with connection.schema_editor() as schema_editor:
+        schema_editor.create_model(TestModel)
+    
+    # Create a Window expression (these have filterable=False by design)
+    from django.db.models import F, Avg
+    window_expr = Window(Avg('name'))
+    
+    query = Query(TestModel)
+    
+    try:
+        query.check_filterable(window_expr)
+        print("‚úó FAILED: Window expression should have raised NotSupportedError")
+        return False
+    except NotSupportedError as e:
+        if "Window is disallowed in the filter clause" in str(e):
+            print("‚úì SUCCESS: Window expression correctly raised NotSupportedError")
+            return True
+        else:
+            print(f"‚úó FAILED: Wrong error message: {e}")
+            return False
+    except Exception as e:
+        print(f"‚úó FAILED: Unexpected error: {e}")
+        return False
+
+
+def test_custom_expression():
+    """Test a custom expression with filterable=False."""
+    print("Testing custom expression with filterable=False...")
+    
+    class CustomExpression(BaseExpression):
+        filterable = False
+    
+    expr = CustomExpression()
+    query = Query(TestModel)
+    
+    try:
+        query.check_filterable(expr)
+        print("‚úó FAILED: Custom expression should have raised NotSupportedError")
+        return False
+    except NotSupportedError as e:
+        if "CustomExpression is disallowed in the filter clause" in str(e):
+            print("‚úì SUCCESS: Custom expression correctly raised NotSupportedError")
+            return True
+        else:
+            print(f"‚úó FAILED: Wrong error message: {e}")
+            return False
+    except Exception as e:
+        print(f"‚úó FAILED: Unexpected error: {e}")
+        return False
+
+
+def test_expression_with_filterable_true():
+    """Test that expressions with filterable=True work correctly."""
+    print("Testing expression with filterable=True...")
+    
+    class CustomExpression(BaseExpression):
+        filterable = True  # Explicitly set to True
+    
+    expr = CustomExpression()
+    query = Query(TestModel)
+    
+    try:
+        query.check_filterable(expr)
+        print("‚úì SUCCESS: Expression with filterable=True passed check")
+        return True
+    except Exception as e:
+        print(f"‚úó FAILED: {e}")
+        return False
+
+
+def run_tests():
+    """Run all tests."""
+    print("Testing legitimate expression filterable behavior...\n")
+    
+    tests = [
+        test_window_expression,
+        test_custom_expression,
+        test_expression_with_filterable_true,
+    ]
+    
+    passed = 0
+    total = len(tests)
+    
+    for test in tests:
+        if test():
+            passed += 1
+        print()
+    
+    print(f"Results: {passed}/{total} tests passed")
+    return passed == total
+
+
+if __name__ == "__main__":
+    success = run_tests()
+    
+    if success:
+        print("üéâ All legitimate expression tests passed!")
+    else:
+        print("‚ùå Some legitimate expression tests failed.")
+    
+    sys.exit(0 if success else 1)
diff --git a/test_original_issue.py b/test_original_issue.py
new file mode 100644
index 0000000000..a9cb7549e1
--- /dev/null
+++ b/test_original_issue.py
@@ -0,0 +1,111 @@
+#!/usr/bin/env python
+"""
+Test script that exactly reproduces the original issue scenario.
+"""
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        SECRET_KEY='test-secret-key',
+    )
+
+django.setup()
+
+from django.db import models
+from django.db.utils import NotSupportedError
+from django.utils import timezone
+
+
+# Exact models from the issue description
+class ProductMetaDataType(models.Model):
+    label = models.CharField(max_length=255, unique=True, blank=False, null=False)
+    filterable = models.BooleanField(default=False)
+    
+    class Meta:
+        app_label = "adminpricing"
+    
+    def __str__(self):
+        return self.label
+
+
+class ProductMetaData(models.Model):
+    id = models.BigAutoField(primary_key=True)
+    product = models.CharField(max_length=255, null=False, blank=False)  # Simplified from ForeignKey
+    value = models.TextField(null=False, blank=False)
+    marketplace = models.CharField(max_length=255, null=False, blank=False)  # Simplified from ForeignKey
+    date_created = models.DateTimeField(null=True, default=timezone.now)
+    metadata_type = models.ForeignKey(
+        ProductMetaDataType, null=False, blank=False, on_delete=models.CASCADE
+    )
+    
+    class Meta:
+        app_label = "adminpricing"
+
+
+def test_original_issue():
+    """Test the exact scenario from the issue description."""
+    print("Testing the exact original issue scenario...")
+    
+    # Create tables
+    from django.db import connection
+    with connection.schema_editor() as schema_editor:
+        schema_editor.create_model(ProductMetaDataType)
+        schema_editor.create_model(ProductMetaData)
+    
+    # Create the metadata type with filterable=False (this was causing the issue)
+    brand_metadata = ProductMetaDataType.objects.create(
+        label="Brand",
+        filterable=False
+    )
+    
+    # Create a product metadata record
+    ProductMetaData.objects.create(
+        product="Test Product",
+        value="Dark Vador",
+        marketplace="Test Marketplace",
+        metadata_type=brand_metadata
+    )
+    
+    # This is the exact line that was failing in the issue
+    try:
+        print("Executing: ProductMetaData.objects.filter(value='Dark Vador', metadata_type=brand_metadata)")
+        for p in ProductMetaData.objects.filter(value="Dark Vador", metadata_type=brand_metadata):
+            print(f"  Found: {p.product} - {p.value}")
+        
+        print("‚úì SUCCESS: Original issue is fixed!")
+        return True
+        
+    except NotSupportedError as e:
+        print(f"‚úó FAILED: {e}")
+        return False
+    except Exception as e:
+        print(f"‚úó UNEXPECTED ERROR: {e}")
+        return False
+
+
+if __name__ == "__main__":
+    print("Testing the original issue scenario...\n")
+    success = test_original_issue()
+    
+    if success:
+        print("\nüéâ The original issue has been successfully resolved!")
+    else:
+        print("\n‚ùå The original issue still exists.")
+    
+    sys.exit(0 if success else 1)
diff --git a/test_query_fix.py b/test_query_fix.py
new file mode 100644
index 0000000000..d79d11e33f
--- /dev/null
+++ b/test_query_fix.py
@@ -0,0 +1,158 @@
+#!/usr/bin/env python
+"""
+Test script to verify the query fix works correctly.
+"""
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        SECRET_KEY='test-secret-key',
+    )
+
+django.setup()
+
+from django.db import models
+from django.db.utils import NotSupportedError
+from django.db.models.sql.query import Query
+from django.db.models.expressions import BaseExpression
+
+
+class TestModel(models.Model):
+    name = models.CharField(max_length=100)
+    filterable = models.BooleanField(default=False)
+    
+    class Meta:
+        app_label = "test_app"
+
+
+class TestExpression(BaseExpression):
+    """Test expression with filterable=False"""
+    filterable = False
+
+
+def test_query_filterable_check():
+    """Test that the check_filterable method works correctly."""
+    print("Testing check_filterable method...")
+    
+    # Test 1: Model instance should not raise error
+    print("  Test 1: Model instance with filterable=False")
+    query = Query(TestModel)
+    model_instance = TestModel(name="test", filterable=False)
+    
+    try:
+        query.check_filterable(model_instance)
+        print("    ‚úì SUCCESS: Model instance passed filterable check")
+    except Exception as e:
+        print(f"    ‚úó FAILED: {e}")
+        return False
+    
+    # Test 2: Expression with filterable=False should raise error
+    print("  Test 2: Expression with filterable=False")
+    expr = TestExpression()
+    
+    try:
+        query.check_filterable(expr)
+        print("    ‚úó FAILED: Should have raised NotSupportedError")
+        return False
+    except NotSupportedError as e:
+        if "TestExpression is disallowed in the filter clause" in str(e):
+            print("    ‚úì SUCCESS: Expression correctly raised NotSupportedError")
+        else:
+            print(f"    ‚úó FAILED: Wrong error message: {e}")
+            return False
+    except Exception as e:
+        print(f"    ‚úó FAILED: Unexpected error: {e}")
+        return False
+    
+    # Test 3: Regular object should not raise error
+    print("  Test 3: Regular object")
+    class RegularObject:
+        filterable = False
+    
+    regular_obj = RegularObject()
+    
+    try:
+        query.check_filterable(regular_obj)
+        print("    ‚úì SUCCESS: Regular object passed filterable check")
+    except Exception as e:
+        print(f"    ‚úó FAILED: {e}")
+        return False
+    
+    return True
+
+
+def test_actual_query():
+    """Test actual database query with filterable field."""
+    print("Testing actual database query...")
+    
+    from django.db import connection
+    with connection.schema_editor() as schema_editor:
+        schema_editor.create_model(TestModel)
+    
+    # Create test data
+    obj1 = TestModel.objects.create(name="test1", filterable=False)
+    obj2 = TestModel.objects.create(name="test2", filterable=True)
+    
+    # Test filtering with filterable=False object
+    try:
+        results = TestModel.objects.filter(name="test1")
+        assert results.count() == 1
+        assert results.first().name == "test1"
+        print("  ‚úì SUCCESS: Query with filterable=False object works")
+    except Exception as e:
+        print(f"    ‚úó FAILED: {e}")
+        return False
+    
+    # Test filtering with filterable=True object
+    try:
+        results = TestModel.objects.filter(name="test2")
+        assert results.count() == 1
+        assert results.first().name == "test2"
+        print("  ‚úì SUCCESS: Query with filterable=True object works")
+    except Exception as e:
+        print(f"    ‚úó FAILED: {e}")
+        return False
+    
+    return True
+
+
+def run_tests():
+    """Run all tests."""
+    print("Running query fix tests...\n")
+    
+    tests = [
+        test_query_filterable_check,
+        test_actual_query,
+    ]
+    
+    passed = 0
+    total = len(tests)
+    
+    for test in tests:
+        if test():
+            passed += 1
+        print()
+    
+    print(f"Results: {passed}/{total} tests passed")
+    return passed == total
+
+
+if __name__ == "__main__":
+    success = run_tests()
+    sys.exit(0 if success else 1)

2026-01-06 15:06:36,892 - INFO - ------------------------------
2026-01-06 15:06:36,892 - INFO - END Runtime Completion Fn
2026-01-06 15:06:36,892 - INFO - ------------------------------
2026-01-06 15:06:36,892 - INFO - Got git diff for instance django__django-13028:
--------
diff --git a/comprehensive_test.py b/comprehensive_test.py
new file mode 100644
index 0000000000..89f853a09a
--- /dev/null
+++ b/comprehensive_test.py
@@ -0,0 +1,194 @@
+#!/usr/bin/env python
+"""
+Comprehensive test for the filterable field fix.
+Tests various scenarios to ensure the fix works correctly.
+"""
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        SECRET_KEY='test-secret-key',
+    )
+
+django.setup()
+
+from django.db import models
+from django.db.utils import NotSupportedError
+from django.db.models.expressions import BaseExpression
+
+
+class ProductMetaDataType(models.Model):
+    label = models.CharField(max_length=255, unique=True, blank=False, null=False)
+    filterable = models.BooleanField(default=False)
+    
+    class Meta:
+        app_label = "test_app"
+
+
+class ProductMetaData(models.Model):
+    product = models.CharField(max_length=255, null=False, blank=False)
+    value = models.TextField(null=False, blank=False)
+    metadata_type = models.ForeignKey(
+        ProductMetaDataType, null=False, blank=False, on_delete=models.CASCADE
+    )
+    
+    class Meta:
+        app_label = "test_app"
+
+
+class TestExpression(BaseExpression):
+    """A test expression with filterable=False to ensure the check still works for expressions."""
+    filterable = False
+
+
+def test_filterable_field_false():
+    """Test that filterable=False on model field doesn't cause error."""
+    print("Test 1: Model with filterable=False field...")
+    
+    from django.db import connection
+    with connection.schema_editor() as schema_editor:
+        schema_editor.create_model(ProductMetaDataType)
+        schema_editor.create_model(ProductMetaData)
+    
+    metadata_type = ProductMetaDataType.objects.create(
+        label="Brand",
+        filterable=False
+    )
+    
+    ProductMetaData.objects.create(
+        product="Test Product",
+        value="Dark Vador",
+        metadata_type=metadata_type
+    )
+    
+    try:
+        results = ProductMetaData.objects.filter(
+            value="Dark Vador", 
+            metadata_type=metadata_type
+        )
+        assert results.count() == 1
+        print("  ‚úì SUCCESS: filterable=False field works correctly")
+        return True
+    except Exception as e:
+        print(f"  ‚úó FAILED: {e}")
+        return False
+
+
+def test_filterable_field_true():
+    """Test that filterable=True on model field works."""
+    print("Test 2: Model with filterable=True field...")
+    
+    metadata_type = ProductMetaDataType.objects.create(
+        label="Category",
+        filterable=True
+    )
+    
+    ProductMetaData.objects.create(
+        product="Test Product 2",
+        value="Electronics",
+        metadata_type=metadata_type
+    )
+    
+    try:
+        results = ProductMetaData.objects.filter(
+            value="Electronics", 
+            metadata_type=metadata_type
+        )
+        assert results.count() == 1
+        print("  ‚úì SUCCESS: filterable=True field works correctly")
+        return True
+    except Exception as e:
+        print(f"  ‚úó FAILED: {e}")
+        return False
+
+
+def test_expression_filterable_false():
+    """Test that expressions with filterable=False still raise NotSupportedError."""
+    print("Test 3: Expression with filterable=False...")
+    
+    try:
+        from django.db.models.sql.query import Query
+        query = Query(ProductMetaData)
+        expr = TestExpression()
+        query.check_filterable(expr)
+        print("  ‚úó FAILED: Should have raised NotSupportedError")
+        return False
+    except NotSupportedError as e:
+        if "TestExpression is disallowed in the filter clause" in str(e):
+            print("  ‚úì SUCCESS: Expression filterable check still works")
+            return True
+        else:
+            print(f"  ‚úó FAILED: Wrong error message: {e}")
+            return False
+    except Exception as e:
+        print(f"  ‚úó FAILED: Unexpected error: {e}")
+        return False
+
+
+def test_regular_model_without_filterable():
+    """Test that regular models without filterable field work."""
+    print("Test 4: Regular model without filterable field...")
+    
+    class SimpleModel(models.Model):
+        name = models.CharField(max_length=100)
+        
+        class Meta:
+            app_label = "test_app"
+    
+    try:
+        from django.db import connection
+        with connection.schema_editor() as schema_editor:
+            schema_editor.create_model(SimpleModel)
+        
+        obj = SimpleModel.objects.create(name="Test")
+        results = SimpleModel.objects.filter(name="Test")
+        assert results.count() == 1
+        print("  ‚úì SUCCESS: Regular model works correctly")
+        return True
+    except Exception as e:
+        print(f"  ‚úó FAILED: {e}")
+        return False
+
+
+def run_all_tests():
+    """Run all tests."""
+    print("Running comprehensive tests for filterable field fix...\n")
+    
+    tests = [
+        test_filterable_field_false,
+        test_filterable_field_true,
+        test_expression_filterable_false,
+        test_regular_model_without_filterable,
+    ]
+    
+    passed = 0
+    total = len(tests)
+    
+    for test in tests:
+        if test():
+            passed += 1
+        print()
+    
+    print(f"Results: {passed}/{total} tests passed")
+    return passed == total
+
+
+if __name__ == "__main__":
+    success = run_all_tests()
+    sys.exit(0 if success else 1)
diff --git a/django/db/models/sql/query.py b/django/db/models/sql/query.py
index ce18098fd2..eb6210d4c7 100644
--- a/django/db/models/sql/query.py
+++ b/django/db/models/sql/query.py
@@ -1124,7 +1124,9 @@ class Query(BaseExpression):
 
     def check_filterable(self, expression):
         """Raise an error if expression cannot be used in a WHERE clause."""
-        if not getattr(expression, 'filterable', True):
+        # Only check filterable attribute on Django expressions, not model instances
+        from django.db.models.expressions import BaseExpression
+        if isinstance(expression, BaseExpression) and not getattr(expression, 'filterable', True):
             raise NotSupportedError(
                 expression.__class__.__name__ + ' is disallowed in the filter '
                 'clause.'
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 0000000000..eae29b1dd5
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,107 @@
+#!/usr/bin/env python
+"""
+Reproduction script for the filterable field issue.
+This script reproduces the NotSupportedError when a model has a field named 'filterable'.
+"""
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        SECRET_KEY='test-secret-key',
+    )
+
+django.setup()
+
+from django.db import models
+from django.db.utils import NotSupportedError
+
+
+class ProductMetaDataType(models.Model):
+    label = models.CharField(max_length=255, unique=True, blank=False, null=False)
+    filterable = models.BooleanField(default=False)  # This field causes the issue
+    
+    class Meta:
+        app_label = "test_app"
+
+
+class ProductMetaData(models.Model):
+    product = models.CharField(max_length=255, null=False, blank=False)
+    value = models.TextField(null=False, blank=False)
+    metadata_type = models.ForeignKey(
+        ProductMetaDataType, null=False, blank=False, on_delete=models.CASCADE
+    )
+    
+    class Meta:
+        app_label = "test_app"
+
+
+def test_issue():
+    """Test that reproduces the NotSupportedError issue."""
+    print("Creating tables...")
+    
+    # Create tables
+    from django.db import connection
+    with connection.schema_editor() as schema_editor:
+        schema_editor.create_model(ProductMetaDataType)
+        schema_editor.create_model(ProductMetaData)
+    
+    print("Creating test data...")
+    
+    # Create a metadata type with filterable=False
+    metadata_type = ProductMetaDataType.objects.create(
+        label="Brand",
+        filterable=False  # This should trigger the error
+    )
+    
+    # Create a product metadata record
+    product_meta = ProductMetaData.objects.create(
+        product="Test Product",
+        value="Dark Vador",
+        metadata_type=metadata_type
+    )
+    
+    print("Attempting to filter...")
+    
+    try:
+        # This should raise NotSupportedError due to the filterable field
+        results = ProductMetaData.objects.filter(
+            value="Dark Vador", 
+            metadata_type=metadata_type
+        )
+        print(f"SUCCESS: Found {results.count()} results")
+        for result in results:
+            print(f"  - {result.product}: {result.value}")
+    except NotSupportedError as e:
+        print(f"ERROR: {e}")
+        return False
+    except Exception as e:
+        print(f"UNEXPECTED ERROR: {e}")
+        return False
+    
+    return True
+
+
+if __name__ == "__main__":
+    print("Reproducing the filterable field issue...")
+    success = test_issue()
+    if success:
+        print("Test passed - no error occurred")
+    else:
+        print("Test failed - error reproduced")
+    sys.exit(0 if success else 1)
diff --git a/test_legitimate_expressions.py b/test_legitimate_expressions.py
new file mode 100644
index 0000000000..48ee661ba4
--- /dev/null
+++ b/test_legitimate_expressions.py
@@ -0,0 +1,148 @@
+#!/usr/bin/env python
+"""
+Test script to verify that legitimate expressions with filterable=False still work correctly.
+"""
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        SECRET_KEY='test-secret-key',
+    )
+
+django.setup()
+
+from django.db import models
+from django.db.utils import NotSupportedError
+from django.db.models.sql.query import Query
+from django.db.models.expressions import BaseExpression, Window
+
+
+class TestModel(models.Model):
+    name = models.CharField(max_length=100)
+    
+    class Meta:
+        app_label = "test_app"
+
+
+def test_window_expression():
+    """Test that Window expressions (which have filterable=False) still raise NotSupportedError."""
+    print("Testing Window expression with filterable=False...")
+    
+    from django.db import connection
+    with connection.schema_editor() as schema_editor:
+        schema_editor.create_model(TestModel)
+    
+    # Create a Window expression (these have filterable=False by design)
+    from django.db.models import F, Avg
+    window_expr = Window(Avg('name'))
+    
+    query = Query(TestModel)
+    
+    try:
+        query.check_filterable(window_expr)
+        print("‚úó FAILED: Window expression should have raised NotSupportedError")
+        return False
+    except NotSupportedError as e:
+        if "Window is disallowed in the filter clause" in str(e):
+            print("‚úì SUCCESS: Window expression correctly raised NotSupportedError")
+            return True
+        else:
+            print(f"‚úó FAILED: Wrong error message: {e}")
+            return False
+    except Exception as e:
+        print(f"‚úó FAILED: Unexpected error: {e}")
+        return False
+
+
+def test_custom_expression():
+    """Test a custom expression with filterable=False."""
+    print("Testing custom expression with filterable=False...")
+    
+    class CustomExpression(BaseExpression):
+        filterable = False
+    
+    expr = CustomExpression()
+    query = Query(TestModel)
+    
+    try:
+        query.check_filterable(expr)
+        print("‚úó FAILED: Custom expression should have raised NotSupportedError")
+        return False
+    except NotSupportedError as e:
+        if "CustomExpression is disallowed in the filter clause" in str(e):
+            print("‚úì SUCCESS: Custom expression correctly raised NotSupportedError")
+            return True
+        else:
+            print(f"‚úó FAILED: Wrong error message: {e}")
+            return False
+    except Exception as e:
+        print(f"‚úó FAILED: Unexpected error: {e}")
+        return False
+
+
+def test_expression_with_filterable_true():
+    """Test that expressions with filterable=True work correctly."""
+    print("Testing expression with filterable=True...")
+    
+    class CustomExpression(BaseExpression):
+        filterable = True  # Explicitly set to True
+    
+    expr = CustomExpression()
+    query = Query(TestModel)
+    
+    try:
+        query.check_filterable(expr)
+        print("‚úì SUCCESS: Expression with filterable=True passed check")
+        return True
+    except Exception as e:
+        print(f"‚úó FAILED: {e}")
+        return False
+
+
+def run_tests():
+    """Run all tests."""
+    print("Testing legitimate expression filterable behavior...\n")
+    
+    tests = [
+        test_window_expression,
+        test_custom_expression,
+        test_expression_with_filterable_true,
+    ]
+    
+    passed = 0
+    total = len(tests)
+    
+    for test in tests:
+        if test():
+            passed += 1
+        print()
+    
+    print(f"Results: {passed}/{total} tests passed")
+    return passed == total
+
+
+if __name__ == "__main__":
+    success = run_tests()
+    
+    if success:
+        print("üéâ All legitimate expression tests passed!")
+    else:
+        print("‚ùå Some legitimate expression tests failed.")
+    
+    sys.exit(0 if success else 1)
diff --git a/test_original_issue.py b/test_original_issue.py
new file mode 100644
index 0000000000..a9cb7549e1
--- /dev/null
+++ b/test_original_issue.py
@@ -0,0 +1,111 @@
+#!/usr/bin/env python
+"""
+Test script that exactly reproduces the original issue scenario.
+"""
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        SECRET_KEY='test-secret-key',
+    )
+
+django.setup()
+
+from django.db import models
+from django.db.utils import NotSupportedError
+from django.utils import timezone
+
+
+# Exact models from the issue description
+class ProductMetaDataType(models.Model):
+    label = models.CharField(max_length=255, unique=True, blank=False, null=False)
+    filterable = models.BooleanField(default=False)
+    
+    class Meta:
+        app_label = "adminpricing"
+    
+    def __str__(self):
+        return self.label
+
+
+class ProductMetaData(models.Model):
+    id = models.BigAutoField(primary_key=True)
+    product = models.CharField(max_length=255, null=False, blank=False)  # Simplified from ForeignKey
+    value = models.TextField(null=False, blank=False)
+    marketplace = models.CharField(max_length=255, null=False, blank=False)  # Simplified from ForeignKey
+    date_created = models.DateTimeField(null=True, default=timezone.now)
+    metadata_type = models.ForeignKey(
+        ProductMetaDataType, null=False, blank=False, on_delete=models.CASCADE
+    )
+    
+    class Meta:
+        app_label = "adminpricing"
+
+
+def test_original_issue():
+    """Test the exact scenario from the issue description."""
+    print("Testing the exact original issue scenario...")
+    
+    # Create tables
+    from django.db import connection
+    with connection.schema_editor() as schema_editor:
+        schema_editor.create_model(ProductMetaDataType)
+        schema_editor.create_model(ProductMetaData)
+    
+    # Create the metadata type with filterable=False (this was causing the issue)
+    brand_metadata = ProductMetaDataType.objects.create(
+        label="Brand",
+        filterable=False
+    )
+    
+    # Create a product metadata record
+    ProductMetaData.objects.create(
+        product="Test Product",
+        value="Dark Vador",
+        marketplace="Test Marketplace",
+        metadata_type=brand_metadata
+    )
+    
+    # This is the exact line that was failing in the issue
+    try:
+        print("Executing: ProductMetaData.objects.filter(value='Dark Vador', metadata_type=brand_metadata)")
+        for p in ProductMetaData.objects.filter(value="Dark Vador", metadata_type=brand_metadata):
+            print(f"  Found: {p.product} - {p.value}")
+        
+        print("‚úì SUCCESS: Original issue is fixed!")
+        return True
+        
+    except NotSupportedError as e:
+        print(f"‚úó FAILED: {e}")
+        return False
+    except Exception as e:
+        print(f"‚úó UNEXPECTED ERROR: {e}")
+        return False
+
+
+if __name__ == "__main__":
+    print("Testing the original issue scenario...\n")
+    success = test_original_issue()
+    
+    if success:
+        print("\nüéâ The original issue has been successfully resolved!")
+    else:
+        print("\n‚ùå The original issue still exists.")
+    
+    sys.exit(0 if success else 1)
diff --git a/test_query_fix.py b/test_query_fix.py
new file mode 100644
index 0000000000..d79d11e33f
--- /dev/null
+++ b/test_query_fix.py
@@ -0,0 +1,158 @@
+#!/usr/bin/env python
+"""
+Test script to verify the query fix works correctly.
+"""
+
+import os
+import sys
+import django
+from django.conf import settings
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+        ],
+        SECRET_KEY='test-secret-key',
+    )
+
+django.setup()
+
+from django.db import models
+from django.db.utils import NotSupportedError
+from django.db.models.sql.query import Query
+from django.db.models.expressions import BaseExpression
+
+
+class TestModel(models.Model):
+    name = models.CharField(max_length=100)
+    filterable = models.BooleanField(default=False)
+    
+    class Meta:
+        app_label = "test_app"
+
+
+class TestExpression(BaseExpression):
+    """Test expression with filterable=False"""
+    filterable = False
+
+
+def test_query_filterable_check():
+    """Test that the check_filterable method works correctly."""
+    print("Testing check_filterable method...")
+    
+    # Test 1: Model instance should not raise error
+    print("  Test 1: Model instance with filterable=False")
+    query = Query(TestModel)
+    model_instance = TestModel(name="test", filterable=False)
+    
+    try:
+        query.check_filterable(model_instance)
+        print("    ‚úì SUCCESS: Model instance passed filterable check")
+    except Exception as e:
+        print(f"    ‚úó FAILED: {e}")
+        return False
+    
+    # Test 2: Expression with filterable=False should raise error
+    print("  Test 2: Expression with filterable=False")
+    expr = TestExpression()
+    
+    try:
+        query.check_filterable(expr)
+        print("    ‚úó FAILED: Should have raised NotSupportedError")
+        return False
+    except NotSupportedError as e:
+        if "TestExpression is disallowed in the filter clause" in str(e):
+            print("    ‚úì SUCCESS: Expression correctly raised NotSupportedError")
+        else:
+            print(f"    ‚úó FAILED: Wrong error message: {e}")
+            return False
+    except Exception as e:
+        print(f"    ‚úó FAILED: Unexpected error: {e}")
+        return False
+    
+    # Test 3: Regular object should not raise error
+    print("  Test 3: Regular object")
+    class RegularObject:
+        filterable = False
+    
+    regular_obj = RegularObject()
+    
+    try:
+        query.check_filterable(regular_obj)
+        print("    ‚úì SUCCESS: Regular object passed filterable check")
+    except Exception as e:
+        print(f"    ‚úó FAILED: {e}")
+        return False
+    
+    return True
+
+
+def test_actual_query():
+    """Test actual database query with filterable field."""
+    print("Testing actual database query...")
+    
+    from django.db import connection
+    with connection.schema_editor() as schema_editor:
+        schema_editor.create_model(TestModel)
+    
+    # Create test data
+    obj1 = TestModel.objects.create(name="test1", filterable=False)
+    obj2 = TestModel.objects.create(name="test2", filterable=True)
+    
+    # Test filtering with filterable=False object
+    try:
+        results = TestModel.objects.filter(name="test1")
+        assert results.count() == 1
+        assert results.first().name == "test1"
+        print("  ‚úì SUCCESS: Query with filterable=False object works")
+    except Exception as e:
+        print(f"    ‚úó FAILED: {e}")
+        return False
+    
+    # Test filtering with filterable=True object
+    try:
+        results = TestModel.objects.filter(name="test2")
+        assert results.count() == 1
+        assert results.first().name == "test2"
+        print("  ‚úì SUCCESS: Query with filterable=True object works")
+    except Exception as e:
+        print(f"    ‚úó FAILED: {e}")
+        return False
+    
+    return True
+
+
+def run_tests():
+    """Run all tests."""
+    print("Running query fix tests...\n")
+    
+    tests = [
+        test_query_filterable_check,
+        test_actual_query,
+    ]
+    
+    passed = 0
+    total = len(tests)
+    
+    for test in tests:
+        if test():
+            passed += 1
+        print()
+    
+    print(f"Results: {passed}/{total} tests passed")
+    return passed == total
+
+
+if __name__ == "__main__":
+    success = run_tests()
+    sys.exit(0 if success else 1)
--------
2026-01-06 15:06:46,093 - INFO - Using instance container image: docker.io/swebench/sweb.eval.x86_64.django_1776_django-15498:latest. Please make sure this image exists. Submit an issue on https://github.com/OpenHands/OpenHands if you run into any issues.
2026-01-06 15:06:46,100 - INFO - Resource mapping for princeton-nlp__SWE-bench_Lite-test not found.
2026-01-06 15:06:46,100 - INFO - Logging LLM completions for instance django__django-15498 to ./continuum32/princeton-nlp__SWE-bench_Lite-test/CodeActAgent/GLM-4.6-FP8_maxiter_135/llm_completions/django__django-15498
2026-01-06 15:06:46,116 - INFO - Config file not found: config.toml. Error: [Errno 2] No such file or directory: 'config.toml'
2026-01-06 15:06:46,116 - INFO - Config file not found: [Errno 2] No such file or directory: 'config.toml'. Toml values have not been applied.
