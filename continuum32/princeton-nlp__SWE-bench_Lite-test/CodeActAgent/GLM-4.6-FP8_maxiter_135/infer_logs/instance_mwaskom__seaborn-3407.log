2026-01-06 15:42:50,088 - INFO - [LLM registry 42020348-3786-4e61-b826-9d49d61cf0c7]: Registering service for agent
2026-01-06 15:42:50,136 - INFO - Building image: ghcr.io/openhands/runtime:oh_v1.0.0_6rr8wvm48fdwyk95_v008aov5t6vw3gr5
2026-01-06 15:49:49,320 - INFO - Image [ghcr.io/openhands/runtime:oh_v1.0.0_6rr8wvm48fdwyk95_v008aov5t6vw3gr5] build finished.
2026-01-06 15:49:49,325 - INFO - Re-tagged image [ghcr.io/openhands/runtime:oh_v1.0.0_6rr8wvm48fdwyk95_v008aov5t6vw3gr5] with more generic tag [oh_v1.0.0_6rr8wvm48fdwyk95]
2026-01-06 15:49:49,327 - INFO - Image ghcr.io/openhands/runtime with tags [oh_v1.0.0_6rr8wvm48fdwyk95_v008aov5t6vw3gr5, oh_v1.0.0_6rr8wvm48fdwyk95] built successfully
2026-01-06 15:49:49,360 - INFO - [runtime 7bb59493-150c-41-8b5c2cdd1a01dd0] Starting runtime with image: ghcr.io/openhands/runtime:oh_v1.0.0_6rr8wvm48fdwyk95_v008aov5t6vw3gr5
2026-01-06 15:49:49,523 - INFO - [runtime 7bb59493-150c-41-8b5c2cdd1a01dd0] Starting server with command: ['/openhands/micromamba/bin/micromamba', 'run', '-n', 'openhands', 'poetry', 'run', 'python', '-u', '-m', 'openhands.runtime.action_execution_server', '30658', '--working-dir', '/workspace', '--plugins', 'agent_skills', 'jupyter', '--username', 'root', '--user-id', '0', '--no-enable-browser']
2026-01-06 15:49:49,822 - INFO - [runtime 7bb59493-150c-41-8b5c2cdd1a01dd0] Container started: openhands-runtime-7bb59493-150c-41-8b5c2cdd1a01dd0. VSCode URL: None
2026-01-06 15:49:49,823 - INFO - [runtime 7bb59493-150c-41-8b5c2cdd1a01dd0] Waiting for client to become ready at http://localhost:30658...
2026-01-06 15:50:17,897 - INFO - [runtime 7bb59493-150c-41-8b5c2cdd1a01dd0] Runtime is ready.
2026-01-06 15:50:21,018 - INFO - Successfully configured git: name=openhands, email=openhands@all-hands.dev
2026-01-06 15:50:21,019 - INFO - ------------------------------
2026-01-06 15:50:21,020 - INFO - BEGIN Runtime Initialization Fn
2026-01-06 15:50:21,020 - INFO - ------------------------------
2026-01-06 15:50:21,020 - INFO - **CmdRunAction (source=None, is_input=False)**
COMMAND:
echo 'export SWE_INSTANCE_ID=mwaskom__seaborn-3407' >> ~/.bashrc && echo 'export PIP_CACHE_DIR=~/.cache/pip' >> ~/.bashrc && echo "alias git='git --no-pager'" >> ~/.bashrc && git config --global core.pager "" && git config --global diff.binary false
2026-01-06 15:50:21,640 - INFO - **CmdOutputObservation (source=None, exit code=0, metadata={
  "exit_code": 0,
  "pid": -1,
  "username": "root",
  "hostname": "f8c103566539",
  "working_dir": "/workspace",
  "py_interpreter_path": "/openhands/micromamba/envs/openhands/bin/python",
  "prefix": "",
  "suffix": "\n[The command completed with exit code 0.]"
})**
--BEGIN AGENT OBSERVATION--

[The command completed with exit code 0.]
[Current working directory: /workspace]
[Python interpreter: /openhands/micromamba/envs/openhands/bin/python]
[Command finished with exit code 0]
--END AGENT OBSERVATION--
2026-01-06 15:50:21,640 - INFO - **CmdRunAction (source=None, is_input=False)**
COMMAND:
export USER=$(whoami); echo USER=${USER} 
2026-01-06 15:50:22,258 - INFO - **CmdOutputObservation (source=None, exit code=0, metadata={
  "exit_code": 0,
  "pid": -1,
  "username": "root",
  "hostname": "f8c103566539",
  "working_dir": "/workspace",
  "py_interpreter_path": "/openhands/micromamba/envs/openhands/bin/python",
  "prefix": "",
  "suffix": "\n[The command completed with exit code 0.]"
})**
--BEGIN AGENT OBSERVATION--
USER=root
[The command completed with exit code 0.]
[Current working directory: /workspace]
[Python interpreter: /openhands/micromamba/envs/openhands/bin/python]
[Command finished with exit code 0]
--END AGENT OBSERVATION--
2026-01-06 15:50:22,259 - INFO - **CmdRunAction (source=None, is_input=False)**
COMMAND:
mkdir -p /swe_util/eval_data/instances
2026-01-06 15:50:22,884 - INFO - **CmdOutputObservation (source=None, exit code=0, metadata={
  "exit_code": 0,
  "pid": -1,
  "username": "root",
  "hostname": "f8c103566539",
  "working_dir": "/workspace",
  "py_interpreter_path": "/openhands/micromamba/envs/openhands/bin/python",
  "prefix": "",
  "suffix": "\n[The command completed with exit code 0.]"
})**
--BEGIN AGENT OBSERVATION--

[The command completed with exit code 0.]
[Current working directory: /workspace]
[Python interpreter: /openhands/micromamba/envs/openhands/bin/python]
[Command finished with exit code 0]
--END AGENT OBSERVATION--
2026-01-06 15:50:22,891 - INFO - **CmdRunAction (source=None, is_input=False)**
COMMAND:
cat ~/.bashrc
2026-01-06 15:50:23,510 - INFO - **CmdOutputObservation (source=None, exit code=0, metadata={
  "exit_code": 0,
  "pid": -1,
  "username": "root",
  "hostname": "f8c103566539",
  "working_dir": "/workspace",
  "py_interpreter_path": "/openhands/micromamba/envs/openhands/bin/python",
  "prefix": "",
  "suffix": "\n[The command completed with exit code 0.]"
})**
--BEGIN AGENT OBSERVATION--
source /opt/miniconda3/etc/profile.d/conda.sh && conda activate testbed

. "/openhands/bin/env"
export PATH="/usr/bin:/bin:/usr/sbin:/sbin:/openhands/micromamba/bin:$PATH"
export PLAYWRIGHT_BROWSERS_PATH=/opt/playwright-browsers
eval "$(/openhands/micromamba/bin/micromamba shell hook --shell bash)"
micromamba activate openhands 2>/dev/null || true
export ENABLE_AUTO_LINT=true
export NO_CHANGE_TIMEOUT_SECONDS=30
export OPENHANDS_EVAL_INSTANCE_ID=mwaskom__seaborn-3407
export OPENHANDS_EVAL_JOB_ID=1243110938
export OPENHANDS_TIMING_DIR=./continuum32/princeton-nlp__SWE-bench_Lite-test/CodeActAgent/GLM-4.6-FP8_maxiter_135/timing
export SWE_INSTANCE_ID=mwaskom__seaborn-3407
export PIP_CACHE_DIR=~/.cache/pip
alias git='git --no-pager'
[The command completed with exit code 0.]
[Current working directory: /workspace]
[Python interpreter: /openhands/micromamba/envs/openhands/bin/python]
[Command finished with exit code 0]
--END AGENT OBSERVATION--
2026-01-06 15:50:23,511 - INFO - **CmdRunAction (source=None, is_input=False)**
COMMAND:
source ~/.bashrc
2026-01-06 15:50:24,130 - INFO - **CmdOutputObservation (source=None, exit code=0, metadata={
  "exit_code": 0,
  "pid": -1,
  "username": "root",
  "hostname": "f8c103566539",
  "working_dir": "/workspace",
  "py_interpreter_path": "/openhands/micromamba/envs/openhands/bin/python",
  "prefix": "",
  "suffix": "\n[The command completed with exit code 0.]"
})**
--BEGIN AGENT OBSERVATION--

[The command completed with exit code 0.]
[Current working directory: /workspace]
[Python interpreter: /openhands/micromamba/envs/openhands/bin/python]
[Command finished with exit code 0]
--END AGENT OBSERVATION--
2026-01-06 15:50:24,131 - INFO - **CmdRunAction (source=None, is_input=False)**
COMMAND:
source /swe_util/instance_swe_entry.sh
2026-01-06 15:50:24,748 - INFO - **CmdOutputObservation (source=None, exit code=0, metadata={
  "exit_code": 0,
  "pid": -1,
  "username": "root",
  "hostname": "f8c103566539",
  "working_dir": "/workspace",
  "py_interpreter_path": "/opt/miniconda3/envs/testbed/bin/python",
  "prefix": "",
  "suffix": "\n[The command completed with exit code 0.]"
})**
--BEGIN AGENT OBSERVATION--
WORKSPACE_NAME: mwaskom__seaborn__0.13
[The command completed with exit code 0.]
[Current working directory: /workspace]
[Python interpreter: /opt/miniconda3/envs/testbed/bin/python]
[Command finished with exit code 0]
--END AGENT OBSERVATION--
2026-01-06 15:50:24,749 - INFO - **CmdRunAction (source=None, is_input=False)**
COMMAND:
cd /workspace/mwaskom__seaborn__0.13
2026-01-06 15:50:25,367 - INFO - **CmdOutputObservation (source=None, exit code=0, metadata={
  "exit_code": 0,
  "pid": -1,
  "username": "root",
  "hostname": "f8c103566539",
  "working_dir": "/workspace/mwaskom__seaborn__0.13",
  "py_interpreter_path": "/opt/miniconda3/envs/testbed/bin/python",
  "prefix": "",
  "suffix": "\n[The command completed with exit code 0.]"
})**
--BEGIN AGENT OBSERVATION--

[The command completed with exit code 0.]
[Current working directory: /workspace/mwaskom__seaborn__0.13]
[Python interpreter: /opt/miniconda3/envs/testbed/bin/python]
[Command finished with exit code 0]
--END AGENT OBSERVATION--
2026-01-06 15:50:25,367 - INFO - **CmdRunAction (source=None, is_input=False)**
COMMAND:
git reset --hard
2026-01-06 15:50:25,984 - INFO - **CmdOutputObservation (source=None, exit code=0, metadata={
  "exit_code": 0,
  "pid": -1,
  "username": "root",
  "hostname": "f8c103566539",
  "working_dir": "/workspace/mwaskom__seaborn__0.13",
  "py_interpreter_path": "/opt/miniconda3/envs/testbed/bin/python",
  "prefix": "",
  "suffix": "\n[The command completed with exit code 0.]"
})**
--BEGIN AGENT OBSERVATION--
HEAD is now at 515286e0 Improve handling of edge cases with nullable dtypes (#3394)
[The command completed with exit code 0.]
[Current working directory: /workspace/mwaskom__seaborn__0.13]
[Python interpreter: /opt/miniconda3/envs/testbed/bin/python]
[Command finished with exit code 0]
--END AGENT OBSERVATION--
2026-01-06 15:50:25,984 - INFO - **CmdRunAction (source=None, is_input=False)**
COMMAND:
for remote_name in $(git remote); do git remote remove "${remote_name}"; done
2026-01-06 15:50:26,603 - INFO - **CmdOutputObservation (source=None, exit code=0, metadata={
  "exit_code": 0,
  "pid": -1,
  "username": "root",
  "hostname": "f8c103566539",
  "working_dir": "/workspace/mwaskom__seaborn__0.13",
  "py_interpreter_path": "/opt/miniconda3/envs/testbed/bin/python",
  "prefix": "",
  "suffix": "\n[The command completed with exit code 0.]"
})**
--BEGIN AGENT OBSERVATION--

[The command completed with exit code 0.]
[Current working directory: /workspace/mwaskom__seaborn__0.13]
[Python interpreter: /opt/miniconda3/envs/testbed/bin/python]
[Command finished with exit code 0]
--END AGENT OBSERVATION--
2026-01-06 15:50:26,603 - INFO - **CmdRunAction (source=None, is_input=False)**
COMMAND:
which python
2026-01-06 15:50:27,222 - INFO - **CmdOutputObservation (source=None, exit code=0, metadata={
  "exit_code": 0,
  "pid": -1,
  "username": "root",
  "hostname": "f8c103566539",
  "working_dir": "/workspace/mwaskom__seaborn__0.13",
  "py_interpreter_path": "/opt/miniconda3/envs/testbed/bin/python",
  "prefix": "",
  "suffix": "\n[The command completed with exit code 0.]"
})**
--BEGIN AGENT OBSERVATION--
/opt/miniconda3/envs/testbed/bin/python
[The command completed with exit code 0.]
[Current working directory: /workspace/mwaskom__seaborn__0.13]
[Python interpreter: /opt/miniconda3/envs/testbed/bin/python]
[Command finished with exit code 0]
--END AGENT OBSERVATION--
2026-01-06 15:50:27,222 - INFO - ------------------------------
2026-01-06 15:50:27,222 - INFO - END Runtime Initialization Fn
2026-01-06 15:50:27,222 - INFO - ------------------------------
2026-01-06 15:50:27,225 - INFO - [LLM registry e3328d31-eb5f-462f-aff9-893e3d78fefb]: Registering service for agent
2026-01-06 15:50:27,236 - INFO - [runtime 7bb59493-150c-41-8b5c2cdd1a01dd0] Selected repo: None, loading microagents from /workspace/.openhands/microagents (inside runtime)
2026-01-06 15:50:27,239 - INFO - [runtime 7bb59493-150c-41-8b5c2cdd1a01dd0] Attempting to list files in repository microagents directory: /workspace/.openhands/microagents
2026-01-06 15:50:27,244 - INFO - Loading user workspace microagents: []
2026-01-06 15:50:27,244 - INFO - AgentController 7bb59493-150c-41-8b5c2cdd1a01dd0 - created new state. start_id: 0
2026-01-06 15:50:27,254 - INFO - [Agent Controller 7bb59493-150c-41-8b5c2cdd1a01dd0] Setting agent(CodeActAgent) state from AgentState.LOADING to AgentState.RUNNING
2026-01-06 15:50:27,256 - INFO - Saved conversation stats
2026-01-06 16:00:23,049 - INFO - [Agent Controller 7bb59493-150c-41-8b5c2cdd1a01dd0] Setting agent(CodeActAgent) state from AgentState.RUNNING to AgentState.FINISHED
2026-01-06 16:00:23,051 - INFO - Saved conversation stats
2026-01-06 16:00:23,878 - INFO - ------------------------------
2026-01-06 16:00:23,878 - INFO - BEGIN Runtime Completion Fn
2026-01-06 16:00:23,878 - INFO - ------------------------------
2026-01-06 16:00:23,879 - INFO - **CmdRunAction (source=None, is_input=False)**
COMMAND:
cd /workspace/mwaskom__seaborn__0.13
2026-01-06 16:00:24,499 - INFO - **CmdOutputObservation (source=None, exit code=0, metadata={
  "exit_code": 0,
  "pid": -1,
  "username": "root",
  "hostname": "f8c103566539",
  "working_dir": "/workspace/mwaskom__seaborn__0.13",
  "py_interpreter_path": "/opt/miniconda3/envs/testbed/bin/python",
  "prefix": "",
  "suffix": "\n[The command completed with exit code 0.]"
})**
--BEGIN AGENT OBSERVATION--

[The command completed with exit code 0.]
[Current working directory: /workspace/mwaskom__seaborn__0.13]
[Python interpreter: /opt/miniconda3/envs/testbed/bin/python]
[Command finished with exit code 0]
--END AGENT OBSERVATION--
2026-01-06 16:00:24,499 - INFO - **CmdRunAction (source=None, is_input=False)**
COMMAND:
git config --global core.pager ""
2026-01-06 16:00:25,119 - INFO - **CmdOutputObservation (source=None, exit code=0, metadata={
  "exit_code": 0,
  "pid": -1,
  "username": "root",
  "hostname": "f8c103566539",
  "working_dir": "/workspace/mwaskom__seaborn__0.13",
  "py_interpreter_path": "/opt/miniconda3/envs/testbed/bin/python",
  "prefix": "",
  "suffix": "\n[The command completed with exit code 0.]"
})**
--BEGIN AGENT OBSERVATION--

[The command completed with exit code 0.]
[Current working directory: /workspace/mwaskom__seaborn__0.13]
[Python interpreter: /opt/miniconda3/envs/testbed/bin/python]
[Command finished with exit code 0]
--END AGENT OBSERVATION--
2026-01-06 16:00:25,119 - INFO - **CmdRunAction (source=None, is_input=False)**
COMMAND:
find . -type d -name .git -not -path "./.git"
2026-01-06 16:00:25,742 - INFO - **CmdOutputObservation (source=None, exit code=0, metadata={
  "exit_code": 0,
  "pid": -1,
  "username": "root",
  "hostname": "f8c103566539",
  "working_dir": "/workspace/mwaskom__seaborn__0.13",
  "py_interpreter_path": "/opt/miniconda3/envs/testbed/bin/python",
  "prefix": "",
  "suffix": "\n[The command completed with exit code 0.]"
})**
--BEGIN AGENT OBSERVATION--

[The command completed with exit code 0.]
[Current working directory: /workspace/mwaskom__seaborn__0.13]
[Python interpreter: /opt/miniconda3/envs/testbed/bin/python]
[Command finished with exit code 0]
--END AGENT OBSERVATION--
2026-01-06 16:00:25,743 - INFO - **CmdRunAction (source=None, is_input=False)**
COMMAND:
git add -A
2026-01-06 16:00:26,369 - INFO - **CmdOutputObservation (source=None, exit code=0, metadata={
  "exit_code": 0,
  "pid": -1,
  "username": "root",
  "hostname": "f8c103566539",
  "working_dir": "/workspace/mwaskom__seaborn__0.13",
  "py_interpreter_path": "/opt/miniconda3/envs/testbed/bin/python",
  "prefix": "",
  "suffix": "\n[The command completed with exit code 0.]"
})**
--BEGIN AGENT OBSERVATION--

[The command completed with exit code 0.]
[Current working directory: /workspace/mwaskom__seaborn__0.13]
[Python interpreter: /opt/miniconda3/envs/testbed/bin/python]
[Command finished with exit code 0]
--END AGENT OBSERVATION--
2026-01-06 16:00:26,369 - INFO - **CmdRunAction (source=None, is_input=False)**
COMMAND:
for file in $(git status --porcelain | grep -E "^(M| M|\?\?|A| A)" | cut -c4-); do
        if [ -f "$file" ] && (file "$file" | grep -q "executable" || git check-attr binary "$file" | grep -q "binary: set"); then
            git rm -f "$file" 2>/dev/null || rm -f "$file"
            echo "Removed: $file"
        fi
    done
2026-01-06 16:00:26,995 - INFO - **CmdOutputObservation (source=None, exit code=0, metadata={
  "exit_code": 0,
  "pid": -1,
  "username": "root",
  "hostname": "f8c103566539",
  "working_dir": "/workspace/mwaskom__seaborn__0.13",
  "py_interpreter_path": "/opt/miniconda3/envs/testbed/bin/python",
  "prefix": "",
  "suffix": "\n[The command completed with exit code 0.]"
})**
--BEGIN AGENT OBSERVATION--
bash: file: command not found
bash: file: command not found
bash: file: command not found
bash: file: command not found
bash: file: command not found
bash: file: command not found
[The command completed with exit code 0.]
[Current working directory: /workspace/mwaskom__seaborn__0.13]
[Python interpreter: /opt/miniconda3/envs/testbed/bin/python]
[Command finished with exit code 0]
--END AGENT OBSERVATION--
2026-01-06 16:00:26,996 - INFO - **CmdRunAction (source=None, is_input=False)**
COMMAND:
git diff --no-color --cached 515286e02be3e4c0ff2ef4addb34a53c4a676ee4 > patch.diff
2026-01-06 16:00:27,621 - INFO - **CmdOutputObservation (source=None, exit code=0, metadata={
  "exit_code": 0,
  "pid": -1,
  "username": "root",
  "hostname": "f8c103566539",
  "working_dir": "/workspace/mwaskom__seaborn__0.13",
  "py_interpreter_path": "/opt/miniconda3/envs/testbed/bin/python",
  "prefix": "",
  "suffix": "\n[The command completed with exit code 0.]"
})**
--BEGIN AGENT OBSERVATION--

[The command completed with exit code 0.]
[Current working directory: /workspace/mwaskom__seaborn__0.13]
[Python interpreter: /opt/miniconda3/envs/testbed/bin/python]
[Command finished with exit code 0]
--END AGENT OBSERVATION--
2026-01-06 16:00:27,622 - INFO - FileReadAction(path='patch.diff', start=0, end=-1, thought='', action=<ActionType.READ: 'read'>, security_risk=<ActionSecurityRisk.UNKNOWN: -1>, impl_source=<FileReadSource.DEFAULT: 'default'>, view_range=None)
2026-01-06 16:00:27,625 - INFO - [Read from /workspace/mwaskom__seaborn__0.13/patch.diff is successful.]
diff --git a/debug_issue.py b/debug_issue.py
new file mode 100644
index 00000000..a8e1058e
--- /dev/null
+++ b/debug_issue.py
@@ -0,0 +1,71 @@
+#!/usr/bin/env python3
+"""
+Debug script to understand where the MultiIndex issue occurs.
+"""
+
+import numpy as np
+import pandas as pd
+import seaborn as sns
+
+def debug_pairgrid_creation():
+    """Debug the PairGrid creation process."""
+    print("Creating MultiIndex DataFrame...")
+    
+    # Create MultiIndex DataFrame
+    data = {
+        ("A", "1"): np.random.rand(10),
+        ("A", "2"): np.random.rand(10),
+        ("B", "1"): np.random.rand(10),
+        ("B", "2"): np.random.rand(10),
+    }
+    df = pd.DataFrame(data)
+    
+    print("DataFrame columns:", df.columns.tolist())
+    print("Column types:", [type(col) for col in df.columns])
+    
+    # Let's manually step through the PairGrid creation process
+    print("\n=== PairGrid Creation Debug ===")
+    
+    # Import the PairGrid class
+    from seaborn.axisgrid import PairGrid
+    
+    # Step 1: Find numeric columns
+    grid = PairGrid.__new__(PairGrid)  # Create instance without calling __init__
+    numeric_cols = grid._find_numeric_cols(df)
+    print("Numeric cols found:", numeric_cols)
+    print("Numeric col types:", [type(col) for col in numeric_cols])
+    
+    # Step 2: Create the grid (this should work)
+    try:
+        grid = PairGrid(df)
+        print("PairGrid created successfully!")
+        print("x_vars:", grid.x_vars)
+        print("y_vars:", grid.y_vars)
+        print("x_vars types:", [type(var) for var in grid.x_vars])
+        print("y_vars types:", [type(var) for var in grid.y_vars])
+        
+        # Step 3: Check what happens when we access the data
+        print("\n=== Data Access Debug ===")
+        for var in grid.x_vars:
+            print(f"Trying to access var: {var} (type: {type(var)})")
+            try:
+                vector = grid.data[var]
+                print(f"  SUCCESS: Got vector of shape {vector.shape}")
+            except Exception as e:
+                print(f"  ERROR: {e}")
+                
+        # Step 4: Check diagonal variables
+        print("\n=== Diagonal Variables Debug ===")
+        if hasattr(grid, 'diag_vars') and grid.diag_vars is not None:
+            print("diag_vars:", grid.diag_vars)
+            print("diag_vars types:", [type(var) for var in grid.diag_vars])
+        else:
+            print("diag_vars is None - need to call map_diag first")
+            
+    except Exception as e:
+        print(f"Error creating PairGrid: {e}")
+        import traceback
+        traceback.print_exc()
+
+if __name__ == "__main__":
+    debug_pairgrid_creation()
diff --git a/debug_mapdiag.py b/debug_mapdiag.py
new file mode 100644
index 00000000..7735d390
--- /dev/null
+++ b/debug_mapdiag.py
@@ -0,0 +1,83 @@
+#!/usr/bin/env python3
+"""
+Debug script to understand the map_diag issue with MultiIndex.
+"""
+
+import numpy as np
+import pandas as pd
+import seaborn as sns
+
+def debug_map_diag():
+    """Debug the map_diag process."""
+    print("Creating MultiIndex DataFrame...")
+    
+    # Create MultiIndex DataFrame
+    data = {
+        ("A", "1"): np.random.rand(10),
+        ("A", "2"): np.random.rand(10),
+        ("B", "1"): np.random.rand(10),
+        ("B", "2"): np.random.rand(10),
+    }
+    df = pd.DataFrame(data)
+    
+    print("DataFrame columns:", df.columns.tolist())
+    
+    # Import the PairGrid class
+    from seaborn.axisgrid import PairGrid
+    from seaborn.distributions import histplot
+    
+    # Create the grid
+    grid = PairGrid(df)
+    print("PairGrid created successfully!")
+    print("x_vars:", grid.x_vars)
+    print("y_vars:", grid.y_vars)
+    
+    # Now let's debug the map_diag process step by step
+    print("\n=== Debugging map_diag ===")
+    
+    # Step 1: Check the diagonal variable setup
+    print("Before map_diag - diag_vars:", getattr(grid, 'diag_vars', 'None'))
+    
+    # Let's manually step through the map_diag logic
+    print("\nStep 1: Setting up diagonal axes...")
+    if grid.diag_axes is None:
+        diag_vars = []
+        diag_axes = []
+        for i, y_var in enumerate(grid.y_vars):
+            for j, x_var in enumerate(grid.x_vars):
+                print(f"  Checking: y_var={y_var} (type: {type(y_var)}), x_var={x_var} (type: {type(x_var)})")
+                if x_var == y_var:
+                    print(f"    Match found! Adding x_var to diag_vars: {x_var}")
+                    diag_vars.append(x_var)
+                    # ... (rest of the axis setup)
+        
+        print(f"diag_vars after setup: {diag_vars}")
+        print(f"diag_vars types: {[type(var) for var in diag_vars]}")
+        
+        # This is where the issue might be - let's see what numpy does to these
+        diag_vars_array = np.array(diag_vars, np.object_)
+        print(f"diag_vars as numpy array: {diag_vars_array}")
+        print(f"diag_vars array types: {[type(var) for var in diag_vars_array]}")
+        
+        # Let's test accessing data with these variables
+        print("\nTesting data access with diag_vars:")
+        for var in diag_vars_array:
+            print(f"  Trying var: {var} (type: {type(var)})")
+            try:
+                vector = grid.data[var]
+                print(f"    SUCCESS")
+            except Exception as e:
+                print(f"    ERROR: {e}")
+    
+    # Now let's try the actual map_diag call
+    print("\n=== Calling map_diag ===")
+    try:
+        grid.map_diag(histplot)
+        print("map_diag completed successfully!")
+    except Exception as e:
+        print(f"map_diag failed: {e}")
+        import traceback
+        traceback.print_exc()
+
+if __name__ == "__main__":
+    debug_map_diag()
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 00000000..6985a8ea
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,110 @@
+#!/usr/bin/env python3
+"""
+Reproduction script for the MultiIndex DataFrame pairplot KeyError issue.
+"""
+
+import numpy as np
+import pandas as pd
+import seaborn as sns
+import traceback
+
+def test_multiindex_pairplot():
+    """Test pairplot with MultiIndex DataFrame - should reproduce the KeyError."""
+    print("Testing pairplot with MultiIndex DataFrame...")
+    
+    # Create MultiIndex DataFrame as described in the issue
+    data = {
+        ("A", "1"): np.random.rand(100),
+        ("A", "2"): np.random.rand(100),
+        ("B", "1"): np.random.rand(100),
+        ("B", "2"): np.random.rand(100),
+    }
+    df = pd.DataFrame(data)
+    
+    print("DataFrame columns:", df.columns.tolist())
+    print("DataFrame shape:", df.shape)
+    print("Column names type:", type(df.columns[0]))
+    
+    try:
+        # This should raise KeyError: "['1'] not in index"
+        g = sns.pairplot(df)
+        print("SUCCESS: pairplot worked without error!")
+        return True
+    except Exception as e:
+        print(f"ERROR: {type(e).__name__}: {e}")
+        traceback.print_exc()
+        return False
+
+def test_regular_dataframe():
+    """Test pairplot with regular DataFrame - should work fine."""
+    print("\nTesting pairplot with regular DataFrame...")
+    
+    # Create regular DataFrame
+    data = {
+        "A1": np.random.rand(100),
+        "A2": np.random.rand(100),
+        "B1": np.random.rand(100),
+        "B2": np.random.rand(100),
+    }
+    df = pd.DataFrame(data)
+    
+    print("DataFrame columns:", df.columns.tolist())
+    print("DataFrame shape:", df.shape)
+    print("Column names type:", type(df.columns[0]))
+    
+    try:
+        g = sns.pairplot(df)
+        print("SUCCESS: pairplot worked without error!")
+        return True
+    except Exception as e:
+        print(f"ERROR: {type(e).__name__}: {e}")
+        traceback.print_exc()
+        return False
+
+def test_workaround():
+    """Test the workaround mentioned in the issue."""
+    print("\nTesting workaround (flattening column names)...")
+    
+    # Create MultiIndex DataFrame
+    data = {
+        ("A", "1"): np.random.rand(100),
+        ("A", "2"): np.random.rand(100),
+        ("B", "1"): np.random.rand(100),
+        ("B", "2"): np.random.rand(100),
+    }
+    df = pd.DataFrame(data)
+    
+    # Apply workaround
+    df.columns = ["".join(column) for column in df.columns]
+    
+    print("DataFrame columns after flattening:", df.columns.tolist())
+    
+    try:
+        g = sns.pairplot(df)
+        print("SUCCESS: pairplot worked with workaround!")
+        return True
+    except Exception as e:
+        print(f"ERROR: {type(e).__name__}: {e}")
+        traceback.print_exc()
+        return False
+
+if __name__ == "__main__":
+    print("=" * 60)
+    print("REPRODUCING MULTIINDEX PAIRPLOT ISSUE")
+    print("=" * 60)
+    
+    # Test regular DataFrame (should work)
+    regular_success = test_regular_dataframe()
+    
+    # Test MultiIndex DataFrame (should fail)
+    multiindex_success = test_multiindex_pairplot()
+    
+    # Test workaround (should work)
+    workaround_success = test_workaround()
+    
+    print("\n" + "=" * 60)
+    print("SUMMARY:")
+    print(f"Regular DataFrame: {'PASS' if regular_success else 'FAIL'}")
+    print(f"MultiIndex DataFrame: {'PASS' if multiindex_success else 'FAIL'}")
+    print(f"Workaround: {'PASS' if workaround_success else 'FAIL'}")
+    print("=" * 60)
diff --git a/seaborn/axisgrid.py b/seaborn/axisgrid.py
index 75349099..5eaa7997 100644
--- a/seaborn/axisgrid.py
+++ b/seaborn/axisgrid.py
@@ -1472,8 +1472,8 @@ class PairGrid(Grid):
                 for ax in diag_axes[1:]:
                     share_axis(diag_axes[0], ax, "y")
 
-            self.diag_vars = np.array(diag_vars, np.object_)
-            self.diag_axes = np.array(diag_axes, np.object_)
+            self.diag_vars = diag_vars
+            self.diag_axes = diag_axes
 
         if "hue" not in signature(func).parameters:
             return self._map_diag_iter_hue(func, **kwargs)
diff --git a/test_comprehensive.py b/test_comprehensive.py
new file mode 100644
index 00000000..e871073e
--- /dev/null
+++ b/test_comprehensive.py
@@ -0,0 +1,179 @@
+#!/usr/bin/env python3
+"""
+Comprehensive test for MultiIndex DataFrame pairplot fix.
+"""
+
+import numpy as np
+import pandas as pd
+import seaborn as sns
+import matplotlib.pyplot as plt
+
+def test_multiindex_variations():
+    """Test various MultiIndex DataFrame configurations."""
+    print("Testing various MultiIndex DataFrame configurations...")
+    
+    test_cases = [
+        # 2-level MultiIndex
+        {
+            "name": "2-level MultiIndex",
+            "data": {
+                ("A", "1"): np.random.rand(20),
+                ("A", "2"): np.random.rand(20),
+                ("B", "1"): np.random.rand(20),
+                ("B", "2"): np.random.rand(20),
+            }
+        },
+        # 3-level MultiIndex
+        {
+            "name": "3-level MultiIndex",
+            "data": {
+                ("A", "X", "1"): np.random.rand(20),
+                ("A", "X", "2"): np.random.rand(20),
+                ("B", "Y", "1"): np.random.rand(20),
+                ("B", "Y", "2"): np.random.rand(20),
+            }
+        },
+        # Mixed types in MultiIndex
+        {
+            "name": "Mixed types MultiIndex",
+            "data": {
+                ("A", 1): np.random.rand(20),
+                ("A", 2): np.random.rand(20),
+                ("B", 1): np.random.rand(20),
+                ("B", 2): np.random.rand(20),
+            }
+        },
+        # Single level MultiIndex (edge case)
+        {
+            "name": "Single level MultiIndex",
+            "data": {
+                ("A",): np.random.rand(20),
+                ("B",): np.random.rand(20),
+                ("C",): np.random.rand(20),
+            }
+        }
+    ]
+    
+    results = []
+    
+    for test_case in test_cases:
+        print(f"\n--- Testing {test_case['name']} ---")
+        df = pd.DataFrame(test_case["data"])
+        print(f"Columns: {df.columns.tolist()}")
+        
+        try:
+            # Test basic pairplot
+            g = sns.pairplot(df)
+            print(f"âœ“ Basic pairplot successful")
+            
+            # Test with different diag_kinds
+            for diag_kind in ["hist", "kde"]:
+                try:
+                    g = sns.pairplot(df, diag_kind=diag_kind)
+                    print(f"âœ“ pairplot with diag_kind='{diag_kind}' successful")
+                except Exception as e:
+                    print(f"âœ— pairplot with diag_kind='{diag_kind}' failed: {e}")
+                    results.append(False)
+                    continue
+            
+            # Test with hue parameter (if we have enough columns)
+            if len(df.columns) > 2:
+                try:
+                    # Add a categorical column for hue
+                    df_with_hue = df.copy()
+                    df_with_hue[("hue", "col")] = np.random.choice(['A', 'B'], size=len(df))
+                    g = sns.pairplot(df_with_hue, hue=("hue", "col"))
+                    print(f"âœ“ pairplot with hue successful")
+                except Exception as e:
+                    print(f"âœ— pairplot with hue failed: {e}")
+                    results.append(False)
+                    continue
+            
+            results.append(True)
+            print(f"âœ“ {test_case['name']} PASSED")
+            
+        except Exception as e:
+            print(f"âœ— {test_case['name']} FAILED: {e}")
+            results.append(False)
+        
+        plt.close('all')  # Clean up plots
+    
+    return results
+
+def test_backward_compatibility():
+    """Test that regular DataFrames still work."""
+    print("\n" + "="*50)
+    print("Testing backward compatibility with regular DataFrames...")
+    
+    test_cases = [
+        {
+            "name": "String columns",
+            "data": {
+                "A1": np.random.rand(20),
+                "A2": np.random.rand(20),
+                "B1": np.random.rand(20),
+                "B2": np.random.rand(20),
+            }
+        },
+        {
+            "name": "Integer columns",
+            "data": {
+                1: np.random.rand(20),
+                2: np.random.rand(20),
+                3: np.random.rand(20),
+                4: np.random.rand(20),
+            }
+        },
+        {
+            "name": "Mixed columns",
+            "data": {
+                "A": np.random.rand(20),
+                1: np.random.rand(20),
+                "B": np.random.rand(20),
+                2: np.random.rand(20),
+            }
+        }
+    ]
+    
+    results = []
+    
+    for test_case in test_cases:
+        print(f"\n--- Testing {test_case['name']} ---")
+        df = pd.DataFrame(test_case["data"])
+        print(f"Columns: {df.columns.tolist()}")
+        
+        try:
+            g = sns.pairplot(df)
+            print(f"âœ“ {test_case['name']} PASSED")
+            results.append(True)
+        except Exception as e:
+            print(f"âœ— {test_case['name']} FAILED: {e}")
+            results.append(False)
+        
+        plt.close('all')  # Clean up plots
+    
+    return results
+
+if __name__ == "__main__":
+    print("=" * 60)
+    print("COMPREHENSIVE MULTIINDEX PAIRPLOT TESTING")
+    print("=" * 60)
+    
+    # Test MultiIndex variations
+    multiindex_results = test_multiindex_variations()
+    
+    # Test backward compatibility
+    backward_compat_results = test_backward_compatibility()
+    
+    # Summary
+    print("\n" + "=" * 60)
+    print("SUMMARY:")
+    print(f"MultiIndex tests: {sum(multiindex_results)}/{len(multiindex_results)} passed")
+    print(f"Backward compatibility tests: {sum(backward_compat_results)}/{len(backward_compat_results)} passed")
+    print(f"Total: {sum(multiindex_results + backward_compat_results)}/{len(multiindex_results + backward_compat_results)} passed")
+    
+    if all(multiindex_results + backward_compat_results):
+        print("ðŸŽ‰ ALL TESTS PASSED!")
+    else:
+        print("âŒ Some tests failed!")
+    print("=" * 60)
diff --git a/tests/test_axisgrid.py b/tests/test_axisgrid.py
index ce8b0eaa..3efaf6eb 100644
--- a/tests/test_axisgrid.py
+++ b/tests/test_axisgrid.py
@@ -1422,6 +1422,34 @@ class TestPairGrid:
         with pytest.warns(UserWarning):
             g = ag.pairplot(self.df, hue="a", vars=vars, markers=markers[:-2])
 
+    def test_pairplot_multiindex(self):
+        """Test that pairplot works with MultiIndex DataFrames."""
+        # Create MultiIndex DataFrame
+        data = {
+            ("A", "1"): self.rs.normal(size=50),
+            ("A", "2"): self.rs.normal(size=50),
+            ("B", "1"): self.rs.normal(size=50),
+            ("B", "2"): self.rs.normal(size=50),
+        }
+        df_multi = pd.DataFrame(data)
+        
+        # This should not raise a KeyError
+        g = ag.pairplot(df_multi)
+        
+        # Test with different diag_kinds
+        g = ag.pairplot(df_multi, diag_kind="kde")
+        
+        # Test 3-level MultiIndex
+        data_3level = {
+            ("A", "X", "1"): self.rs.normal(size=50),
+            ("A", "X", "2"): self.rs.normal(size=50),
+            ("B", "Y", "1"): self.rs.normal(size=50),
+            ("B", "Y", "2"): self.rs.normal(size=50),
+        }
+        df_3level = pd.DataFrame(data_3level)
+        
+        g = ag.pairplot(df_3level)
+
     def test_corner_despine(self):
 
         g = ag.PairGrid(self.df, corner=True, despine=False)

2026-01-06 16:00:27,626 - INFO - ------------------------------
2026-01-06 16:00:27,626 - INFO - END Runtime Completion Fn
2026-01-06 16:00:27,627 - INFO - ------------------------------
2026-01-06 16:00:27,627 - INFO - Got git diff for instance mwaskom__seaborn-3407:
--------
diff --git a/debug_issue.py b/debug_issue.py
new file mode 100644
index 00000000..a8e1058e
--- /dev/null
+++ b/debug_issue.py
@@ -0,0 +1,71 @@
+#!/usr/bin/env python3
+"""
+Debug script to understand where the MultiIndex issue occurs.
+"""
+
+import numpy as np
+import pandas as pd
+import seaborn as sns
+
+def debug_pairgrid_creation():
+    """Debug the PairGrid creation process."""
+    print("Creating MultiIndex DataFrame...")
+    
+    # Create MultiIndex DataFrame
+    data = {
+        ("A", "1"): np.random.rand(10),
+        ("A", "2"): np.random.rand(10),
+        ("B", "1"): np.random.rand(10),
+        ("B", "2"): np.random.rand(10),
+    }
+    df = pd.DataFrame(data)
+    
+    print("DataFrame columns:", df.columns.tolist())
+    print("Column types:", [type(col) for col in df.columns])
+    
+    # Let's manually step through the PairGrid creation process
+    print("\n=== PairGrid Creation Debug ===")
+    
+    # Import the PairGrid class
+    from seaborn.axisgrid import PairGrid
+    
+    # Step 1: Find numeric columns
+    grid = PairGrid.__new__(PairGrid)  # Create instance without calling __init__
+    numeric_cols = grid._find_numeric_cols(df)
+    print("Numeric cols found:", numeric_cols)
+    print("Numeric col types:", [type(col) for col in numeric_cols])
+    
+    # Step 2: Create the grid (this should work)
+    try:
+        grid = PairGrid(df)
+        print("PairGrid created successfully!")
+        print("x_vars:", grid.x_vars)
+        print("y_vars:", grid.y_vars)
+        print("x_vars types:", [type(var) for var in grid.x_vars])
+        print("y_vars types:", [type(var) for var in grid.y_vars])
+        
+        # Step 3: Check what happens when we access the data
+        print("\n=== Data Access Debug ===")
+        for var in grid.x_vars:
+            print(f"Trying to access var: {var} (type: {type(var)})")
+            try:
+                vector = grid.data[var]
+                print(f"  SUCCESS: Got vector of shape {vector.shape}")
+            except Exception as e:
+                print(f"  ERROR: {e}")
+                
+        # Step 4: Check diagonal variables
+        print("\n=== Diagonal Variables Debug ===")
+        if hasattr(grid, 'diag_vars') and grid.diag_vars is not None:
+            print("diag_vars:", grid.diag_vars)
+            print("diag_vars types:", [type(var) for var in grid.diag_vars])
+        else:
+            print("diag_vars is None - need to call map_diag first")
+            
+    except Exception as e:
+        print(f"Error creating PairGrid: {e}")
+        import traceback
+        traceback.print_exc()
+
+if __name__ == "__main__":
+    debug_pairgrid_creation()
diff --git a/debug_mapdiag.py b/debug_mapdiag.py
new file mode 100644
index 00000000..7735d390
--- /dev/null
+++ b/debug_mapdiag.py
@@ -0,0 +1,83 @@
+#!/usr/bin/env python3
+"""
+Debug script to understand the map_diag issue with MultiIndex.
+"""
+
+import numpy as np
+import pandas as pd
+import seaborn as sns
+
+def debug_map_diag():
+    """Debug the map_diag process."""
+    print("Creating MultiIndex DataFrame...")
+    
+    # Create MultiIndex DataFrame
+    data = {
+        ("A", "1"): np.random.rand(10),
+        ("A", "2"): np.random.rand(10),
+        ("B", "1"): np.random.rand(10),
+        ("B", "2"): np.random.rand(10),
+    }
+    df = pd.DataFrame(data)
+    
+    print("DataFrame columns:", df.columns.tolist())
+    
+    # Import the PairGrid class
+    from seaborn.axisgrid import PairGrid
+    from seaborn.distributions import histplot
+    
+    # Create the grid
+    grid = PairGrid(df)
+    print("PairGrid created successfully!")
+    print("x_vars:", grid.x_vars)
+    print("y_vars:", grid.y_vars)
+    
+    # Now let's debug the map_diag process step by step
+    print("\n=== Debugging map_diag ===")
+    
+    # Step 1: Check the diagonal variable setup
+    print("Before map_diag - diag_vars:", getattr(grid, 'diag_vars', 'None'))
+    
+    # Let's manually step through the map_diag logic
+    print("\nStep 1: Setting up diagonal axes...")
+    if grid.diag_axes is None:
+        diag_vars = []
+        diag_axes = []
+        for i, y_var in enumerate(grid.y_vars):
+            for j, x_var in enumerate(grid.x_vars):
+                print(f"  Checking: y_var={y_var} (type: {type(y_var)}), x_var={x_var} (type: {type(x_var)})")
+                if x_var == y_var:
+                    print(f"    Match found! Adding x_var to diag_vars: {x_var}")
+                    diag_vars.append(x_var)
+                    # ... (rest of the axis setup)
+        
+        print(f"diag_vars after setup: {diag_vars}")
+        print(f"diag_vars types: {[type(var) for var in diag_vars]}")
+        
+        # This is where the issue might be - let's see what numpy does to these
+        diag_vars_array = np.array(diag_vars, np.object_)
+        print(f"diag_vars as numpy array: {diag_vars_array}")
+        print(f"diag_vars array types: {[type(var) for var in diag_vars_array]}")
+        
+        # Let's test accessing data with these variables
+        print("\nTesting data access with diag_vars:")
+        for var in diag_vars_array:
+            print(f"  Trying var: {var} (type: {type(var)})")
+            try:
+                vector = grid.data[var]
+                print(f"    SUCCESS")
+            except Exception as e:
+                print(f"    ERROR: {e}")
+    
+    # Now let's try the actual map_diag call
+    print("\n=== Calling map_diag ===")
+    try:
+        grid.map_diag(histplot)
+        print("map_diag completed successfully!")
+    except Exception as e:
+        print(f"map_diag failed: {e}")
+        import traceback
+        traceback.print_exc()
+
+if __name__ == "__main__":
+    debug_map_diag()
diff --git a/reproduce_issue.py b/reproduce_issue.py
new file mode 100644
index 00000000..6985a8ea
--- /dev/null
+++ b/reproduce_issue.py
@@ -0,0 +1,110 @@
+#!/usr/bin/env python3
+"""
+Reproduction script for the MultiIndex DataFrame pairplot KeyError issue.
+"""
+
+import numpy as np
+import pandas as pd
+import seaborn as sns
+import traceback
+
+def test_multiindex_pairplot():
+    """Test pairplot with MultiIndex DataFrame - should reproduce the KeyError."""
+    print("Testing pairplot with MultiIndex DataFrame...")
+    
+    # Create MultiIndex DataFrame as described in the issue
+    data = {
+        ("A", "1"): np.random.rand(100),
+        ("A", "2"): np.random.rand(100),
+        ("B", "1"): np.random.rand(100),
+        ("B", "2"): np.random.rand(100),
+    }
+    df = pd.DataFrame(data)
+    
+    print("DataFrame columns:", df.columns.tolist())
+    print("DataFrame shape:", df.shape)
+    print("Column names type:", type(df.columns[0]))
+    
+    try:
+        # This should raise KeyError: "['1'] not in index"
+        g = sns.pairplot(df)
+        print("SUCCESS: pairplot worked without error!")
+        return True
+    except Exception as e:
+        print(f"ERROR: {type(e).__name__}: {e}")
+        traceback.print_exc()
+        return False
+
+def test_regular_dataframe():
+    """Test pairplot with regular DataFrame - should work fine."""
+    print("\nTesting pairplot with regular DataFrame...")
+    
+    # Create regular DataFrame
+    data = {
+        "A1": np.random.rand(100),
+        "A2": np.random.rand(100),
+        "B1": np.random.rand(100),
+        "B2": np.random.rand(100),
+    }
+    df = pd.DataFrame(data)
+    
+    print("DataFrame columns:", df.columns.tolist())
+    print("DataFrame shape:", df.shape)
+    print("Column names type:", type(df.columns[0]))
+    
+    try:
+        g = sns.pairplot(df)
+        print("SUCCESS: pairplot worked without error!")
+        return True
+    except Exception as e:
+        print(f"ERROR: {type(e).__name__}: {e}")
+        traceback.print_exc()
+        return False
+
+def test_workaround():
+    """Test the workaround mentioned in the issue."""
+    print("\nTesting workaround (flattening column names)...")
+    
+    # Create MultiIndex DataFrame
+    data = {
+        ("A", "1"): np.random.rand(100),
+        ("A", "2"): np.random.rand(100),
+        ("B", "1"): np.random.rand(100),
+        ("B", "2"): np.random.rand(100),
+    }
+    df = pd.DataFrame(data)
+    
+    # Apply workaround
+    df.columns = ["".join(column) for column in df.columns]
+    
+    print("DataFrame columns after flattening:", df.columns.tolist())
+    
+    try:
+        g = sns.pairplot(df)
+        print("SUCCESS: pairplot worked with workaround!")
+        return True
+    except Exception as e:
+        print(f"ERROR: {type(e).__name__}: {e}")
+        traceback.print_exc()
+        return False
+
+if __name__ == "__main__":
+    print("=" * 60)
+    print("REPRODUCING MULTIINDEX PAIRPLOT ISSUE")
+    print("=" * 60)
+    
+    # Test regular DataFrame (should work)
+    regular_success = test_regular_dataframe()
+    
+    # Test MultiIndex DataFrame (should fail)
+    multiindex_success = test_multiindex_pairplot()
+    
+    # Test workaround (should work)
+    workaround_success = test_workaround()
+    
+    print("\n" + "=" * 60)
+    print("SUMMARY:")
+    print(f"Regular DataFrame: {'PASS' if regular_success else 'FAIL'}")
+    print(f"MultiIndex DataFrame: {'PASS' if multiindex_success else 'FAIL'}")
+    print(f"Workaround: {'PASS' if workaround_success else 'FAIL'}")
+    print("=" * 60)
diff --git a/seaborn/axisgrid.py b/seaborn/axisgrid.py
index 75349099..5eaa7997 100644
--- a/seaborn/axisgrid.py
+++ b/seaborn/axisgrid.py
@@ -1472,8 +1472,8 @@ class PairGrid(Grid):
                 for ax in diag_axes[1:]:
                     share_axis(diag_axes[0], ax, "y")
 
-            self.diag_vars = np.array(diag_vars, np.object_)
-            self.diag_axes = np.array(diag_axes, np.object_)
+            self.diag_vars = diag_vars
+            self.diag_axes = diag_axes
 
         if "hue" not in signature(func).parameters:
             return self._map_diag_iter_hue(func, **kwargs)
diff --git a/test_comprehensive.py b/test_comprehensive.py
new file mode 100644
index 00000000..e871073e
--- /dev/null
+++ b/test_comprehensive.py
@@ -0,0 +1,179 @@
+#!/usr/bin/env python3
+"""
+Comprehensive test for MultiIndex DataFrame pairplot fix.
+"""
+
+import numpy as np
+import pandas as pd
+import seaborn as sns
+import matplotlib.pyplot as plt
+
+def test_multiindex_variations():
+    """Test various MultiIndex DataFrame configurations."""
+    print("Testing various MultiIndex DataFrame configurations...")
+    
+    test_cases = [
+        # 2-level MultiIndex
+        {
+            "name": "2-level MultiIndex",
+            "data": {
+                ("A", "1"): np.random.rand(20),
+                ("A", "2"): np.random.rand(20),
+                ("B", "1"): np.random.rand(20),
+                ("B", "2"): np.random.rand(20),
+            }
+        },
+        # 3-level MultiIndex
+        {
+            "name": "3-level MultiIndex",
+            "data": {
+                ("A", "X", "1"): np.random.rand(20),
+                ("A", "X", "2"): np.random.rand(20),
+                ("B", "Y", "1"): np.random.rand(20),
+                ("B", "Y", "2"): np.random.rand(20),
+            }
+        },
+        # Mixed types in MultiIndex
+        {
+            "name": "Mixed types MultiIndex",
+            "data": {
+                ("A", 1): np.random.rand(20),
+                ("A", 2): np.random.rand(20),
+                ("B", 1): np.random.rand(20),
+                ("B", 2): np.random.rand(20),
+            }
+        },
+        # Single level MultiIndex (edge case)
+        {
+            "name": "Single level MultiIndex",
+            "data": {
+                ("A",): np.random.rand(20),
+                ("B",): np.random.rand(20),
+                ("C",): np.random.rand(20),
+            }
+        }
+    ]
+    
+    results = []
+    
+    for test_case in test_cases:
+        print(f"\n--- Testing {test_case['name']} ---")
+        df = pd.DataFrame(test_case["data"])
+        print(f"Columns: {df.columns.tolist()}")
+        
+        try:
+            # Test basic pairplot
+            g = sns.pairplot(df)
+            print(f"âœ“ Basic pairplot successful")
+            
+            # Test with different diag_kinds
+            for diag_kind in ["hist", "kde"]:
+                try:
+                    g = sns.pairplot(df, diag_kind=diag_kind)
+                    print(f"âœ“ pairplot with diag_kind='{diag_kind}' successful")
+                except Exception as e:
+                    print(f"âœ— pairplot with diag_kind='{diag_kind}' failed: {e}")
+                    results.append(False)
+                    continue
+            
+            # Test with hue parameter (if we have enough columns)
+            if len(df.columns) > 2:
+                try:
+                    # Add a categorical column for hue
+                    df_with_hue = df.copy()
+                    df_with_hue[("hue", "col")] = np.random.choice(['A', 'B'], size=len(df))
+                    g = sns.pairplot(df_with_hue, hue=("hue", "col"))
+                    print(f"âœ“ pairplot with hue successful")
+                except Exception as e:
+                    print(f"âœ— pairplot with hue failed: {e}")
+                    results.append(False)
+                    continue
+            
+            results.append(True)
+            print(f"âœ“ {test_case['name']} PASSED")
+            
+        except Exception as e:
+            print(f"âœ— {test_case['name']} FAILED: {e}")
+            results.append(False)
+        
+        plt.close('all')  # Clean up plots
+    
+    return results
+
+def test_backward_compatibility():
+    """Test that regular DataFrames still work."""
+    print("\n" + "="*50)
+    print("Testing backward compatibility with regular DataFrames...")
+    
+    test_cases = [
+        {
+            "name": "String columns",
+            "data": {
+                "A1": np.random.rand(20),
+                "A2": np.random.rand(20),
+                "B1": np.random.rand(20),
+                "B2": np.random.rand(20),
+            }
+        },
+        {
+            "name": "Integer columns",
+            "data": {
+                1: np.random.rand(20),
+                2: np.random.rand(20),
+                3: np.random.rand(20),
+                4: np.random.rand(20),
+            }
+        },
+        {
+            "name": "Mixed columns",
+            "data": {
+                "A": np.random.rand(20),
+                1: np.random.rand(20),
+                "B": np.random.rand(20),
+                2: np.random.rand(20),
+            }
+        }
+    ]
+    
+    results = []
+    
+    for test_case in test_cases:
+        print(f"\n--- Testing {test_case['name']} ---")
+        df = pd.DataFrame(test_case["data"])
+        print(f"Columns: {df.columns.tolist()}")
+        
+        try:
+            g = sns.pairplot(df)
+            print(f"âœ“ {test_case['name']} PASSED")
+            results.append(True)
+        except Exception as e:
+            print(f"âœ— {test_case['name']} FAILED: {e}")
+            results.append(False)
+        
+        plt.close('all')  # Clean up plots
+    
+    return results
+
+if __name__ == "__main__":
+    print("=" * 60)
+    print("COMPREHENSIVE MULTIINDEX PAIRPLOT TESTING")
+    print("=" * 60)
+    
+    # Test MultiIndex variations
+    multiindex_results = test_multiindex_variations()
+    
+    # Test backward compatibility
+    backward_compat_results = test_backward_compatibility()
+    
+    # Summary
+    print("\n" + "=" * 60)
+    print("SUMMARY:")
+    print(f"MultiIndex tests: {sum(multiindex_results)}/{len(multiindex_results)} passed")
+    print(f"Backward compatibility tests: {sum(backward_compat_results)}/{len(backward_compat_results)} passed")
+    print(f"Total: {sum(multiindex_results + backward_compat_results)}/{len(multiindex_results + backward_compat_results)} passed")
+    
+    if all(multiindex_results + backward_compat_results):
+        print("ðŸŽ‰ ALL TESTS PASSED!")
+    else:
+        print("âŒ Some tests failed!")
+    print("=" * 60)
diff --git a/tests/test_axisgrid.py b/tests/test_axisgrid.py
index ce8b0eaa..3efaf6eb 100644
--- a/tests/test_axisgrid.py
+++ b/tests/test_axisgrid.py
@@ -1422,6 +1422,34 @@ class TestPairGrid:
         with pytest.warns(UserWarning):
             g = ag.pairplot(self.df, hue="a", vars=vars, markers=markers[:-2])
 
+    def test_pairplot_multiindex(self):
+        """Test that pairplot works with MultiIndex DataFrames."""
+        # Create MultiIndex DataFrame
+        data = {
+            ("A", "1"): self.rs.normal(size=50),
+            ("A", "2"): self.rs.normal(size=50),
+            ("B", "1"): self.rs.normal(size=50),
+            ("B", "2"): self.rs.normal(size=50),
+        }
+        df_multi = pd.DataFrame(data)
+        
+        # This should not raise a KeyError
+        g = ag.pairplot(df_multi)
+        
+        # Test with different diag_kinds
+        g = ag.pairplot(df_multi, diag_kind="kde")
+        
+        # Test 3-level MultiIndex
+        data_3level = {
+            ("A", "X", "1"): self.rs.normal(size=50),
+            ("A", "X", "2"): self.rs.normal(size=50),
+            ("B", "Y", "1"): self.rs.normal(size=50),
+            ("B", "Y", "2"): self.rs.normal(size=50),
+        }
+        df_3level = pd.DataFrame(data_3level)
+        
+        g = ag.pairplot(df_3level)
+
     def test_corner_despine(self):
 
         g = ag.PairGrid(self.df, corner=True, despine=False)
--------
2026-01-06 16:00:29,044 - INFO - Using instance container image: docker.io/swebench/sweb.eval.x86_64.pytest-dev_1776_pytest-7168:latest. Please make sure this image exists. Submit an issue on https://github.com/OpenHands/OpenHands if you run into any issues.
2026-01-06 16:00:29,044 - INFO - Resource mapping for princeton-nlp__SWE-bench_Lite-test not found.
2026-01-06 16:00:29,045 - INFO - Logging LLM completions for instance pytest-dev__pytest-7168 to ./continuum32/princeton-nlp__SWE-bench_Lite-test/CodeActAgent/GLM-4.6-FP8_maxiter_135/llm_completions/pytest-dev__pytest-7168
2026-01-06 16:00:29,045 - INFO - Config file not found: config.toml. Error: [Errno 2] No such file or directory: 'config.toml'
2026-01-06 16:00:29,045 - INFO - Config file not found: [Errno 2] No such file or directory: 'config.toml'. Toml values have not been applied.
