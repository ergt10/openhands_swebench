2026-01-06 14:43:15,419 - INFO - [LLM registry 4d14f31a-165e-4889-b188-701f9c23adea]: Registering service for agent
2026-01-06 14:43:15,462 - INFO - Building image: ghcr.io/openhands/runtime:oh_v1.0.0_8wcge8w38p7cfyqu_v008aov5t6vw3gr5
2026-01-06 14:55:27,214 - INFO - Image [ghcr.io/openhands/runtime:oh_v1.0.0_8wcge8w38p7cfyqu_v008aov5t6vw3gr5] build finished.
2026-01-06 14:55:27,222 - INFO - Re-tagged image [ghcr.io/openhands/runtime:oh_v1.0.0_8wcge8w38p7cfyqu_v008aov5t6vw3gr5] with more generic tag [oh_v1.0.0_8wcge8w38p7cfyqu]
2026-01-06 14:55:27,224 - INFO - Image ghcr.io/openhands/runtime with tags [oh_v1.0.0_8wcge8w38p7cfyqu_v008aov5t6vw3gr5, oh_v1.0.0_8wcge8w38p7cfyqu] built successfully
2026-01-06 14:55:27,268 - INFO - [runtime 990746d4-a06e-4f-5c408cc97d56de7] Starting runtime with image: ghcr.io/openhands/runtime:oh_v1.0.0_8wcge8w38p7cfyqu_v008aov5t6vw3gr5
2026-01-06 14:55:27,367 - INFO - [runtime 990746d4-a06e-4f-5c408cc97d56de7] Starting server with command: ['/openhands/micromamba/bin/micromamba', 'run', '-n', 'openhands', 'poetry', 'run', 'python', '-u', '-m', 'openhands.runtime.action_execution_server', '36450', '--working-dir', '/workspace', '--plugins', 'agent_skills', 'jupyter', '--username', 'root', '--user-id', '0', '--no-enable-browser']
2026-01-06 14:55:27,911 - INFO - [runtime 990746d4-a06e-4f-5c408cc97d56de7] Container started: openhands-runtime-990746d4-a06e-4f-5c408cc97d56de7. VSCode URL: None
2026-01-06 14:55:27,911 - INFO - [runtime 990746d4-a06e-4f-5c408cc97d56de7] Waiting for client to become ready at http://localhost:36450...
2026-01-06 14:56:00,224 - INFO - [runtime 990746d4-a06e-4f-5c408cc97d56de7] Runtime is ready.
2026-01-06 14:56:03,349 - INFO - Successfully configured git: name=openhands, email=openhands@all-hands.dev
2026-01-06 14:56:03,351 - INFO - ------------------------------
2026-01-06 14:56:03,351 - INFO - BEGIN Runtime Initialization Fn
2026-01-06 14:56:03,352 - INFO - ------------------------------
2026-01-06 14:56:03,352 - INFO - **CmdRunAction (source=None, is_input=False)**
COMMAND:
echo 'export SWE_INSTANCE_ID=django__django-13230' >> ~/.bashrc && echo 'export PIP_CACHE_DIR=~/.cache/pip' >> ~/.bashrc && echo "alias git='git --no-pager'" >> ~/.bashrc && git config --global core.pager "" && git config --global diff.binary false
2026-01-06 14:56:03,978 - INFO - **CmdOutputObservation (source=None, exit code=0, metadata={
  "exit_code": 0,
  "pid": -1,
  "username": "root",
  "hostname": "8dc3d4c1062a",
  "working_dir": "/workspace",
  "py_interpreter_path": "/openhands/micromamba/envs/openhands/bin/python",
  "prefix": "",
  "suffix": "\n[The command completed with exit code 0.]"
})**
--BEGIN AGENT OBSERVATION--

[The command completed with exit code 0.]
[Current working directory: /workspace]
[Python interpreter: /openhands/micromamba/envs/openhands/bin/python]
[Command finished with exit code 0]
--END AGENT OBSERVATION--
2026-01-06 14:56:03,978 - INFO - **CmdRunAction (source=None, is_input=False)**
COMMAND:
export USER=$(whoami); echo USER=${USER} 
2026-01-06 14:56:04,597 - INFO - **CmdOutputObservation (source=None, exit code=0, metadata={
  "exit_code": 0,
  "pid": -1,
  "username": "root",
  "hostname": "8dc3d4c1062a",
  "working_dir": "/workspace",
  "py_interpreter_path": "/openhands/micromamba/envs/openhands/bin/python",
  "prefix": "",
  "suffix": "\n[The command completed with exit code 0.]"
})**
--BEGIN AGENT OBSERVATION--
USER=root
[The command completed with exit code 0.]
[Current working directory: /workspace]
[Python interpreter: /openhands/micromamba/envs/openhands/bin/python]
[Command finished with exit code 0]
--END AGENT OBSERVATION--
2026-01-06 14:56:04,598 - INFO - **CmdRunAction (source=None, is_input=False)**
COMMAND:
mkdir -p /swe_util/eval_data/instances
2026-01-06 14:56:05,217 - INFO - **CmdOutputObservation (source=None, exit code=0, metadata={
  "exit_code": 0,
  "pid": -1,
  "username": "root",
  "hostname": "8dc3d4c1062a",
  "working_dir": "/workspace",
  "py_interpreter_path": "/openhands/micromamba/envs/openhands/bin/python",
  "prefix": "",
  "suffix": "\n[The command completed with exit code 0.]"
})**
--BEGIN AGENT OBSERVATION--

[The command completed with exit code 0.]
[Current working directory: /workspace]
[Python interpreter: /openhands/micromamba/envs/openhands/bin/python]
[Command finished with exit code 0]
--END AGENT OBSERVATION--
2026-01-06 14:56:05,227 - INFO - **CmdRunAction (source=None, is_input=False)**
COMMAND:
cat ~/.bashrc
2026-01-06 14:56:05,849 - INFO - **CmdOutputObservation (source=None, exit code=0, metadata={
  "exit_code": 0,
  "pid": -1,
  "username": "root",
  "hostname": "8dc3d4c1062a",
  "working_dir": "/workspace",
  "py_interpreter_path": "/openhands/micromamba/envs/openhands/bin/python",
  "prefix": "",
  "suffix": "\n[The command completed with exit code 0.]"
})**
--BEGIN AGENT OBSERVATION--
source /opt/miniconda3/etc/profile.d/conda.sh && conda activate testbed

. "/openhands/bin/env"
export PATH="/usr/bin:/bin:/usr/sbin:/sbin:/openhands/micromamba/bin:$PATH"
export PLAYWRIGHT_BROWSERS_PATH=/opt/playwright-browsers
eval "$(/openhands/micromamba/bin/micromamba shell hook --shell bash)"
micromamba activate openhands 2>/dev/null || true
export ENABLE_AUTO_LINT=true
export NO_CHANGE_TIMEOUT_SECONDS=30
export OPENHANDS_EVAL_INSTANCE_ID=django__django-13230
export OPENHANDS_EVAL_JOB_ID=1801270245
export OPENHANDS_TIMING_DIR=./continuum32/princeton-nlp__SWE-bench_Lite-test/CodeActAgent/GLM-4.6-FP8_maxiter_135/timing
export SWE_INSTANCE_ID=django__django-13230
export PIP_CACHE_DIR=~/.cache/pip
alias git='git --no-pager'
[The command completed with exit code 0.]
[Current working directory: /workspace]
[Python interpreter: /openhands/micromamba/envs/openhands/bin/python]
[Command finished with exit code 0]
--END AGENT OBSERVATION--
2026-01-06 14:56:05,851 - INFO - **CmdRunAction (source=None, is_input=False)**
COMMAND:
source ~/.bashrc
2026-01-06 14:56:06,472 - INFO - **CmdOutputObservation (source=None, exit code=0, metadata={
  "exit_code": 0,
  "pid": -1,
  "username": "root",
  "hostname": "8dc3d4c1062a",
  "working_dir": "/workspace",
  "py_interpreter_path": "/openhands/micromamba/envs/openhands/bin/python",
  "prefix": "",
  "suffix": "\n[The command completed with exit code 0.]"
})**
--BEGIN AGENT OBSERVATION--

[The command completed with exit code 0.]
[Current working directory: /workspace]
[Python interpreter: /openhands/micromamba/envs/openhands/bin/python]
[Command finished with exit code 0]
--END AGENT OBSERVATION--
2026-01-06 14:56:06,472 - INFO - **CmdRunAction (source=None, is_input=False)**
COMMAND:
source /swe_util/instance_swe_entry.sh
2026-01-06 14:56:11,114 - INFO - **CmdOutputObservation (source=None, exit code=0, metadata={
  "exit_code": 0,
  "pid": -1,
  "username": "root",
  "hostname": "8dc3d4c1062a",
  "working_dir": "/workspace",
  "py_interpreter_path": "/opt/miniconda3/envs/testbed/bin/python",
  "prefix": "",
  "suffix": "\n[The command completed with exit code 0.]"
})**
--BEGIN AGENT OBSERVATION--
WORKSPACE_NAME: django__django__3.2
[The command completed with exit code 0.]
[Current working directory: /workspace]
[Python interpreter: /opt/miniconda3/envs/testbed/bin/python]
[Command finished with exit code 0]
--END AGENT OBSERVATION--
2026-01-06 14:56:11,114 - INFO - **CmdRunAction (source=None, is_input=False)**
COMMAND:
cd /workspace/django__django__3.2
2026-01-06 14:56:11,738 - INFO - **CmdOutputObservation (source=None, exit code=0, metadata={
  "exit_code": 0,
  "pid": -1,
  "username": "root",
  "hostname": "8dc3d4c1062a",
  "working_dir": "/workspace/django__django__3.2",
  "py_interpreter_path": "/opt/miniconda3/envs/testbed/bin/python",
  "prefix": "",
  "suffix": "\n[The command completed with exit code 0.]"
})**
--BEGIN AGENT OBSERVATION--

[The command completed with exit code 0.]
[Current working directory: /workspace/django__django__3.2]
[Python interpreter: /opt/miniconda3/envs/testbed/bin/python]
[Command finished with exit code 0]
--END AGENT OBSERVATION--
2026-01-06 14:56:11,739 - INFO - **CmdRunAction (source=None, is_input=False)**
COMMAND:
git reset --hard
2026-01-06 14:56:13,369 - INFO - **CmdOutputObservation (source=None, exit code=0, metadata={
  "exit_code": 0,
  "pid": -1,
  "username": "root",
  "hostname": "8dc3d4c1062a",
  "working_dir": "/workspace/django__django__3.2",
  "py_interpreter_path": "/opt/miniconda3/envs/testbed/bin/python",
  "prefix": "",
  "suffix": "\n[The command completed with exit code 0.]"
})**
--BEGIN AGENT OBSERVATION--
Updating files: 100% (6290/6290), done.
HEAD is now at 184a6eebb0 Refs #31829 -- Added DatabaseFeatures.json_key_contains_list_matching_requires_list.
[The command completed with exit code 0.]
[Current working directory: /workspace/django__django__3.2]
[Python interpreter: /opt/miniconda3/envs/testbed/bin/python]
[Command finished with exit code 0]
--END AGENT OBSERVATION--
2026-01-06 14:56:13,369 - INFO - **CmdRunAction (source=None, is_input=False)**
COMMAND:
for remote_name in $(git remote); do git remote remove "${remote_name}"; done
2026-01-06 14:56:13,995 - INFO - **CmdOutputObservation (source=None, exit code=0, metadata={
  "exit_code": 0,
  "pid": -1,
  "username": "root",
  "hostname": "8dc3d4c1062a",
  "working_dir": "/workspace/django__django__3.2",
  "py_interpreter_path": "/opt/miniconda3/envs/testbed/bin/python",
  "prefix": "",
  "suffix": "\n[The command completed with exit code 0.]"
})**
--BEGIN AGENT OBSERVATION--

[The command completed with exit code 0.]
[Current working directory: /workspace/django__django__3.2]
[Python interpreter: /opt/miniconda3/envs/testbed/bin/python]
[Command finished with exit code 0]
--END AGENT OBSERVATION--
2026-01-06 14:56:13,996 - INFO - **CmdRunAction (source=None, is_input=False)**
COMMAND:
which python
2026-01-06 14:56:14,615 - INFO - **CmdOutputObservation (source=None, exit code=0, metadata={
  "exit_code": 0,
  "pid": -1,
  "username": "root",
  "hostname": "8dc3d4c1062a",
  "working_dir": "/workspace/django__django__3.2",
  "py_interpreter_path": "/opt/miniconda3/envs/testbed/bin/python",
  "prefix": "",
  "suffix": "\n[The command completed with exit code 0.]"
})**
--BEGIN AGENT OBSERVATION--
/opt/miniconda3/envs/testbed/bin/python
[The command completed with exit code 0.]
[Current working directory: /workspace/django__django__3.2]
[Python interpreter: /opt/miniconda3/envs/testbed/bin/python]
[Command finished with exit code 0]
--END AGENT OBSERVATION--
2026-01-06 14:56:14,615 - INFO - ------------------------------
2026-01-06 14:56:14,616 - INFO - END Runtime Initialization Fn
2026-01-06 14:56:14,616 - INFO - ------------------------------
2026-01-06 14:56:14,619 - INFO - [LLM registry 8b8c0063-c056-47fb-a604-ae10196c3024]: Registering service for agent
2026-01-06 14:56:14,634 - INFO - [runtime 990746d4-a06e-4f-5c408cc97d56de7] Selected repo: None, loading microagents from /workspace/.openhands/microagents (inside runtime)
2026-01-06 14:56:14,637 - INFO - [runtime 990746d4-a06e-4f-5c408cc97d56de7] Attempting to list files in repository microagents directory: /workspace/.openhands/microagents
2026-01-06 14:56:14,640 - INFO - Loading user workspace microagents: []
2026-01-06 14:56:14,640 - INFO - AgentController 990746d4-a06e-4f-5c408cc97d56de7 - created new state. start_id: 0
2026-01-06 14:56:14,646 - INFO - [Agent Controller 990746d4-a06e-4f-5c408cc97d56de7] Setting agent(CodeActAgent) state from AgentState.LOADING to AgentState.RUNNING
2026-01-06 14:56:14,647 - INFO - Saved conversation stats
2026-01-06 15:07:08,782 - INFO - [Agent Controller 990746d4-a06e-4f-5c408cc97d56de7] Setting agent(CodeActAgent) state from AgentState.RUNNING to AgentState.FINISHED
2026-01-06 15:07:08,783 - INFO - Saved conversation stats
2026-01-06 15:07:09,402 - INFO - ------------------------------
2026-01-06 15:07:09,402 - INFO - BEGIN Runtime Completion Fn
2026-01-06 15:07:09,402 - INFO - ------------------------------
2026-01-06 15:07:09,402 - INFO - **CmdRunAction (source=None, is_input=False)**
COMMAND:
cd /workspace/django__django__3.2
2026-01-06 15:07:10,024 - INFO - **CmdOutputObservation (source=None, exit code=0, metadata={
  "exit_code": 0,
  "pid": -1,
  "username": "root",
  "hostname": "8dc3d4c1062a",
  "working_dir": "/workspace/django__django__3.2",
  "py_interpreter_path": "/opt/miniconda3/envs/testbed/bin/python",
  "prefix": "",
  "suffix": "\n[The command completed with exit code 0.]"
})**
--BEGIN AGENT OBSERVATION--

[The command completed with exit code 0.]
[Current working directory: /workspace/django__django__3.2]
[Python interpreter: /opt/miniconda3/envs/testbed/bin/python]
[Command finished with exit code 0]
--END AGENT OBSERVATION--
2026-01-06 15:07:10,024 - INFO - **CmdRunAction (source=None, is_input=False)**
COMMAND:
git config --global core.pager ""
2026-01-06 15:07:10,643 - INFO - **CmdOutputObservation (source=None, exit code=0, metadata={
  "exit_code": 0,
  "pid": -1,
  "username": "root",
  "hostname": "8dc3d4c1062a",
  "working_dir": "/workspace/django__django__3.2",
  "py_interpreter_path": "/opt/miniconda3/envs/testbed/bin/python",
  "prefix": "",
  "suffix": "\n[The command completed with exit code 0.]"
})**
--BEGIN AGENT OBSERVATION--

[The command completed with exit code 0.]
[Current working directory: /workspace/django__django__3.2]
[Python interpreter: /opt/miniconda3/envs/testbed/bin/python]
[Command finished with exit code 0]
--END AGENT OBSERVATION--
2026-01-06 15:07:10,643 - INFO - **CmdRunAction (source=None, is_input=False)**
COMMAND:
find . -type d -name .git -not -path "./.git"
2026-01-06 15:07:11,263 - INFO - **CmdOutputObservation (source=None, exit code=0, metadata={
  "exit_code": 0,
  "pid": -1,
  "username": "root",
  "hostname": "8dc3d4c1062a",
  "working_dir": "/workspace/django__django__3.2",
  "py_interpreter_path": "/opt/miniconda3/envs/testbed/bin/python",
  "prefix": "",
  "suffix": "\n[The command completed with exit code 0.]"
})**
--BEGIN AGENT OBSERVATION--

[The command completed with exit code 0.]
[Current working directory: /workspace/django__django__3.2]
[Python interpreter: /opt/miniconda3/envs/testbed/bin/python]
[Command finished with exit code 0]
--END AGENT OBSERVATION--
2026-01-06 15:07:11,263 - INFO - **CmdRunAction (source=None, is_input=False)**
COMMAND:
git add -A
2026-01-06 15:07:11,881 - INFO - **CmdOutputObservation (source=None, exit code=0, metadata={
  "exit_code": 0,
  "pid": -1,
  "username": "root",
  "hostname": "8dc3d4c1062a",
  "working_dir": "/workspace/django__django__3.2",
  "py_interpreter_path": "/opt/miniconda3/envs/testbed/bin/python",
  "prefix": "",
  "suffix": "\n[The command completed with exit code 0.]"
})**
--BEGIN AGENT OBSERVATION--

[The command completed with exit code 0.]
[Current working directory: /workspace/django__django__3.2]
[Python interpreter: /opt/miniconda3/envs/testbed/bin/python]
[Command finished with exit code 0]
--END AGENT OBSERVATION--
2026-01-06 15:07:11,881 - INFO - **CmdRunAction (source=None, is_input=False)**
COMMAND:
for file in $(git status --porcelain | grep -E "^(M| M|\?\?|A| A)" | cut -c4-); do
        if [ -f "$file" ] && (file "$file" | grep -q "executable" || git check-attr binary "$file" | grep -q "binary: set"); then
            git rm -f "$file" 2>/dev/null || rm -f "$file"
            echo "Removed: $file"
        fi
    done
2026-01-06 15:07:12,505 - INFO - **CmdOutputObservation (source=None, exit code=0, metadata={
  "exit_code": 0,
  "pid": -1,
  "username": "root",
  "hostname": "8dc3d4c1062a",
  "working_dir": "/workspace/django__django__3.2",
  "py_interpreter_path": "/opt/miniconda3/envs/testbed/bin/python",
  "prefix": "",
  "suffix": "\n[The command completed with exit code 0.]"
})**
--BEGIN AGENT OBSERVATION--
bash: file: command not found
bash: file: command not found
bash: file: command not found
bash: file: command not found
[The command completed with exit code 0.]
[Current working directory: /workspace/django__django__3.2]
[Python interpreter: /opt/miniconda3/envs/testbed/bin/python]
[Command finished with exit code 0]
--END AGENT OBSERVATION--
2026-01-06 15:07:12,505 - INFO - **CmdRunAction (source=None, is_input=False)**
COMMAND:
git diff --no-color --cached 184a6eebb0ef56d5f1b1315a8e666830e37f3f81 > patch.diff
2026-01-06 15:07:13,126 - INFO - **CmdOutputObservation (source=None, exit code=0, metadata={
  "exit_code": 0,
  "pid": -1,
  "username": "root",
  "hostname": "8dc3d4c1062a",
  "working_dir": "/workspace/django__django__3.2",
  "py_interpreter_path": "/opt/miniconda3/envs/testbed/bin/python",
  "prefix": "",
  "suffix": "\n[The command completed with exit code 0.]"
})**
--BEGIN AGENT OBSERVATION--

[The command completed with exit code 0.]
[Current working directory: /workspace/django__django__3.2]
[Python interpreter: /opt/miniconda3/envs/testbed/bin/python]
[Command finished with exit code 0]
--END AGENT OBSERVATION--
2026-01-06 15:07:13,126 - INFO - FileReadAction(path='patch.diff', start=0, end=-1, thought='', action=<ActionType.READ: 'read'>, security_risk=<ActionSecurityRisk.UNKNOWN: -1>, impl_source=<FileReadSource.DEFAULT: 'default'>, view_range=None)
2026-01-06 15:07:13,130 - INFO - [Read from /workspace/django__django__3.2/patch.diff is successful.]
diff --git a/django/contrib/syndication/views.py b/django/contrib/syndication/views.py
index 68ffb0bfe0..6f1d2e6647 100644
--- a/django/contrib/syndication/views.py
+++ b/django/contrib/syndication/views.py
@@ -199,6 +199,11 @@ class Feed:
             if updateddate and is_naive(updateddate):
                 updateddate = make_aware(updateddate, tz)
 
+            extra_kwargs = self.item_extra_kwargs(item)
+            comments = self._get_dynamic_attr('item_comments', item)
+            if comments is not None and 'comments' not in extra_kwargs:
+                extra_kwargs['comments'] = comments
+            
             feed.add_item(
                 title=title,
                 link=link,
@@ -214,6 +219,6 @@ class Feed:
                 author_link=author_link,
                 categories=self._get_dynamic_attr('item_categories', item),
                 item_copyright=self._get_dynamic_attr('item_copyright', item),
-                **self.item_extra_kwargs(item)
+                **extra_kwargs
             )
         return feed
diff --git a/test_atom_comments.py b/test_atom_comments.py
new file mode 100644
index 0000000000..b63069fee5
--- /dev/null
+++ b/test_atom_comments.py
@@ -0,0 +1,131 @@
+#!/usr/bin/env python
+"""
+Test that item_comments works with Atom feeds as well.
+"""
+import os
+import sys
+import django
+from django.conf import settings
+from django.contrib.syndication import views
+from django.utils import feedgenerator
+from xml.dom import minidom
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+            'django.contrib.sites',
+            'django.contrib.syndication',
+        ],
+        SECRET_KEY='test-secret-key',
+        SITE_ID=1,
+        USE_TZ=True,
+    )
+    django.setup()
+    
+    # Create the database tables
+    from django.core.management import call_command
+    call_command('migrate', verbosity=0, interactive=False)
+
+# Create a mock item class
+class MockItem:
+    def __init__(self, title, link, description, comments_url):
+        self.title = title
+        self.link = link
+        self.description = description
+        self.comments_url = comments_url
+    
+    def get_absolute_url(self):
+        return self.link
+
+# Test Atom feed with item_comments
+class TestAtomCommentsFeed(views.Feed):
+    title = 'Test Atom Feed with Comments'
+    link = '/test/'
+    description = 'A test Atom feed that includes comments'
+    feed_type = feedgenerator.Atom1Feed
+    
+    def items(self):
+        return [
+            MockItem(
+                title='Test Item 1',
+                link='/item/1/',
+                description='First test item',
+                comments_url='/comments/1/'
+            )
+        ]
+    
+    def item_comments(self, item):
+        return item.comments_url
+
+def test_atom_feed_comments():
+    """Test that Atom feeds handle comments correctly."""
+    print("\n=== Testing Atom Feed with Comments ===")
+    
+    # Create a mock request
+    class MockRequest:
+        def is_secure(self):
+            return False
+        def get_host(self):
+            return 'example.com'
+        path = '/test/'
+    
+    request = MockRequest()
+    feed = TestAtomCommentsFeed()
+    
+    try:
+        # Get the feed
+        feed_obj = feed.get_feed(None, request)
+        
+        # Generate Atom XML
+        output = feed_obj.writeString('utf-8')
+        
+        print("Generated Atom XML (first 500 chars):")
+        print(output[:500] + "..." if len(output) > 500 else output)
+        
+        # Parse XML to check structure
+        doc = minidom.parseString(output)
+        
+        # Check if it's a valid Atom feed
+        feed_elements = doc.getElementsByTagName('feed')
+        if feed_elements:
+            print("✓ Valid Atom feed structure")
+        
+        # Check for entries
+        entry_elements = doc.getElementsByTagName('entry')
+        print(f"Number of <entry> elements: {len(entry_elements)}")
+        
+        # Note: Atom doesn't have a standard <comments> element like RSS
+        # The comments would need to be handled via a custom extension or link element
+        print("✓ Atom feed generated successfully (comments passed to feedgenerator)")
+        return True
+            
+    except Exception as e:
+        print(f"✗ ERROR: {e}")
+        import traceback
+        traceback.print_exc()
+        return False
+
+def main():
+    print("Testing Django syndication framework with Atom feeds and comments")
+    print("=" * 60)
+    
+    success = test_atom_feed_comments()
+    
+    print("\n" + "=" * 60)
+    if success:
+        print("✓ Atom feed test passed!")
+    else:
+        print("✗ Atom feed test failed.")
+
+if __name__ == '__main__':
+    main()
diff --git a/test_comments_edge_cases.py b/test_comments_edge_cases.py
new file mode 100644
index 0000000000..81843e3c16
--- /dev/null
+++ b/test_comments_edge_cases.py
@@ -0,0 +1,204 @@
+#!/usr/bin/env python
+"""
+Test edge cases for item_comments support in Django syndication framework.
+"""
+import os
+import sys
+import django
+from django.conf import settings
+from django.contrib.syndication import views
+from django.utils import feedgenerator
+from xml.dom import minidom
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+            'django.contrib.sites',
+            'django.contrib.syndication',
+        ],
+        SECRET_KEY='test-secret-key',
+        SITE_ID=1,
+        USE_TZ=True,
+    )
+    django.setup()
+    
+    # Create the database tables
+    from django.core.management import call_command
+    call_command('migrate', verbosity=0, interactive=False)
+
+# Create a mock item class
+class MockItem:
+    def __init__(self, title, link, description, comments_url=None):
+        self.title = title
+        self.link = link
+        self.description = description
+        self.comments_url = comments_url
+    
+    def get_absolute_url(self):
+        return self.link
+
+# Test feed with item_comments returning None
+class TestCommentsNoneFeed(views.Feed):
+    title = 'Test Feed with None Comments'
+    link = '/test/'
+    description = 'A test feed where item_comments returns None'
+    
+    def items(self):
+        return [
+            MockItem(
+                title='Test Item 1',
+                link='/item/1/',
+                description='First test item',
+                comments_url=None
+            )
+        ]
+    
+    def item_comments(self, item):
+        return None
+
+# Test feed with both item_comments and item_extra_kwargs returning comments
+class TestCommentsConflictFeed(views.Feed):
+    title = 'Test Feed with Comments Conflict'
+    link = '/test/'
+    description = 'A test feed where both item_comments and item_extra_kwargs return comments'
+    
+    def items(self):
+        return [
+            MockItem(
+                title='Test Item 1',
+                link='/item/1/',
+                description='First test item',
+                comments_url='/comments/1/'
+            )
+        ]
+    
+    def item_comments(self, item):
+        return '/comments/from-method/'
+    
+    def item_extra_kwargs(self, item):
+        return {'comments': '/comments/from-extra-kwargs/'}
+
+# Test feed with item_comments returning empty string
+class TestCommentsEmptyFeed(views.Feed):
+    title = 'Test Feed with Empty Comments'
+    link = '/test/'
+    description = 'A test feed where item_comments returns empty string'
+    
+    def items(self):
+        return [
+            MockItem(
+                title='Test Item 1',
+                link='/item/1/',
+                description='First test item'
+            )
+        ]
+    
+    def item_comments(self, item):
+        return ''
+
+# Test feed without item_comments method
+class TestNoCommentsFeed(views.Feed):
+    title = 'Test Feed without Comments'
+    link = '/test/'
+    description = 'A test feed without item_comments method'
+    
+    def items(self):
+        return [
+            MockItem(
+                title='Test Item 1',
+                link='/item/1/',
+                description='First test item'
+            )
+        ]
+
+def test_feed_comments(feed_class, test_name, expected_comments=None):
+    """Test a feed class and check if comments are included in the RSS output."""
+    print(f"\n=== Testing {test_name} ===")
+    
+    # Create a mock request
+    class MockRequest:
+        def is_secure(self):
+            return False
+        def get_host(self):
+            return 'example.com'
+        path = '/test/'
+    
+    request = MockRequest()
+    feed = feed_class()
+    
+    try:
+        # Get the feed
+        feed_obj = feed.get_feed(None, request)
+        
+        # Generate RSS XML
+        output = feed_obj.writeString('utf-8')
+        
+        # Parse XML to check for comments elements
+        doc = minidom.parseString(output)
+        comments_elements = doc.getElementsByTagName('comments')
+        
+        print(f"Number of <comments> elements found: {len(comments_elements)}")
+        
+        if comments_elements:
+            for i, elem in enumerate(comments_elements):
+                content = elem.firstChild.nodeValue if elem.firstChild else "None"
+                print(f"  Comment {i+1}: '{content}'")
+        
+        # Check expectations
+        if expected_comments is None:
+            # Expect no comments
+            if len(comments_elements) == 0:
+                print("✓ SUCCESS: No comments as expected")
+                return True
+            else:
+                print("✗ FAILURE: Unexpected comments found")
+                return False
+        else:
+            # Expect specific number of comments
+            if len(comments_elements) == expected_comments:
+                print(f"✓ SUCCESS: Found expected {expected_comments} comment(s)")
+                return True
+            else:
+                print(f"✗ FAILURE: Expected {expected_comments} comments, found {len(comments_elements)}")
+                return False
+            
+    except Exception as e:
+        print(f"✗ ERROR: {e}")
+        import traceback
+        traceback.print_exc()
+        return False
+
+def main():
+    print("Testing Django syndication framework comments edge cases")
+    print("=" * 60)
+    
+    # Test various edge cases
+    test1 = test_feed_comments(TestCommentsNoneFeed, "item_comments returns None", expected_comments=0)
+    test2 = test_feed_comments(TestCommentsConflictFeed, "Both item_comments and item_extra_kwargs return comments", expected_comments=1)
+    test3 = test_feed_comments(TestCommentsEmptyFeed, "item_comments returns empty string", expected_comments=1)
+    test4 = test_feed_comments(TestNoCommentsFeed, "No item_comments method", expected_comments=0)
+    
+    print("\n" + "=" * 60)
+    print("EDGE CASE SUMMARY:")
+    print(f"  None comments: {'PASS' if test1 else 'FAIL'}")
+    print(f"  Conflict resolution: {'PASS' if test2 else 'FAIL'}")
+    print(f"  Empty string comments: {'PASS' if test3 else 'FAIL'}")
+    print(f"  No comments method: {'PASS' if test4 else 'FAIL'}")
+    
+    if all([test1, test2, test3, test4]):
+        print("\n✓ All edge cases pass!")
+    else:
+        print("\n✗ Some edge cases failed.")
+
+if __name__ == '__main__':
+    main()
diff --git a/test_comments_support.py b/test_comments_support.py
new file mode 100644
index 0000000000..3a213d05b8
--- /dev/null
+++ b/test_comments_support.py
@@ -0,0 +1,173 @@
+#!/usr/bin/env python
+"""
+Test script to verify item_comments support in Django syndication framework.
+"""
+import os
+import sys
+import django
+from django.conf import settings
+from django.contrib.syndication import views
+from django.utils import feedgenerator
+from xml.dom import minidom
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+            'django.contrib.sites',
+            'django.contrib.syndication',
+        ],
+        SECRET_KEY='test-secret-key',
+        SITE_ID=1,
+        USE_TZ=True,
+    )
+    django.setup()
+    
+    # Create the database tables
+    from django.core.management import call_command
+    call_command('migrate', verbosity=0, interactive=False)
+
+# Create a mock item class
+class MockItem:
+    def __init__(self, title, link, description, comments_url):
+        self.title = title
+        self.link = link
+        self.description = description
+        self.comments_url = comments_url
+    
+    def get_absolute_url(self):
+        return self.link
+
+# Test feed with item_comments method
+class TestCommentsFeed(views.Feed):
+    title = 'Test Feed with Comments'
+    link = '/test/'
+    description = 'A test feed that includes comments'
+    
+    def items(self):
+        return [
+            MockItem(
+                title='Test Item 1',
+                link='/item/1/',
+                description='First test item',
+                comments_url='/comments/1/'
+            ),
+            MockItem(
+                title='Test Item 2', 
+                link='/item/2/',
+                description='Second test item',
+                comments_url='/comments/2/'
+            )
+        ]
+    
+    def item_comments(self, item):
+        return item.comments_url
+
+# Test feed using item_extra_kwargs (current workaround)
+class TestCommentsViaExtraKwargsFeed(views.Feed):
+    title = 'Test Feed with Comments via Extra Kwargs'
+    link = '/test/'
+    description = 'A test feed that includes comments via extra_kwargs'
+    
+    def items(self):
+        return [
+            MockItem(
+                title='Test Item 1',
+                link='/item/1/',
+                description='First test item',
+                comments_url='/comments/1/'
+            ),
+            MockItem(
+                title='Test Item 2',
+                link='/item/2/',
+                description='Second test item',
+                comments_url='/comments/2/'
+            )
+        ]
+    
+    def item_extra_kwargs(self, item):
+        return {'comments': item.comments_url}
+
+def test_feed_comments(feed_class, test_name):
+    """Test a feed class and check if comments are included in the RSS output."""
+    print(f"\n=== Testing {test_name} ===")
+    
+    # Create a mock request
+    class MockRequest:
+        def is_secure(self):
+            return False
+        def get_host(self):
+            return 'example.com'
+        path = '/test/'
+    
+    request = MockRequest()
+    feed = feed_class()
+    
+    try:
+        # Get the feed
+        feed_obj = feed.get_feed(None, request)
+        
+        # Generate RSS XML
+        output = feed_obj.writeString('utf-8')
+        
+        # Parse XML to check for comments elements
+        doc = minidom.parseString(output)
+        comments_elements = doc.getElementsByTagName('comments')
+        
+        print(f"Number of <comments> elements found: {len(comments_elements)}")
+        
+        if comments_elements:
+            for i, elem in enumerate(comments_elements):
+                content = elem.firstChild.nodeValue if elem.firstChild else "None"
+                print(f"  Comment {i+1}: {content}")
+        
+        # Check if we have the expected number of comments
+        if len(comments_elements) == 2:
+            print("✓ SUCCESS: Comments are properly included in the feed")
+            return True
+        else:
+            print("✗ FAILURE: Comments are missing or incomplete")
+            print("\nGenerated RSS:")
+            print(output)
+            return False
+            
+    except Exception as e:
+        print(f"✗ ERROR: {e}")
+        import traceback
+        traceback.print_exc()
+        return False
+
+def main():
+    print("Testing Django syndication framework comments support")
+    print("=" * 60)
+    
+    # Test the workaround (should work)
+    success1 = test_feed_comments(TestCommentsViaExtraKwargsFeed, "Comments via item_extra_kwargs (workaround)")
+    
+    # Test the desired feature (currently won't work, should work after fix)
+    success2 = test_feed_comments(TestCommentsFeed, "Comments via item_comments method")
+    
+    print("\n" + "=" * 60)
+    print("SUMMARY:")
+    print(f"  Workaround (item_extra_kwargs): {'PASS' if success1 else 'FAIL'}")
+    print(f"  Direct method (item_comments): {'PASS' if success2 else 'FAIL'}")
+    
+    if success1 and not success2:
+        print("\nThe issue is confirmed: item_comments method is not supported.")
+        print("The workaround using item_extra_kwargs works correctly.")
+    elif success1 and success2:
+        print("\nBoth methods work! The feature has been implemented.")
+    else:
+        print("\nUnexpected results. Please check the implementation.")
+
+if __name__ == '__main__':
+    main()

2026-01-06 15:07:13,131 - INFO - ------------------------------
2026-01-06 15:07:13,131 - INFO - END Runtime Completion Fn
2026-01-06 15:07:13,132 - INFO - ------------------------------
2026-01-06 15:07:13,132 - INFO - Got git diff for instance django__django-13230:
--------
diff --git a/django/contrib/syndication/views.py b/django/contrib/syndication/views.py
index 68ffb0bfe0..6f1d2e6647 100644
--- a/django/contrib/syndication/views.py
+++ b/django/contrib/syndication/views.py
@@ -199,6 +199,11 @@ class Feed:
             if updateddate and is_naive(updateddate):
                 updateddate = make_aware(updateddate, tz)
 
+            extra_kwargs = self.item_extra_kwargs(item)
+            comments = self._get_dynamic_attr('item_comments', item)
+            if comments is not None and 'comments' not in extra_kwargs:
+                extra_kwargs['comments'] = comments
+            
             feed.add_item(
                 title=title,
                 link=link,
@@ -214,6 +219,6 @@ class Feed:
                 author_link=author_link,
                 categories=self._get_dynamic_attr('item_categories', item),
                 item_copyright=self._get_dynamic_attr('item_copyright', item),
-                **self.item_extra_kwargs(item)
+                **extra_kwargs
             )
         return feed
diff --git a/test_atom_comments.py b/test_atom_comments.py
new file mode 100644
index 0000000000..b63069fee5
--- /dev/null
+++ b/test_atom_comments.py
@@ -0,0 +1,131 @@
+#!/usr/bin/env python
+"""
+Test that item_comments works with Atom feeds as well.
+"""
+import os
+import sys
+import django
+from django.conf import settings
+from django.contrib.syndication import views
+from django.utils import feedgenerator
+from xml.dom import minidom
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+            'django.contrib.sites',
+            'django.contrib.syndication',
+        ],
+        SECRET_KEY='test-secret-key',
+        SITE_ID=1,
+        USE_TZ=True,
+    )
+    django.setup()
+    
+    # Create the database tables
+    from django.core.management import call_command
+    call_command('migrate', verbosity=0, interactive=False)
+
+# Create a mock item class
+class MockItem:
+    def __init__(self, title, link, description, comments_url):
+        self.title = title
+        self.link = link
+        self.description = description
+        self.comments_url = comments_url
+    
+    def get_absolute_url(self):
+        return self.link
+
+# Test Atom feed with item_comments
+class TestAtomCommentsFeed(views.Feed):
+    title = 'Test Atom Feed with Comments'
+    link = '/test/'
+    description = 'A test Atom feed that includes comments'
+    feed_type = feedgenerator.Atom1Feed
+    
+    def items(self):
+        return [
+            MockItem(
+                title='Test Item 1',
+                link='/item/1/',
+                description='First test item',
+                comments_url='/comments/1/'
+            )
+        ]
+    
+    def item_comments(self, item):
+        return item.comments_url
+
+def test_atom_feed_comments():
+    """Test that Atom feeds handle comments correctly."""
+    print("\n=== Testing Atom Feed with Comments ===")
+    
+    # Create a mock request
+    class MockRequest:
+        def is_secure(self):
+            return False
+        def get_host(self):
+            return 'example.com'
+        path = '/test/'
+    
+    request = MockRequest()
+    feed = TestAtomCommentsFeed()
+    
+    try:
+        # Get the feed
+        feed_obj = feed.get_feed(None, request)
+        
+        # Generate Atom XML
+        output = feed_obj.writeString('utf-8')
+        
+        print("Generated Atom XML (first 500 chars):")
+        print(output[:500] + "..." if len(output) > 500 else output)
+        
+        # Parse XML to check structure
+        doc = minidom.parseString(output)
+        
+        # Check if it's a valid Atom feed
+        feed_elements = doc.getElementsByTagName('feed')
+        if feed_elements:
+            print("✓ Valid Atom feed structure")
+        
+        # Check for entries
+        entry_elements = doc.getElementsByTagName('entry')
+        print(f"Number of <entry> elements: {len(entry_elements)}")
+        
+        # Note: Atom doesn't have a standard <comments> element like RSS
+        # The comments would need to be handled via a custom extension or link element
+        print("✓ Atom feed generated successfully (comments passed to feedgenerator)")
+        return True
+            
+    except Exception as e:
+        print(f"✗ ERROR: {e}")
+        import traceback
+        traceback.print_exc()
+        return False
+
+def main():
+    print("Testing Django syndication framework with Atom feeds and comments")
+    print("=" * 60)
+    
+    success = test_atom_feed_comments()
+    
+    print("\n" + "=" * 60)
+    if success:
+        print("✓ Atom feed test passed!")
+    else:
+        print("✗ Atom feed test failed.")
+
+if __name__ == '__main__':
+    main()
diff --git a/test_comments_edge_cases.py b/test_comments_edge_cases.py
new file mode 100644
index 0000000000..81843e3c16
--- /dev/null
+++ b/test_comments_edge_cases.py
@@ -0,0 +1,204 @@
+#!/usr/bin/env python
+"""
+Test edge cases for item_comments support in Django syndication framework.
+"""
+import os
+import sys
+import django
+from django.conf import settings
+from django.contrib.syndication import views
+from django.utils import feedgenerator
+from xml.dom import minidom
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+            'django.contrib.sites',
+            'django.contrib.syndication',
+        ],
+        SECRET_KEY='test-secret-key',
+        SITE_ID=1,
+        USE_TZ=True,
+    )
+    django.setup()
+    
+    # Create the database tables
+    from django.core.management import call_command
+    call_command('migrate', verbosity=0, interactive=False)
+
+# Create a mock item class
+class MockItem:
+    def __init__(self, title, link, description, comments_url=None):
+        self.title = title
+        self.link = link
+        self.description = description
+        self.comments_url = comments_url
+    
+    def get_absolute_url(self):
+        return self.link
+
+# Test feed with item_comments returning None
+class TestCommentsNoneFeed(views.Feed):
+    title = 'Test Feed with None Comments'
+    link = '/test/'
+    description = 'A test feed where item_comments returns None'
+    
+    def items(self):
+        return [
+            MockItem(
+                title='Test Item 1',
+                link='/item/1/',
+                description='First test item',
+                comments_url=None
+            )
+        ]
+    
+    def item_comments(self, item):
+        return None
+
+# Test feed with both item_comments and item_extra_kwargs returning comments
+class TestCommentsConflictFeed(views.Feed):
+    title = 'Test Feed with Comments Conflict'
+    link = '/test/'
+    description = 'A test feed where both item_comments and item_extra_kwargs return comments'
+    
+    def items(self):
+        return [
+            MockItem(
+                title='Test Item 1',
+                link='/item/1/',
+                description='First test item',
+                comments_url='/comments/1/'
+            )
+        ]
+    
+    def item_comments(self, item):
+        return '/comments/from-method/'
+    
+    def item_extra_kwargs(self, item):
+        return {'comments': '/comments/from-extra-kwargs/'}
+
+# Test feed with item_comments returning empty string
+class TestCommentsEmptyFeed(views.Feed):
+    title = 'Test Feed with Empty Comments'
+    link = '/test/'
+    description = 'A test feed where item_comments returns empty string'
+    
+    def items(self):
+        return [
+            MockItem(
+                title='Test Item 1',
+                link='/item/1/',
+                description='First test item'
+            )
+        ]
+    
+    def item_comments(self, item):
+        return ''
+
+# Test feed without item_comments method
+class TestNoCommentsFeed(views.Feed):
+    title = 'Test Feed without Comments'
+    link = '/test/'
+    description = 'A test feed without item_comments method'
+    
+    def items(self):
+        return [
+            MockItem(
+                title='Test Item 1',
+                link='/item/1/',
+                description='First test item'
+            )
+        ]
+
+def test_feed_comments(feed_class, test_name, expected_comments=None):
+    """Test a feed class and check if comments are included in the RSS output."""
+    print(f"\n=== Testing {test_name} ===")
+    
+    # Create a mock request
+    class MockRequest:
+        def is_secure(self):
+            return False
+        def get_host(self):
+            return 'example.com'
+        path = '/test/'
+    
+    request = MockRequest()
+    feed = feed_class()
+    
+    try:
+        # Get the feed
+        feed_obj = feed.get_feed(None, request)
+        
+        # Generate RSS XML
+        output = feed_obj.writeString('utf-8')
+        
+        # Parse XML to check for comments elements
+        doc = minidom.parseString(output)
+        comments_elements = doc.getElementsByTagName('comments')
+        
+        print(f"Number of <comments> elements found: {len(comments_elements)}")
+        
+        if comments_elements:
+            for i, elem in enumerate(comments_elements):
+                content = elem.firstChild.nodeValue if elem.firstChild else "None"
+                print(f"  Comment {i+1}: '{content}'")
+        
+        # Check expectations
+        if expected_comments is None:
+            # Expect no comments
+            if len(comments_elements) == 0:
+                print("✓ SUCCESS: No comments as expected")
+                return True
+            else:
+                print("✗ FAILURE: Unexpected comments found")
+                return False
+        else:
+            # Expect specific number of comments
+            if len(comments_elements) == expected_comments:
+                print(f"✓ SUCCESS: Found expected {expected_comments} comment(s)")
+                return True
+            else:
+                print(f"✗ FAILURE: Expected {expected_comments} comments, found {len(comments_elements)}")
+                return False
+            
+    except Exception as e:
+        print(f"✗ ERROR: {e}")
+        import traceback
+        traceback.print_exc()
+        return False
+
+def main():
+    print("Testing Django syndication framework comments edge cases")
+    print("=" * 60)
+    
+    # Test various edge cases
+    test1 = test_feed_comments(TestCommentsNoneFeed, "item_comments returns None", expected_comments=0)
+    test2 = test_feed_comments(TestCommentsConflictFeed, "Both item_comments and item_extra_kwargs return comments", expected_comments=1)
+    test3 = test_feed_comments(TestCommentsEmptyFeed, "item_comments returns empty string", expected_comments=1)
+    test4 = test_feed_comments(TestNoCommentsFeed, "No item_comments method", expected_comments=0)
+    
+    print("\n" + "=" * 60)
+    print("EDGE CASE SUMMARY:")
+    print(f"  None comments: {'PASS' if test1 else 'FAIL'}")
+    print(f"  Conflict resolution: {'PASS' if test2 else 'FAIL'}")
+    print(f"  Empty string comments: {'PASS' if test3 else 'FAIL'}")
+    print(f"  No comments method: {'PASS' if test4 else 'FAIL'}")
+    
+    if all([test1, test2, test3, test4]):
+        print("\n✓ All edge cases pass!")
+    else:
+        print("\n✗ Some edge cases failed.")
+
+if __name__ == '__main__':
+    main()
diff --git a/test_comments_support.py b/test_comments_support.py
new file mode 100644
index 0000000000..3a213d05b8
--- /dev/null
+++ b/test_comments_support.py
@@ -0,0 +1,173 @@
+#!/usr/bin/env python
+"""
+Test script to verify item_comments support in Django syndication framework.
+"""
+import os
+import sys
+import django
+from django.conf import settings
+from django.contrib.syndication import views
+from django.utils import feedgenerator
+from xml.dom import minidom
+
+# Configure Django settings
+if not settings.configured:
+    settings.configure(
+        DEBUG=True,
+        DATABASES={
+            'default': {
+                'ENGINE': 'django.db.backends.sqlite3',
+                'NAME': ':memory:',
+            }
+        },
+        INSTALLED_APPS=[
+            'django.contrib.contenttypes',
+            'django.contrib.auth',
+            'django.contrib.sites',
+            'django.contrib.syndication',
+        ],
+        SECRET_KEY='test-secret-key',
+        SITE_ID=1,
+        USE_TZ=True,
+    )
+    django.setup()
+    
+    # Create the database tables
+    from django.core.management import call_command
+    call_command('migrate', verbosity=0, interactive=False)
+
+# Create a mock item class
+class MockItem:
+    def __init__(self, title, link, description, comments_url):
+        self.title = title
+        self.link = link
+        self.description = description
+        self.comments_url = comments_url
+    
+    def get_absolute_url(self):
+        return self.link
+
+# Test feed with item_comments method
+class TestCommentsFeed(views.Feed):
+    title = 'Test Feed with Comments'
+    link = '/test/'
+    description = 'A test feed that includes comments'
+    
+    def items(self):
+        return [
+            MockItem(
+                title='Test Item 1',
+                link='/item/1/',
+                description='First test item',
+                comments_url='/comments/1/'
+            ),
+            MockItem(
+                title='Test Item 2', 
+                link='/item/2/',
+                description='Second test item',
+                comments_url='/comments/2/'
+            )
+        ]
+    
+    def item_comments(self, item):
+        return item.comments_url
+
+# Test feed using item_extra_kwargs (current workaround)
+class TestCommentsViaExtraKwargsFeed(views.Feed):
+    title = 'Test Feed with Comments via Extra Kwargs'
+    link = '/test/'
+    description = 'A test feed that includes comments via extra_kwargs'
+    
+    def items(self):
+        return [
+            MockItem(
+                title='Test Item 1',
+                link='/item/1/',
+                description='First test item',
+                comments_url='/comments/1/'
+            ),
+            MockItem(
+                title='Test Item 2',
+                link='/item/2/',
+                description='Second test item',
+                comments_url='/comments/2/'
+            )
+        ]
+    
+    def item_extra_kwargs(self, item):
+        return {'comments': item.comments_url}
+
+def test_feed_comments(feed_class, test_name):
+    """Test a feed class and check if comments are included in the RSS output."""
+    print(f"\n=== Testing {test_name} ===")
+    
+    # Create a mock request
+    class MockRequest:
+        def is_secure(self):
+            return False
+        def get_host(self):
+            return 'example.com'
+        path = '/test/'
+    
+    request = MockRequest()
+    feed = feed_class()
+    
+    try:
+        # Get the feed
+        feed_obj = feed.get_feed(None, request)
+        
+        # Generate RSS XML
+        output = feed_obj.writeString('utf-8')
+        
+        # Parse XML to check for comments elements
+        doc = minidom.parseString(output)
+        comments_elements = doc.getElementsByTagName('comments')
+        
+        print(f"Number of <comments> elements found: {len(comments_elements)}")
+        
+        if comments_elements:
+            for i, elem in enumerate(comments_elements):
+                content = elem.firstChild.nodeValue if elem.firstChild else "None"
+                print(f"  Comment {i+1}: {content}")
+        
+        # Check if we have the expected number of comments
+        if len(comments_elements) == 2:
+            print("✓ SUCCESS: Comments are properly included in the feed")
+            return True
+        else:
+            print("✗ FAILURE: Comments are missing or incomplete")
+            print("\nGenerated RSS:")
+            print(output)
+            return False
+            
+    except Exception as e:
+        print(f"✗ ERROR: {e}")
+        import traceback
+        traceback.print_exc()
+        return False
+
+def main():
+    print("Testing Django syndication framework comments support")
+    print("=" * 60)
+    
+    # Test the workaround (should work)
+    success1 = test_feed_comments(TestCommentsViaExtraKwargsFeed, "Comments via item_extra_kwargs (workaround)")
+    
+    # Test the desired feature (currently won't work, should work after fix)
+    success2 = test_feed_comments(TestCommentsFeed, "Comments via item_comments method")
+    
+    print("\n" + "=" * 60)
+    print("SUMMARY:")
+    print(f"  Workaround (item_extra_kwargs): {'PASS' if success1 else 'FAIL'}")
+    print(f"  Direct method (item_comments): {'PASS' if success2 else 'FAIL'}")
+    
+    if success1 and not success2:
+        print("\nThe issue is confirmed: item_comments method is not supported.")
+        print("The workaround using item_extra_kwargs works correctly.")
+    elif success1 and success2:
+        print("\nBoth methods work! The feature has been implemented.")
+    else:
+        print("\nUnexpected results. Please check the implementation.")
+
+if __name__ == '__main__':
+    main()
--------
2026-01-06 15:07:18,515 - INFO - Using instance container image: docker.io/swebench/sweb.eval.x86_64.django_1776_django-15695:latest. Please make sure this image exists. Submit an issue on https://github.com/OpenHands/OpenHands if you run into any issues.
2026-01-06 15:07:18,515 - INFO - Resource mapping for princeton-nlp__SWE-bench_Lite-test not found.
2026-01-06 15:07:18,516 - INFO - Logging LLM completions for instance django__django-15695 to ./continuum32/princeton-nlp__SWE-bench_Lite-test/CodeActAgent/GLM-4.6-FP8_maxiter_135/llm_completions/django__django-15695
2026-01-06 15:07:18,516 - INFO - Config file not found: config.toml. Error: [Errno 2] No such file or directory: 'config.toml'
2026-01-06 15:07:18,516 - INFO - Config file not found: [Errno 2] No such file or directory: 'config.toml'. Toml values have not been applied.
